<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dataset</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='60%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='120'>âš¡</text></svg>">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .chart-container {
            width: 800px;
            height: 500px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 0.85rem; /* Smaller font size */
            table-layout: fixed; /* For better control of column widths */
        }
        /* Column width specifications */
        table th:nth-child(1), table td:nth-child(1) { width: 20%; } /* File Path column */
        table th:nth-child(2), table td:nth-child(2) { width: 15%; } /* Function column - narrower */
        table th:nth-child(3), table td:nth-child(3) { width: 15%; } /* Summarize by GPT-4o column - narrower */
        table th:nth-child(4), table td:nth-child(4) { width: 15%; } /* GHC Query column */
        table th:nth-child(5), table td:nth-child(5) { width: 30%; } /* Code Snippet column */
        @media (max-width: 768px) {
            table {
                font-size: 0.75rem; /* Even smaller on mobile */
            }
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px; /* Slightly smaller padding */
            text-align: left;
            max-width: 200px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease-out;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9; /* Light gray for even rows */
        }
        tr:nth-child(odd) {
            background-color: #ffffff; /* White for odd rows */
        }
        tr:hover {
            background-color: #f0f7ff; /* Light blue hover effect */
        }
        td .cell-content {
            max-height: 3em; /* Approximately two lines of text */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        th {
            background-color: #eaeaea; /* Slightly darker header */
            max-height: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
            font-weight: bold;
        }
        td .cell-content.expanded {
            white-space: pre-wrap;
            max-height: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
            color: #0066cc; /* Blue color for expanded content */
            background-color: rgba(0, 102, 204, 0.05); /* Very light blue background */
        }
        .code-snippet-cell {
            font-family: Consolas, 'Courier New', Courier, monospace;
            font-size: 0.8rem; /* Smaller font for code */
        }
        .stats-container {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f7ff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stats-value {
            font-weight: bold;
            color: #0066cc;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Dataset for GHC code search</h1>

    <!-- <div class="stats-container">
        <p>Haystack symbol match success Rate <span id="success-rate" class="stats-value">0%</span></p>
    </div>

    <div class="chart-container">
        <canvas id="posChart"></canvas>
    </div>

    <div class="chart-container">
        <h2>File Distribution</h2>
        <canvas id="fileMrrHistogram"></canvas>
    </div>

    <div class="chart-container">
        <h2>Time Cost Analysis</h2>
        <canvas id="timeCostChart"></canvas>
    </div> -->

    <h2>Dataset</h2>
    <div id="table-container"></div>

    <script>
        // Dataset
        const dataset = [{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\safety_hub\\abusive_notification_permissions_manager.cc:267-301","function":"AbusiveNotificationPermissionsManager::ShouldCheckOrigin","codesnippet":"{\n  DCHECK(hcsm_);\n  // Skip wildcard patterns that don't belong to a single origin.\n  if (!setting.primary_pattern.MatchesSingleOrigin()) {\n    return false;\n  }\n  if (setting.setting_value == CONTENT_SETTING_ALLOW) {\n    // Secondary pattern should be wildcard for notification permissions. If\n    // not, the permission should be ignored.\n    if (setting.secondary_pattern != ContentSettingsPattern::Wildcard()) {\n      return false;\n    }\n    // If the url is not valid, do not check the origin.\n    GURL setting_url = setting.primary_pattern.ToRepresentativeUrl();\n    if (!setting_url.is_valid()) {\n      return false;\n    }\n    // If the url does not have a REVOKED_ABUSIVE_NOTIFICATION_PERMISSIONS\n    // setting value, we should check the origin.\n    base::Value stored_value =\n        safety_hub_util::GetRevokedAbusiveNotificationPermissionsSettingValue(\n            hcsm_.get(), setting_url);\n    if (stored_value.is_none()) {\n      return true;\n    }\n    // If the url has a REVOKED_ABUSIVE_NOTIFICATION_PERMISSIONS setting value\n    // and the NOTIFICATIONS permission is set to CONTENT_SETTING_ALLOW, then\n    // the user chose to ignore the origin for future revocations so the setting\n    // value should specify ignore.\n    DCHECK(safety_hub_util::IsAbusiveNotificationRevocationIgnored(\n        hcsm_.get(), setting.primary_pattern.ToRepresentativeUrl()));\n    return false;\n  }\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks if a notification permission setting should be ignored based on origin and revocation status."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\renderer_context_menu\\render_view_context_menu_base.cc:439-465","function":"RenderViewContextMenuBase::ExecuteCommand","codesnippet":"{\n  command_executed_ = true;\n  RecordUsedItem(id);\n\n  // Notify all observers the command to be executed.\n  for (auto& observer : observers_)\n    observer.CommandWillBeExecuted(id);\n\n  // If this command is is added by one of our observers, we dispatch\n  // it to the observer.\n  for (auto& observer : observers_) {\n    if (observer.IsCommandIdSupported(id))\n      return observer.ExecuteCommand(id);\n  }\n\n  // Process custom actions range.\n  if (IsContentCustomCommandId(id)) {\n    unsigned action = id - content_context_custom_first;\n    const GURL& link_followed = params_.link_followed;\n#if BUILDFLAG(ENABLE_PLUGINS)\n    HandleAuthorizeAllPlugins();\n#endif\n    source_web_contents_->ExecuteCustomContextMenuCommand(action,\n                                                          link_followed);\n    return;\n  }\n  command_executed_ = false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Executes a command and notifies observers."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\devtools\\protocol\\pwa_handler.cc:284-313","function":"PWAHandler::InstallFromUrl","codesnippet":"{\n  GURL url{in_install_url_or_bundle_url};\n  // Technically unnecessary, but let's check it anyway to avoid leaking\n  // unexpected schemes.\n  if (!url.is_valid()) {\n    std::move(callback)->sendFailure(\n        protocol::Response::InvalidParams(base::StrCat(\n            {\"Invalid installUrlOrBundleUrl \", in_install_url_or_bundle_url})));\n    return;\n  }\n  // TODO(crbug.com/337872319): Support installing isolated apps on chrome-os.\n  if (!url.SchemeIsHTTPOrHTTPS()) {\n    std::move(callback)->sendFailure(\n        protocol::Response::MethodNotFound(base::StrCat(\n            {\"Installing webapp from url \", in_install_url_or_bundle_url,\n             \" with scheme [\", url.scheme(), \"] is not supported yet.\"})));\n    return;\n  }\n  auto* scheduler = GetScheduler();\n  if (!scheduler) {\n    std::move(callback)->sendFailure(errors::WebAppUnavailable());\n    return;\n  }\n  scheduler->FetchInstallInfoFromInstallUrl(\n      GURL{in_manifest_id}, url,\n      base::BindOnce(&PWAHandler::InstallFromInstallInfo,\n                     weak_ptr_factory_.GetWeakPtr(), in_manifest_id,\n                     in_install_url_or_bundle_url, std::move(callback)));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates a URL and initiates the installation of a web app if conditions are met."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\offline_items_collection\\core\\fail_state.cc:9-47","function":"ToFailState","codesnippet":"{\n  switch (static_cast<FailState>(value)) {\n    case FailState::NO_FAILURE:\n    case FailState::CANNOT_DOWNLOAD:\n    case FailState::NETWORK_INSTABILITY:\n    case FailState::FILE_FAILED:\n    case FailState::FILE_ACCESS_DENIED:\n    case FailState::FILE_NO_SPACE:\n    case FailState::FILE_NAME_TOO_LONG:\n    case FailState::FILE_TOO_LARGE:\n    case FailState::FILE_VIRUS_INFECTED:\n    case FailState::FILE_TRANSIENT_ERROR:\n    case FailState::FILE_BLOCKED:\n    case FailState::FILE_SECURITY_CHECK_FAILED:\n    case FailState::FILE_TOO_SHORT:\n    case FailState::FILE_HASH_MISMATCH:\n    case FailState::FILE_SAME_AS_SOURCE:\n    case FailState::NETWORK_FAILED:\n    case FailState::NETWORK_TIMEOUT:\n    case FailState::NETWORK_DISCONNECTED:\n    case FailState::NETWORK_SERVER_DOWN:\n    case FailState::NETWORK_INVALID_REQUEST:\n    case FailState::SERVER_FAILED:\n    case FailState::SERVER_NO_RANGE:\n    case FailState::SERVER_BAD_CONTENT:\n    case FailState::SERVER_UNAUTHORIZED:\n    case FailState::SERVER_CERT_PROBLEM:\n    case FailState::SERVER_FORBIDDEN:\n    case FailState::SERVER_UNREACHABLE:\n    case FailState::SERVER_CONTENT_LENGTH_MISMATCH:\n    case FailState::SERVER_CROSS_ORIGIN_REDIRECT:\n    case FailState::USER_CANCELED:\n    case FailState::USER_SHUTDOWN:\n    case FailState::CRASH:\n    case FailState::FILE_BLOCKED_BY_APPLICATION_GUARD:\n      *fail_state = static_cast<FailState>(value);\n      return true;\n  }\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if a given value corresponds to a specific failure state and updates the failure state accordingly."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\toolbar\\pinned_action_toolbar_button.cc:213-236","function":"PinnedActionToolbarButton::UpdateIcon","codesnippet":"{\n  const std::optional<VectorIcons>& icons = GetVectorIcons();\n  // If the button is a cached permanent button the color provider will not be\n  // available.\n  if (!icons.has_value() || !GetColorProvider()) {\n    return;\n  }\n\n  const gfx::VectorIcon& icon = ui::TouchUiController::Get()->touch_ui()\n                                    ? icons->touch_icon\n                                    : icons->icon;\n\n  if (is_icon_visible_ && action_engaged_) {\n    UpdateIconsWithColors(\n        icon, GetColorProvider()->GetColor(kColorToolbarActionItemEngaged),\n        GetColorProvider()->GetColor(kColorToolbarActionItemEngaged),\n        GetColorProvider()->GetColor(kColorToolbarActionItemEngaged),\n        GetForegroundColor(ButtonState::STATE_DISABLED));\n  } else {\n    UpdateIconsWithColors(icon, GetForegroundColor(ButtonState::STATE_NORMAL),\n                          GetForegroundColor(ButtonState::STATE_HOVERED),\n                          GetForegroundColor(ButtonState::STATE_PRESSED),\n                          GetForegroundColor(ButtonState::STATE_DISABLED));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates button icons with appropriate colors based on engagement state and UI mode."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\collaboration\\internal\\messaging\\storage\\messaging_backend_store_impl.cc:527-567","function":"MessagingBackendStoreImpl::DeleteExpiredMessages","codesnippet":"{\n  std::vector<std::string> ids_to_remove;\n\n  // Loop through every message in the store, remove them if they are expired.\n  base::Time now = base::Time::Now();\n  for (auto& [key, messages_per_group] : messages_) {\n    auto& tab_messages = messages_per_group->tab_messages;\n    for (auto it = tab_messages.begin(); it != tab_messages.end();) {\n      if (IsMessageExpired(it->second, now)) {\n        ids_to_remove.push_back(it->second.uuid());\n        it = tab_messages.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    auto& tab_group_messages = messages_per_group->tab_group_messages;\n    for (auto it = tab_group_messages.begin();\n         it != tab_group_messages.end();) {\n      if (IsMessageExpired(it->second, now)) {\n        ids_to_remove.push_back(it->second.uuid());\n        it = tab_group_messages.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    auto& collab_messages = messages_per_group->collaboration_messages;\n    for (auto it = collab_messages.begin(); it != collab_messages.end();) {\n      if (IsMessageExpired(*it, now)) {\n        ids_to_remove.push_back(it->uuid());\n        it = collab_messages.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    if (!ids_to_remove.empty()) {\n      database_->Delete(ids_to_remove);\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Removes expired messages from storage and deletes their IDs from the database."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\api\\declarative_content\\declarative_content_css_condition_tracker.cc:37-60","function":"DeclarativeContentCssPredicate::Create","codesnippet":"{\n  std::vector<std::string> css_rules;\n  if (value.is_list()) {\n    for (const base::Value& css_rule_value : value.GetList()) {\n      if (!css_rule_value.is_string()) {\n        *error = base::StringPrintf(kCssInvalidTypeOfParameter,\n                                    declarative_content_constants::kCss);\n        return nullptr;\n      }\n      css_rules.push_back(css_rule_value.GetString());\n    }\n  } else {\n    *error = base::StringPrintf(kCssInvalidTypeOfParameter,\n                                declarative_content_constants::kCss);\n    return nullptr;\n  }\n\n  return !css_rules.empty()\n             ? base::WrapUnique(\n                   new DeclarativeContentCssPredicate(evaluator, css_rules))\n             : std::unique_ptr<DeclarativeContentCssPredicate>();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses CSS rules from a list and returns a predicate object if valid."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\leveldb_proto\\internal\\shared_proto_database_client.cc:146-171","function":"SharedProtoDatabaseClient::DestroyObsoleteSharedProtoDatabaseClients","codesnippet":"{\n  ProtoLevelDBWrapper* db_wrapper_ptr = db_wrapper.get();\n  scoped_refptr<ObsoleteClientsDbHolder> db_holder =\n      new ObsoleteClientsDbHolder(std::move(db_wrapper), std::move(callback));\n\n  const ProtoDbType* list = g_obsolete_client_list_for_testing\n                                ? g_obsolete_client_list_for_testing\n                                : kObsoleteSharedProtoDbTypeClients;\n  for (size_t i = 0; list[i] != ProtoDbType::LAST; ++i) {\n    // Callback keeps a ref pointer to db_holder alive till the changes are\n    // done. |db_holder| will be destroyed once all the RemoveKeys() calls\n    // return.\n    Callbacks::UpdateCallback callback_wrapper =\n        base::BindOnce([](scoped_refptr<ObsoleteClientsDbHolder> db_holder,\n                          bool success) { db_holder->set_success(success); },\n                       db_holder);\n    // Remove all type prefixes for the client.\n    // TODO(ssid): Support cleanup of namespaces for clients. This code assumes\n    // the prefix contains the client namespace at the beginning.\n    db_wrapper_ptr->RemoveKeys(\n        base::BindRepeating([](const std::string& key) { return true; }),\n        SharedProtoDatabaseClient::PrefixForDatabase(list[i]).value(),\n        std::move(callback_wrapper));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Removes obsolete client keys from the database."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\commands\\command_service.cc:286-312","function":"CommandService::FindCommandByName","codesnippet":"{\n  const base::Value::Dict& bindings =\n      profile_->GetPrefs()->GetDict(prefs::kExtensionCommands);\n  for (const auto it : bindings) {\n    const ExtensionId* extension = it.second.GetDict().FindString(kExtension);\n    if (!extension || *extension != extension_id)\n      continue;\n    const std::string* command_name =\n        it.second.GetDict().FindString(kCommandName);\n    if (!command_name || *command_name != command)\n      continue;\n    // Format stored in Preferences is: \"Platform:Shortcut[:ExtensionId]\".\n    std::string shortcut = it.first;\n    if (!IsForCurrentPlatform(shortcut))\n      continue;\n    std::optional<bool> global = it.second.GetDict().FindBool(kGlobal);\n\n    std::vector<std::string_view> tokens = base::SplitStringPiece(\n        shortcut, \":\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n    CHECK(tokens.size() >= 2);\n\n    return Command(*command_name, std::u16string(), std::string(tokens[1]),\n                   global.value_or(false));\n  }\n\n  return Command();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Retrieves a command configuration for a specific extension and platform."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\drive\\chromeos\\search_metadata.cc:40-81","function":"FindAndHighlight","codesnippet":"{\n  DCHECK(highlighted_text);\n  highlighted_text->clear();\n\n  // Check text matches with all queries.\n  size_t match_start = 0;\n  size_t match_length = 0;\n\n  std::u16string text16 = base::UTF8ToUTF16(text);\n  std::vector<bool> highlights(text16.size(), false);\n  for (const auto& query : queries) {\n    if (!query->Search(text16, &match_start, &match_length))\n      return false;\n\n    std::fill(highlights.begin() + match_start,\n              highlights.begin() + match_start + match_length, true);\n  }\n\n  // Generate highlighted text.\n  size_t start_current_segment = 0;\n\n  for (size_t i = 0; i < text16.size(); ++i) {\n    if (highlights[start_current_segment] == highlights[i])\n      continue;\n\n    AppendStringWithHighlight(\n        text16, start_current_segment, i - start_current_segment,\n        highlights[start_current_segment], highlighted_text);\n\n    start_current_segment = i;\n  }\n\n  DCHECK_GE(text16.size(), start_current_segment);\n  AppendStringWithHighlight(\n      text16, start_current_segment, text16.size() - start_current_segment,\n      highlights[start_current_segment], highlighted_text);\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Highlights text segments based on query matches."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync\\service\\sync_service.cc:65-84","function":"SyncService::IsSyncFeatureActive","codesnippet":"{\n  if (!IsSyncFeatureEnabled()) {\n    return false;\n  }\n  switch (GetTransportState()) {\n    case TransportState::DISABLED:\n    case TransportState::PAUSED:\n    case TransportState::START_DEFERRED:\n    case TransportState::INITIALIZING:\n    case TransportState::PENDING_DESIRED_CONFIGURATION:\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    case TransportState::START_AUTH_NOT_UIR:\n    case TransportState::START_AUTH_UIR:\n#endif  //  MICROSOFT_EDGE_BRANDING\n      return false;\n    case TransportState::CONFIGURING:\n    case TransportState::ACTIVE:\n      return true;\n  }\n  NOTREACHED();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if the sync feature is active based on transport state."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\ash\\login\\debug\\debug_overlay_handler.cc:113-143","function":"DebugOverlayHandler::HandleCaptureScreenshot","codesnippet":"{\n  aura::Window::Windows root_windows = Shell::GetAllRootWindows();\n  if (root_windows.size() == 0) {\n    return;\n  }\n\n  screenshot_index_++;\n  std::string filename_base =\n      base::StringPrintf(\"%04d - %s\", screenshot_index_, name.c_str());\n\n  for (size_t screen = 0; screen < root_windows.size(); ++screen) {\n    aura::Window* root_window = root_windows[screen];\n    gfx::Rect rect = root_window->bounds();\n    std::string filename = filename_base;\n    if (root_windows.size() > 1) {\n      filename.append(base::StringPrintf(\"- Display %zu\", screen));\n    }\n\n    if (add_resolution_to_filename_) {\n      filename.append(\"_\" + rect.size().ToString());\n    }\n\n    if (DarkLightModeController::Get()->IsDarkModeEnabled()) {\n      filename.append(\"_dark\");\n    }\n\n    filename.append(\".png\");\n    ui::GrabWindowSnapshotAsPNG(root_window, rect,\n                                base::BindOnce(&RunStoreScreenshotOnTaskRunner,\n                                               screenshot_dir_, filename));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Captures and saves screenshots of all root windows with descriptive filenames."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\attribution_reporting\\destination_set.cc:47-108","function":"DestinationSet::FromJSON","codesnippet":"{\n  if (!v) {\n    return base::unexpected(SourceRegistrationError::kDestinationMissing);\n  }\n\n  // Although we build this set iteratively, which results in O(n^2)\n  // construction, n is very small, so this is fine.\n  static_assert(kMaxDestinations == 3,\n                \"Consider using more performant set construction if the size \"\n                \"limit increases.\");\n  base::flat_set<net::SchemefulSite> destination_sites;\n\n  using AppendIfValidResult = base::expected<void, SourceRegistrationError>;\n\n  const auto append_if_valid =\n      [&](const std::string& str,\n          SourceRegistrationError error) -> AppendIfValidResult {\n    auto origin = SuitableOrigin::Deserialize(str);\n    if (!origin.has_value()) {\n      return base::unexpected(error);\n    }\n    destination_sites.emplace(*origin);\n    return base::ok();\n  };\n\n  RETURN_IF_ERROR(v->Visit(base::Overloaded{\n      [&](const std::string& str) {\n        return append_if_valid(\n            str, SourceRegistrationError::kDestinationUntrustworthy);\n      },\n      [&](const base::Value::List& list) -> AppendIfValidResult {\n        if (list.empty()) {\n          return base::unexpected(\n              SourceRegistrationError::kDestinationWrongType);\n        }\n\n        destination_sites.reserve(std::min(list.size(), kMaxDestinations));\n\n        for (const auto& item : list) {\n          const std::string* str = item.GetIfString();\n          if (!str) {\n            return base::unexpected(\n                SourceRegistrationError::kDestinationWrongType);\n          }\n          RETURN_IF_ERROR(append_if_valid(\n              *str, SourceRegistrationError::kDestinationListUntrustworthy));\n\n          if (destination_sites.size() > kMaxDestinations) {\n            return base::unexpected(\n                SourceRegistrationError::kDestinationWrongType);\n          }\n        }\n\n        return base::ok();\n      },\n      [](const auto&) -> AppendIfValidResult {\n        return base::unexpected(SourceRegistrationError::kDestinationWrongType);\n      },\n  }));\n\n  return DestinationSet(std::move(destination_sites));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates and constructs a set of destination sites from input data."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\installer\\util\\lzma_util.cc:192-247","function":"SevenZipDelegateImpl::OnEntry","codesnippet":"{\n  if (entry.file_path.ReferencesParent()) {\n    PLOG(ERROR) << \"Path contains a parent directory traversal which is not \"\n                   \"allowed because it could become a security issue: \"\n                << entry.file_path;\n    unpack_error_ = UNPACK_CREATE_FILE_ERROR;\n    return false;\n  }\n\n  base::FilePath file_path = location_.Append(entry.file_path);\n  if (output_file_)\n    *output_file_ = file_path;\n\n  CreateDirectory(file_path.DirName());\n\n  current_file_ =\n      base::File(file_path, base::File::FLAG_CREATE_ALWAYS |\n                                base::File::FLAG_READ | base::File::FLAG_WRITE |\n                                base::File::FLAG_WIN_EXCLUSIVE_READ |\n                                base::File::FLAG_WIN_EXCLUSIVE_WRITE |\n                                base::File::FLAG_CAN_DELETE_ON_CLOSE |\n                                base::File::FLAG_WIN_SHARE_DELETE);\n  if (!current_file_.IsValid()) {\n    PLOG(ERROR) << \"Invalid file\";\n    error_code_ = ::GetLastError();\n    unpack_error_ = UNPACK_CREATE_FILE_ERROR;\n    return false;\n  }\n\n  // The target file is deleted by default unless extracting succeeds.\n  current_file_.DeleteOnClose(true);\n\n  if (entry.file_size > 0) {\n    mapped_file_.emplace();\n    bool mapped_file_ok = mapped_file_->Initialize(\n        current_file_.Duplicate(), {0, static_cast<size_t>(entry.file_size)},\n        base::MemoryMappedFile::READ_WRITE_EXTEND);\n    if (!mapped_file_ok) {\n      PLOG(ERROR) << \"Can't map file to memory\";\n      error_code_ = ::GetLastError();\n      unpack_error_ = UNPACK_ALLOCATE_ERROR;\n      return false;\n    }\n\n    output = base::span<uint8_t>(mapped_file_->data(), mapped_file_->length());\n  } else {\n    output = base::span<uint8_t>();\n  }\n\n  // Clear the last error code before the entry is extracted to reduce the\n  // likelihood that it will hold an unrelated error code in case extraction\n  // fails.\n  ::SetLastError(ERROR_SUCCESS);\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and prepares a file for extraction, ensuring security and memory mapping."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\settings\\shared_settings_localized_strings_provider.cc:133-162","function":"AddLiveCaptionSectionStrings","codesnippet":"{\n  html_source->AddLocalizedString(\n      \"captionsEnableLiveCaptionTitle\",\n      IDS_SETTINGS_CAPTIONS_ENABLE_LIVE_CAPTION_TITLE);\n  html_source->AddLocalizedString(\n      \"captionsEnableLiveTranslateTitle\",\n      IDS_SETTINGS_CAPTIONS_ENABLE_LIVE_TRANSLATE_TITLE);\n  html_source->AddLocalizedString(\n      \"captionsEnableLiveTranslateSubtitle\",\n      IDS_SETTINGS_CAPTIONS_ENABLE_LIVE_TRANSLATE_SUBTITLE);\n  html_source->AddLocalizedString(\n      \"captionsMaskOffensiveWordsTitle\",\n      IDS_SETTINGS_CAPTIONS_MASK_OFFENSIVE_WORDS_TITLE);\n\n  const bool liveCaptionMultiLanguageEnabled =\n      base::FeatureList::IsEnabled(media::kEdgeLiveCaptionMultiLanguage);\n\n  const bool liveTranslateEnabled = media::IsLiveTranslateEnabled();\n\n  const int live_caption_subtitle_message =\n      GetLiveCaptionSubtitle(liveCaptionMultiLanguageEnabled);\n\n  html_source->AddLocalizedString(\"captionsEnableLiveCaptionSubtitle\",\n                                  live_caption_subtitle_message);\n  html_source->AddBoolean(\"enableLiveCaption\",\n                          captions::IsLiveCaptionFeatureSupported());\n  html_source->AddBoolean(\"enableLiveCaptionMultiLanguage\",\n                          liveCaptionMultiLanguageEnabled);\n\n  html_source->AddBoolean(\"enableLiveTranslate\", liveTranslateEnabled);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adds localized strings and feature flags for live caption and translation settings to the HTML source."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_wns_push\\portable_client\\mojo_socket_stream.cc:81-131","function":"MojoSocketStream::ConnectAsync","codesnippet":"{\n  DCHECK_EQ(m_state, State::Connecting);\n\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"wns_portable_client\", R\"(\n        semantics {\n          sender: \"WNS Portable Client\"\n          description:\n            \"TCP connection to the WNS notification servers.  \"\n            \"Supports reliable bi-directional messaging and push \"\n            \"notifications for multiple consumers.\"\n          trigger:\n            \"The connection is created when an application (e.g. Sync) \"\n            \"or a website using Web Push starts the WNS service, and is kept \"\n            \"alive as long as there are valid applications registered. \"\n            \"Messaging is application/website controlled.\"\n          data:\n            \"Arbitrary application-specific data.\"\n          destination: MICROSOFT_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: NO\n          setting:\n            \"Users can stop messages related to Sync by disabling Sync for \"\n            \"everything in settings. Messages related to Web Push can be \"\n            \"stopped by revoking the site permissions in settings. Messages \"\n            \"related to extensions can be stopped by uninstalling the \"\n            \"extension.\"\n          chrome_policy {\n            SyncDisabled {\n              SyncDisabled: True\n            }\n          }\n        }\n        comments:\n          \"'SyncDisabled' policy disables messages that are based on Sync, \"\n          \"but does not have any effect on other WNS messages.\"\n        )\");\n\n  network::mojom::ProxyResolvingSocketOptionsPtr options =\n      network::mojom::ProxyResolvingSocketOptions::New();\n  options->use_tls = true;\n\n  auto site = net::SchemefulSite(target_url);\n  socket_factory_->CreateProxyResolvingSocket(\n      target_url, net::NetworkAnonymizationKey::CreateFromFrameSite(site, site),\n      std::move(options),\n      net::MutableNetworkTrafficAnnotationTag(traffic_annotation),\n      socket_.BindNewPipeAndPassReceiver(), mojo::NullRemote() /* observer */,\n      base::BindOnce(&MojoSocketStream::OnConnectFinished,\n                     weak_factory_.GetWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Establishes a secure TCP connection to WNS notification servers."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_feedback\\ods_formatter.cc:23-98","function":"SetDiagnosticSessionAttributes","codesnippet":"{\n  session_json.SetByDottedPath(GetAttributePath(\"AppArchitecture\"),\n                               data.os_arch());\n  session_json.SetByDottedPath(GetAttributePath(\"AppBuild\"),\n                               data.edge_version());\n  // 'AppUILang' is used to indicate the browser (Anaheim) language.\n  session_json.SetByDottedPath(GetAttributePath(\"AppUILang\"),\n                               feedback_util::MapLangCodeToLcid(data.locale()));\n  session_json.SetByDottedPath(GetAttributePath(\"Browser\"),\n                               data.browser_name());\n  session_json.SetByDottedPath(GetAttributePath(\"BrowserVersion\"),\n                               data.chromium_version());\n  session_json.SetByDottedPath(GetAttributePath(\"Channel\"), data.channel());\n  session_json.SetByDottedPath(GetAttributePath(\"ClientName\"), \"Edge\");\n  session_json.SetByDottedPath(GetAttributePath(\"Country\"), data.country());\n  session_json.SetByDottedPath(GetAttributePath(\"FlightAudienceGroup\"),\n                               data.audience_group());\n  session_json.SetByDottedPath(GetAttributePath(\"InstallationType\"),\n                               data.install_source());\n  session_json.SetByDottedPath(GetAttributePath(\"InstallDate\"),\n                               data.install_date());\n  session_json.SetByDottedPath(GetAttributePath(\"OsBuild\"), data.os_build());\n  session_json.SetByDottedPath(\n      GetAttributePath(\"OsUserLang\"),\n      feedback_util::MapLangCodeToLcid(data.os_user_locale()));\n  session_json.SetByDottedPath(GetAttributePath(\"Platform\"), data.platform());\n  session_json.SetByDottedPath(GetAttributePath(\"SourceContext\"),\n                               data.source_context());\n  session_json.SetByDottedPath(GetAttributePath(\"SubmitTime\"),\n                               data.submit_time());\n  session_json.SetByDottedPath(GetAttributePath(\"SystemManufacturer\"),\n                               data.device_manufacturer());\n  session_json.SetByDottedPath(GetAttributePath(\"SystemProductName\"),\n                               data.device_model());\n\n  if (data.has_client_id()) {\n    session_json.SetByDottedPath(GetAttributePath(\"ClientId\"),\n                                 std::to_string(data.client_id_hash()));\n  }\n  if (!data.etag().empty()) {\n    session_json.SetByDottedPath(GetAttributePath(\"ETAG\"), data.etag());\n  }\n  if (!data.runtime_etag().empty()) {\n    session_json.SetByDottedPath(GetAttributePath(\"RuntimeETAG\"),\n                                 data.runtime_etag());\n  }\n  if (!data.install_brand().empty()) {\n    session_json.SetByDottedPath(GetAttributePath(\"InstallBrand\"),\n                                 data.install_brand());\n  }\n  if (!data.user_email().empty() && data.session_id() != -1) {\n    session_json.SetByDottedPath(GetAttributePath(\"ProcessSessionId\"),\n                                 base::NumberToString(data.session_id()));\n  }\n  if (!data.page_url().empty()) {\n    session_json.SetByDottedPath(GetAttributePath(\"SourcePageURI\"),\n                                 data.page_url());\n  }\n\n  // Surface queryable forms of Diagnostic Data and append to the Diagnostic\n  // Session Attributes.\n  base::Value::Dict queryable_data_dict;\n  const FeedbackData::DiagnosticDataMap* sys_info = data.sys_info();\n  if (sys_info) {\n    for (const auto& iter : *sys_info) {\n      if (!iter.second.queryable_value->empty()) {\n        queryable_data_dict.Merge(iter.second.queryable_value->Clone());\n      }\n    }\n  }\n  base::Value::Dict* attributes_dict =\n      session_json.FindDict(kSessionAttributesKey);\n  if (attributes_dict) {\n    attributes_dict->Merge(queryable_data_dict.Clone());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Populates a JSON object with session and diagnostic data attributes."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\shelf\\app_service\\app_service_app_window_arc_tracker.cc:482-549","function":"AppServiceAppWindowArcTracker::AttachControllerToWindow","codesnippet":"{\n  auto task_or_session_id = arc::GetWindowTaskOrSessionId(window);\n  if (!task_or_session_id.has_value()) {\n    return;\n  }\n\n  // System windows are also arc apps.\n  window->SetProperty(chromeos::kAppTypeKey, chromeos::AppType::ARC_APP);\n\n  if (*task_or_session_id == arc::kSystemWindowTaskId) {\n    return;\n  }\n\n  ArcAppWindowInfo* const info = GetArcAppWindowInfo(window);\n  if (!info) {\n    return;\n  }\n\n  window->SetProperty(ash::kArcPackageNameKey, info->package_name());\n  window->SetProperty<int>(ash::kShelfItemTypeKey, ash::TYPE_APP);\n\n  // Check if we have set the AppWindowBase for this task. If it was a session\n  // window (ARC ghost window) and replace by real task window, function will\n  // returen here.\n  if (app_service_controller_->GetAppWindow(window)) {\n    return;\n  }\n\n  views::Widget* const widget = views::Widget::GetWidgetForNativeWindow(window);\n  DCHECK(widget);\n  info->set_window(window);\n  const ash::ShelfID shelf_id = info->shelf_id();\n\n  const auto task_id = arc::GetWindowTaskId(window);\n  const auto session_id = arc::GetWindowSessionId(window);\n  if (task_id.has_value()) {\n    AttachControllerToTask(*task_id);\n  } else if (session_id.has_value()) {\n    AttachControllerToSession(*session_id, *info);\n  }\n\n  if (!info->task_hidden_from_shelf()) {\n    app_service_controller_->AddWindowToShelf(window, shelf_id);\n  }\n  AppWindowBase* app_window = app_service_controller_->GetAppWindow(window);\n  if (app_window) {\n    app_window->SetDescription(info->title(), info->icon());\n  }\n\n  window->SetProperty(ash::kShelfIDKey, shelf_id.Serialize());\n  window->SetProperty(ash::kAppIDKey, shelf_id.app_id);\n  window->SetProperty(aura::client::kSkipImeProcessing, true);\n\n  if (info->launch_intent().empty()) {\n    return;\n  }\n\n  auto intent = arc::Intent::Get(info->launch_intent());\n  if (!intent) {\n    LOG(ERROR) << \"Failed to parse launch intent: \" << info->launch_intent();\n    return;\n  }\n\n  if (info->app_shelf_id().app_id() == arc::kPlayStoreAppId) {\n    HandlePlayStoreLaunch(*intent);\n  }\n  MaybeHandleDeferredLaunch(*intent);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Associates an ARC app window with its properties and manages its integration with the system shelf."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\chromebox_for_meetings\\artemis\\log_file.cc:94-136","function":"LogFile::RetrieveNextLogs","codesnippet":"{\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n\n  std::vector<std::string> logs;\n  size_t num_read_lines = 0;\n  size_t num_read_bytes = 0;\n\n  std::string line;\n  while (!IsAtEOF() && !IsInFailState() && num_read_lines < line_count &&\n         num_read_bytes < max_byte_limit && std::getline(file_stream_, line)) {\n    num_read_bytes += line.size();\n    num_read_lines++;\n\n    logs.push_back(std::move(line));\n    last_read_offset_ = file_stream_.tellg();\n  }\n\n  if (IsInFailState()) {\n    LOG(ERROR) << \"Error reading file \" << filepath_ << \" after \"\n               << num_read_lines << \" lines\";\n  } else if (num_read_lines < line_count && num_read_bytes > max_byte_limit &&\n             !IsAtEOF()) {\n    LOG(WARNING) << \"Requested \" << line_count << \" lines for \" << GetFilePath()\n                 << \", but only read \" << num_read_lines\n                 << \" due to byte cap. Limit exceeded by \"\n                 << num_read_bytes - max_byte_limit << \" bytes.\";\n\n    // Drop logs until we're within our limit. This is a highly unlikely\n    // scenario, so this shouldn't impact our data analysis too much.\n    size_t orig_size = logs.size();\n    while (num_read_bytes > max_byte_limit && !logs.empty()) {\n      num_read_bytes -= logs.back().size();\n      logs.pop_back();\n    }\n\n    LOG(WARNING) << \"Dropped \" << orig_size - logs.size() << \" logs.\";\n  } else {\n    VLOG(3) << \"Read \" << num_read_bytes << \" bytes from \" << GetFilePath();\n  }\n\n  return logs;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Reads lines from a file into a vector, logging errors or warnings if limits are exceeded."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_skype\\skype_share_bubble_view.cc:42-88","function":"SkypeShareBubbleView::SkypeShareBubbleView","codesnippet":"{\n  set_use_custom_frame(true);\n  if (!last_focused_view_tracker_) {\n    last_focused_view_tracker_ = std::make_unique<views::ViewTracker>();\n    if (browser_view && browser_view->GetFocusManager()) {\n      last_focused_view_tracker_->SetView(\n          browser_view->GetFocusManager()->GetFocusedView());\n    }\n  }\n  SetFocusTraversesOut(true);\n  SetEnableArrowKeyTraversal(true);\n  set_draggable(false);\n  set_close_on_deactivate(false);\n  set_accept_events(true);\n  if (browser_view) {\n    browser_event_monitor_ = views::EventMonitor::CreateWindowMonitor(\n        this, browser_view->GetNativeWindow(),\n        {ui::EventType::kMousePressed, ui::EventType::kKeyPressed, ui::EventType::kTouchPressed});\n    set_has_parent(true);\n    set_parent_window(browser_view->GetBubbleParentView());\n  }\n\n  if (GetNativeTheme()->ShouldUseDarkColors()) {\n    SetBackgroundColor(SkColorSetARGB(245, 44, 44, 44));\n  } else {\n    SetBackgroundColor(SkColorSetARGB(184, 252, 252, 252));\n  }\n\n  const gfx::Insets margins = gfx::Insets::TLBR(kCornerRadius, kLateralPadding,\n                                                kCornerRadius, kLateralPadding);\n  set_margins(margins);\n\n  views::DialogDelegate::SetButtons(\n      static_cast<int>(ui::mojom::DialogButton::kNone));\n  SetAccessibleWindowRole(ax::mojom::Role::kDialog);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes a custom dialog window with specific focus, appearance, and event handling settings."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\support_tool\\ash\\chrome_user_logs_data_collector.cc:247-271","function":"ChromeUserLogsDataCollector::OnUserLogFileRead","codesnippet":"{\n  if (user_log_file.first.empty()) {\n    errors_.push_back(base::StringPrintf(\n        \"Couldn't copy logs from %s log file\",\n        original_log_path.BaseName().AsUTF8Unsafe().c_str()));\n    std::move(barrier_closure).Run();\n    return;\n  }\n  if (user_log_file.second.empty()) {\n    errors_.push_back(base::StringPrintf(\n        \"Couldn't read logs from %s log file for PII detection\",\n        original_log_path.BaseName().AsUTF8Unsafe().c_str()));\n    std::move(barrier_closure).Run();\n    return;\n  }\n  task_runner_for_redaction_tool_->PostTaskAndReplyWithResult(\n      FROM_HERE,\n      base::BindOnce(&DetectPII, user_log_file.second,\n                     redaction_tool_container_),\n      base::BindOnce(&ChromeUserLogsDataCollector::OnPIIDetected,\n                     weak_ptr_factory_.GetWeakPtr(), std::move(barrier_closure),\n                     user_log_file.first));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Detects personally identifiable information (PII) in user log files."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\controls\\hover_button.cc:448-469","function":"HoverButton::AddLayerToRegion","codesnippet":"{\n  if (title_) {\n    title_->SetPaintToLayer();\n    title_->layer()->SetFillsBoundsOpaquely(false);\n    title_->SetSubpixelRenderingEnabled(false);\n  }\n  if (subtitle_) {\n    subtitle_->SetPaintToLayer();\n    subtitle_->layer()->SetFillsBoundsOpaquely(false);\n    subtitle_->SetSubpixelRenderingEnabled(false);\n  }\n  if (icon_view_) {\n    icon_view_->SetPaintToLayer();\n    icon_view_->layer()->SetFillsBoundsOpaquely(false);\n  }\n  if (secondary_view_) {\n    secondary_view_->SetPaintToLayer();\n    secondary_view_->layer()->SetFillsBoundsOpaquely(false);\n  }\n\n  LabelButton::AddLayerToRegion(ink_drop_layer, region);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets rendering properties for UI components and adds an ink drop layer to a specified region."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\installer\\util\\install_service_work_item_impl.cc:640-669","function":"InstallServiceWorkItemImpl::UpgradeService","codesnippet":"{\n  DCHECK(service_.IsValid());\n  DCHECK(!original_service_config_.is_valid);\n\n  ServiceConfig original_config;\n  if (!GetServiceConfig(&original_config))\n    return false;\n\n  ServiceConfig new_config = MakeUpgradeServiceConfig(original_config);\n  const bool upgrade_needed = IsUpgradeNeeded(new_config);\n  if (upgrade_needed) {\n    original_service_config_ = std::move(original_config);\n  } else {\n    // In order to determine whether the Service is correctly installed as\n    // opposed to being in a \"deleted\" state, we attempt to change just the\n    // display name in the service configuration even if it is correctly\n    // configured.\n    new_config.display_name = original_config.display_name;\n  }\n\n  // If the service is deleted, `ChangeServiceConfig()` will return false.\n  bool success = ChangeServiceConfig(new_config);\n  if (success && upgrade_needed)\n    rollback_existing_service_ = true;\n\n  // Try to set the service description. Failing is not fatal.\n  SetServiceDescription(service_.Get(), service_description_);\n\n  SetDescription();\n  return success;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Upgrades and configures a service if needed, then sets its description."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_pinned_sites\\pinned_sites_internal.cc:189-242","function":"UrlMatcher::IsContenderWorse","codesnippet":"{\n  CHECK(is_contender_better);\n\n  const T contender_url_pieces = GetUrlPieces(contender_url);\n\n  const size_t matches = GetMatches(contender_url_pieces, match_pieces);\n  UrlMatcher::UrlPieceMatches* contender = GetMatchField(contender_info);\n  contender->matches_ = matches;\n  contender->extras_ = (contender_url_pieces.size() - matches);\n  contender->missing_ = (match_pieces.size() - matches);\n\n  if (*is_contender_better) {\n    // Contender is already the best url. Can abort here, rather than comparing\n    // with the reigning champ (which may not exist).\n    return false;\n  }\n\n  // Note: We know that |best_match_| has a value because |is_contender_better|\n  // is false.\n  const UrlMatcher::UrlPieceMatches* champ = GetMatchField(best_match_.value());\n\n  // Compare the |contender| with the currently-reigning |champ|.\n  bool is_contender_worse = false;\n  if (champ->matches_ > contender->matches_) {\n    // |contender| has fewer matches. It loses.\n    is_contender_worse = true;\n  } else if (champ->matches_ < contender->matches_) {\n    // |contender| has more matches. It wins.\n    *is_contender_better = true;\n  } else {\n    // |contender| and |champ| have same number of matches.\n\n    // Tiebreaker: Check mismatches.\n    const size_t champ_diffs = champ->mismatch_count();\n    const size_t contender_diffs = contender->mismatch_count();\n    if (champ_diffs < contender_diffs) {\n      // |contender| has more mismatches. It loses.\n      is_contender_worse = true;\n    } else if (champ_diffs > contender_diffs) {\n      // |contender| has fewer mismatches. It wins.\n      *is_contender_better = true;\n    }\n    // else {\n    //   // Same number of mismatches. Still tied.\n    // }\n  }\n\n  return is_contender_worse;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Compares a contender URL against a champion URL to determine which is better based on matches and mismatches."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\shelf\\browser_shortcut_shelf_item_controller.cc:55-76","function":"GetListOfActiveBrowsers","codesnippet":"{\n  BrowserList::BrowserVector active_browsers;\n  for (Browser* browser : *BrowserList::GetInstance()) {\n    // Only include browsers for the active user.\n    if (!multi_user_util::IsProfileFromActiveUser(browser->profile())) {\n      continue;\n    }\n\n    // Exclude invisible non-minimized browser windows on the active desk.\n    aura::Window* native_window = browser->window()->GetNativeWindow();\n    if (!browser->window()->IsVisible() && !browser->window()->IsMinimized() &&\n        ash::desks_util::BelongsToActiveDesk(native_window)) {\n      continue;\n    }\n    if (!IsBrowserRepresentedInBrowserList(browser, model) &&\n        !browser->is_type_normal()) {\n      continue;\n    }\n    active_browsers.push_back(browser);\n  }\n  return active_browsers;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Returns a list of active browsers for the current user."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_search_command_line_switches\\process_search_command_line_switches.cc:225-305","function":"ProcessDefaultNTPLayoutCommandLineSwitch","codesnippet":"{\n  // Check for command line switch to reset the NTP to informational mode\n  // layout.\n  if (command_line.HasSwitch(switches::kDefaultNTPLayout)) {\n    std::string switch_value =\n        command_line.GetSwitchValueASCII(switches::kDefaultNTPLayout);\n\n    ProfileManager* profile_manager = g_browser_process->profile_manager();\n    std::vector<ProfileAttributesEntry*> all_profiles =\n        profile_manager->GetProfileAttributesStorage()\n            .GetAllProfilesAttributes();\n\n    // Get the layoutmode pref value to reset to.\n    int layoutmode_reset_value = -1;\n    if (switch_value == \"focused\") {\n      layoutmode_reset_value =\n          static_cast<int>(edge_ntp::prefs::NtpLayoutMode::Focused);\n    }\n    if (switch_value == \"inspirational\") {\n      layoutmode_reset_value =\n          static_cast<int>(edge_ntp::prefs::NtpLayoutMode::Inspirational);\n    }\n    if (switch_value == \"informational\") {\n      layoutmode_reset_value =\n          static_cast<int>(edge_ntp::prefs::NtpLayoutMode::Informative);\n    }\n\n    for (ProfileAttributesEntry* entry : all_profiles) {\n      Profile* profile = profile_manager->GetProfile(entry->GetPath());\n      if (!profile) {\n        continue;\n      }\n\n      PrefService* user_prefs = profile->GetPrefs();\n      const PrefService::Preference* new_tab_url_pref =\n          user_prefs->FindPreference(prefs::kNewTabPageLocationOverride);\n      bool new_tab_url_managed_or_recommended =\n          new_tab_url_pref->IsManaged() || new_tab_url_pref->IsRecommended();\n\n      if (switch_value == \"?\") {\n        if (!new_tab_url_managed_or_recommended) {\n          break;\n        }\n      } else if (layoutmode_reset_value != -1) {\n        // Check if new tab page is policy-managed.\n        if (new_tab_url_pref->IsManaged()) {\n          continue;\n        }\n\n        const extensions::Extension* ntp_extension =\n            extensions::GetExtensionOverridingNewTabPage(profile);\n        if (ntp_extension) {\n          // disable extensions\n          std::string extensionId = ntp_extension->id();\n          if (auto* extension_registrar =\n                  extensions::ExtensionRegistrar::Get(profile)) {\n            extension_registrar->DisableExtension(\n\n                extensionId, {extensions::disable_reason::DISABLE_USER_ACTION});\n          }\n        }\n\n        user_prefs->SetInteger(edge_ntp::prefs::kLayoutMode,\n                               layoutmode_reset_value);\n        user_prefs->SetBoolean(edge_ntp::prefs::kLayoutModeResetBySCOOBE, true);\n\n        user_prefs->SetString(edge_instrumentation::prefs::kNtpLayoutModeInst,\n                              \"edge_utils::ProcessSearchCommandLineSwitches - \"\n                              \"kDefaultNTPLayout;\" +\n                                  base::NumberToString(layoutmode_reset_value));\n      }\n    }\n\n    did_launch = false;\n    should_stop_processing = true;\n    return true;\n  }\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Resets the new tab page layout mode based on a command line switch."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\metrics\\edge_launch_source\\launch_source_base.cc:119-138","function":"LaunchSourceBase::OnClose","codesnippet":"{\n  DCHECK(children_ == 0);\n  closed_ = true;\n  // This is a no-op if activity and audio are shutdown prior to close\n  UpdateDwellTime(base::Time::Now());\n  active_ = false;\n  for (auto it = active_time_trackers_.begin();\n       it != active_time_trackers_.end(); it++) {\n    // when session closes, end all stopwatches\n    it->second->StopwatchEnd();\n  }\n  active_time_trackers_.clear();\n  if (parent_) {\n    parent_->RemoveChild();\n#if BUILDFLAG(IS_WIN)\n    if (!features::edge::growth::IsLaunchSourceLoggingEnabled())\n#endif\n      parent_ = nullptr;\n  }\n  SendUkm();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Closes a session and stops all active time trackers."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_auth\\edge_integrated_account_info_finder.cc:50-81","function":"edge_integrated_account_info_finder::CanHaveIntegratedAccount","codesnippet":"{\n  bool result = false;\n  if (profile_account_type != EdgeAccountType::kMSA &&\n      profile_account_type != EdgeAccountType::kAAD) {\n    return false;\n  }\n\n  if (profile_account_type == EdgeAccountType::kAAD) {\n    const auto msa_sso_on =\n        profile_sso_option == EdgeProfileCurrentSSOOption::kAllowAADMSASSO ||\n        profile_sso_option == EdgeProfileCurrentSSOOption::kAllowMSASSO ||\n        profile_sso_option ==\n            EdgeProfileCurrentSSOOption::kAllowAADMSASSOByPolicyOn ||\n        profile_sso_option ==\n            EdgeProfileCurrentSSOOption::kAllowMSASSOByPolicyOn;\n    return msa_sso_on;\n  }\n\n  if (profile_account_type == EdgeAccountType::kMSA) {\n    const auto aad_sso_on =\n        profile_sso_option == EdgeProfileCurrentSSOOption::kAllowAADMSASSO ||\n        profile_sso_option == EdgeProfileCurrentSSOOption::kAllowAADSSO ||\n        profile_sso_option ==\n            EdgeProfileCurrentSSOOption::kAllowAADMSASSOByPolicyOn ||\n        profile_sso_option ==\n            EdgeProfileCurrentSSOOption::kAllowAADSSOByPolicyOn;\n    return aad_sso_on;\n  }\n\n  return result;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if single sign-on is enabled based on account type and profile options."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_continuity\\core\\browser\\p2p\\http_signal_client.cc:214-253","function":"HttpSignalClient::CreateSession_OnGotResult","codesnippet":"{\n  int response_code = 0;\n  if (create_session_url_loader_->ResponseInfo() &&\n      create_session_url_loader_->ResponseInfo()->headers) {\n    response_code =\n        create_session_url_loader_->ResponseInfo()->headers->response_code();\n  }\n\n  // Check If create session success by checking response code and response\n  if ((response_code != net::HTTP_OK && response_code != net::HTTP_CREATED) ||\n      !response_body || response_body->empty()) {\n    LOG(ERROR) << \"[Continuity] Create session failed, Response code: \"\n               << response_code << \"; response_body: \"\n               << (response_body ? *response_body : \"null\");\n\n    // If the failed count is less than kMaxFailedCount, retry to create\n    // session.\n    if (create_session_failed_count_ < kMaxFailedCount) {\n      create_session_failed_count_++;\n      base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\n          FROM_HERE,\n          base::BindOnce(&HttpSignalClient::CreateSession_OnGotAuthToken,\n                         weak_ptr_factory_.GetWeakPtr(), auth_token, true),\n          base::Milliseconds(kMessageRetryDelaySlowly));\n    } else {\n      if (!response_body || response_body->empty()) {\n        std::move(on_failed_callback_).Run(ConnectError::kEmptyResponse);\n      } else {\n        std::move(on_failed_callback_).Run(ConnectError::kHttpError);\n      }\n    }\n    return;\n  }\n\n  std::string body = *response_body;\n  data_decoder::DataDecoder::ParseJsonIsolated(\n      body, base::BindOnce(&HttpSignalClient::CreateSession_OnResultParsed,\n                           weak_ptr_factory_.GetWeakPtr(), body));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles session creation by checking the response and retrying on failure."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\api\\quick_unlock_private\\quick_unlock_private_api.cc:491-549","function":"QuickUnlockPrivateSetModesFunction::Run","codesnippet":"{\n  params_ = SetModes::Params::Create(args());\n  EXTENSION_FUNCTION_VALIDATE(params_);\n\n  if (params_->modes.size() != params_->credentials.size())\n    return RespondNow(Error(kModesAndCredentialsLengthMismatch));\n\n  if (params_->modes.size() > 1)\n    return RespondNow(Error(kMultipleModesNotSupported));\n\n  std::optional<std::string> error =\n      CheckTokenValidity(browser_context(), params_->token);\n  if (error.has_value()) {\n    return RespondNow(Error(error.value()));\n  }\n\n  // Verify every credential is valid based on policies.\n  PrefService* pref_service = GetActiveProfile(browser_context())->GetPrefs();\n\n  // Do not allow setting a PIN if it is disabled by policy. It is disabled\n  // on the UI, but users can still reach here via dev tools.\n  for (auto& mode : params_->modes) {\n    if (mode == QuickUnlockMode::kPin &&\n        ash::quick_unlock::IsPinDisabledByPolicy(\n            pref_service, ash::quick_unlock::Purpose::kAny)) {\n      return RespondNow(Error(kPinDisabledByPolicy));\n    }\n  }\n\n  // Verify every credential is valid based on policies.\n  bool allow_weak =\n      pref_service->GetBoolean(ash::prefs::kPinUnlockWeakPinsAllowed);\n  for (size_t i = 0; i < params_->modes.size(); ++i) {\n    if (params_->credentials[i].empty())\n      continue;\n\n    if (params_->modes[i] != QuickUnlockMode::kPin) {\n      continue;\n    }\n\n    if (!IsPinNumeric(params_->credentials[i]))\n      return RespondNow(Error(kInvalidPIN));\n\n    CredentialProblem problem =\n        GetCredentialProblemForPin(params_->credentials[i], pref_service);\n    if (problem != CredentialProblem::kNone) {\n      return RespondNow(Error(kInvalidCredential));\n    }\n\n    if (!allow_weak && !IsPinDifficultEnough(params_->credentials[i]))\n      return RespondNow(Error(kWeakCredential));\n  }\n\n  ComputeActiveModes(\n      GetActiveProfile(browser_context()),\n      base::BindOnce(&QuickUnlockPrivateSetModesFunction::OnGetActiveModes,\n                     this));\n\n  return RespondLater();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates and sets quick unlock modes and credentials based on policies."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\policy\\uploading\\upload_job_impl.cc:214-277","function":"UploadJobImpl::SetUpMultipart","codesnippet":"{\n  DCHECK_EQ(ACQUIRING_TOKEN, state_);\n  state_ = PREPARING_CONTENT;\n\n  if (mime_boundary_ && post_data_)\n    return true;\n\n  std::set<std::string> used_names;\n\n  // Check uniqueness of header field names.\n  for (const auto& data_segment : data_segments_) {\n    if (!used_names.insert(data_segment->GetName()).second)\n      return false;\n  }\n\n  mime_boundary_ =\n      std::make_unique<std::string>(boundary_generator_->GenerateBoundary());\n\n  // Estimate an upper bound for the total message size to make memory\n  // allocation more efficient. It is not an error if this turns out to be too\n  // small as std::string will take care of the realloc.\n  size_t size = 0;\n  for (const auto& data_segment : data_segments_) {\n    for (const auto& entry : data_segment->GetHeaderEntries())\n      size += entry.first.size() + entry.second.size();\n    size += kMaxMimeBoundarySize + data_segment->GetName().size() +\n            data_segment->GetFilename().size() + data_segment->GetDataSize();\n    // Add some extra space for all the constants and control characters.\n    size += 128;\n  }\n\n  // Allocate memory of the expected size.\n  post_data_ = std::make_unique<std::string>();\n  post_data_->reserve(size);\n\n  for (const auto& data_segment : data_segments_) {\n    post_data_->append(\"--\" + *mime_boundary_.get() + \"\\r\\n\");\n    post_data_->append(\"Content-Disposition: form-data; name=\\\"\" +\n                       data_segment->GetName() + \"\\\"\");\n    if (!data_segment->GetFilename().empty()) {\n      post_data_->append(\"; filename=\\\"\" + data_segment->GetFilename() + \"\\\"\");\n    }\n    post_data_->append(\"\\r\\n\");\n\n    // Add custom header fields.\n    for (const auto& entry : data_segment->GetHeaderEntries()) {\n      post_data_->append(entry.first + \": \" + entry.second + \"\\r\\n\");\n    }\n    std::unique_ptr<std::string> data = data_segment->GetData();\n    post_data_->append(\"\\r\\n\" + *data + \"\\r\\n\");\n  }\n  post_data_->append(\"--\" + *mime_boundary_.get() + \"--\\r\\n\");\n\n  // Issues a warning if our buffer size estimate was too small.\n  if (post_data_->size() > size) {\n    SYSLOG(INFO)\n        << \"Reallocation needed in POST data buffer. Expected maximum size \"\n        << size << \" bytes, actual size \" << post_data_->size() << \" bytes.\";\n  }\n\n  // Discard the data segments as they are not needed anymore from here on.\n  data_segments_.clear();\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates and prepares multipart form-data content for HTTP POST requests."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\dbus\\ash_dbus_helper.cc:274-372","function":"ShutdownDBus","codesnippet":"{\n  if (g_dbus_helper_observer) {\n    g_dbus_helper_observer->PreShutdownDBus();\n  }\n\n  // Feature list-dependent D-Bus clients are shut down first because we try to\n  // shut down in reverse order of initialization (in case of dependencies).\n  if (features::IsSnoopingProtectionEnabled() ||\n      features::IsQuickDimEnabled()) {\n    HumanPresenceDBusClient::Shutdown();\n  }\n#if BUILDFLAG(PLATFORM_CFM)\n  if (base::FeatureList::IsEnabled(cfm::features::kMojoServices)) {\n    CfmHotlineClient::Shutdown();\n  }\n#endif\n  if (floss::features::IsFlossEnabled()) {\n    FlossMediaClient::Shutdown();\n    floss::FlossDBusManager::Shutdown();\n  } else {\n    bluez::BluezDBusManager::Shutdown();\n  }\n\n  // Depends on `DlcserviceClient`.\n  language_packs::LanguagePackManager::Shutdown();\n\n  // Other D-Bus clients are shut down, also in reverse order of initialization.\n  chromeos::RegmonClient::Shutdown();\n  VmPluginDispatcherClient::Shutdown();\n  VirtualFileProviderClient::Shutdown();\n  UpstartClient::Shutdown();\n  UserDataAuthClient::Shutdown();\n  UpdateEngineClient::Shutdown();\n  chromeos::U2FClient::Shutdown();\n  TypecdClient::Shutdown();\n  chromeos::TpmManagerClient::Shutdown();\n  SystemProxyClient::Shutdown();\n  SystemClockClient::Shutdown();\n  SwapManagementClient::Shutdown();\n  SpacedClient::Shutdown();\n  SmbProviderClient::Shutdown();\n  SessionManagerClient::Shutdown();\n  SeneschalClient::Shutdown();\n  RuntimeProbeClient::Shutdown();\n  ResourcedClient::Shutdown();\n  RgbkbdClient::Shutdown();\n  if (shimless_rma::IsShimlessRmaAllowed()) {\n    RmadClient::Shutdown();\n  }\n  chromeos::PowerManagerClient::Shutdown();\n  chromeos::PermissionBrokerClient::Shutdown();\n  PrintscanmgrClient::Shutdown();\n  PciguardClient::Shutdown();\n  PatchPanelClient::Shutdown();\n  PrivateComputingClient::Shutdown();\n  OsInstallClient::Shutdown();\n  OobeConfigurationClient::Shutdown();\n  chromeos::MissiveClient::Shutdown();\n  MediaAnalyticsClient::Shutdown();\n  chromeos::MachineLearningClient::Shutdown();\n  LorgnetteManagerClient::Shutdown();\n  KerberosClient::Shutdown();\n  chromeos::IpPeripheralServiceClient::Shutdown();\n  InstallAttributesClient::Shutdown();\n  ImageLoaderClient::Shutdown();\n  ImageBurnerClient::Shutdown();\n  hermes_clients::Shutdown();\n  GnubbyClient::Shutdown();\n  featured::FeaturedClient::Shutdown();\n  FederatedClient::Shutdown();\n  EasyUnlockClient::Shutdown();\n  DlcserviceClient::Shutdown();\n  chromeos::DlpClient::Shutdown();\n  DebugDaemonClient::Shutdown();\n  CupsProxyClient::Shutdown();\n  CryptohomePkcs11Client::Shutdown();\n  CryptohomeMiscClient::Shutdown();\n  CrosDisksClient::Shutdown();\n  CrasAudioClient::Shutdown();\n  ConciergeClient::Shutdown();\n  CiceroneClient::Shutdown();\n  ChunneldClient::Shutdown();\n  ChapsClient::Shutdown();\n  CecServiceClient::Shutdown();\n  CdmFactoryDaemonClient::Shutdown();\n  BiodClient::Shutdown();\n  AttestationClient::Shutdown();\n  ArcVmDataMigratorClient::Shutdown();\n  ArcObbMounterClient::Shutdown();\n  ArcMidisClient::Shutdown();\n  ArcKeyMintClient::Shutdown();\n  ArcKeymasterClient::Shutdown();\n  ArcCameraClient::Shutdown();\n  ArcAppfuseProviderClient::Shutdown();\n  AnomalyDetectorClient::Shutdown();\n\n  shill_clients::Shutdown();\n  DBusThreadManager::Shutdown();\n  SystemSaltGetter::Shutdown();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Shuts down various D-Bus clients and services in reverse order of initialization."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\searches\\inverted_index_search_service.cc:222-253","function":"InvertedIndexSearchService::LoadWordCountMap","codesnippet":"{\n  std::unordered_map<int, int> word_count_map;\n\n  base::FilePath filename =\n      GetStorageFilePath(file_path_, kInvertedIndexWordCountFileName);\n  std::string json_string;\n  if (!base::PathExists(filename) ||\n      !base::ReadFileToString(filename, &json_string)) {\n    return {};\n  }\n\n  std::optional<base::Value> root = base::JSONReader::Read(json_string);\n  if (!root || !root->is_dict()) {\n    return {};\n  }\n\n  const base::Value::Dict& dict = root->GetDict();\n  for (const auto pair : dict) {\n    int doc_id;\n    if (!base::StringToInt(pair.first, &doc_id)) {\n      continue;\n    }\n\n    std::optional<int> count_opt = pair.second.GetInt();\n    if (!count_opt) {\n      return {};\n    }\n\n    word_count_map[doc_id] = *count_opt;\n  }\n\n  return word_count_map;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses a JSON file to create a map of document IDs to word counts."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\frame\\minimize_button_metrics_win.cc:83-140","function":"MinimizeButtonMetrics::GetMinimizeButtonOffsetForWindow","codesnippet":"{\n  bool dwm_button_pos = false;\n  POINT minimize_button_corner = {0};\n  RECT button_bounds = {0};\n  if (SUCCEEDED(DwmGetWindowAttribute(hwnd_, DWMWA_CAPTION_BUTTON_BOUNDS,\n                                      &button_bounds, sizeof(button_bounds)))) {\n    if (button_bounds.left != button_bounds.right) {\n      // This converts the button coordinate into screen coordinates\n      // thus, ensuring that the identity switcher is placed in the\n      // same location as before. An additional constant is added because\n      // there is a difference between the caption button bounds and\n      // the values obtained through WM_GETTITLEBARINFOEX. This difference\n      // varies between OS versions, and no metric describing this difference\n      // has been located.\n      RECT window_bounds = {0};\n      if (GetWindowRect(hwnd_, &window_bounds)) {\n        int offset =\n            GetButtonBoundsPositionOffset(button_bounds, window_bounds);\n        minimize_button_corner = {\n            button_bounds.left + window_bounds.left + offset, 0};\n        dwm_button_pos = true;\n      }\n    }\n  }\n  if (!dwm_button_pos) {\n    // Fallback to using the message for the titlebar info only if the above\n    // code fails. It can fail if DWM is disabled globally or only for the\n    // given HWND. The WM_GETTITLEBARINFOEX message can fail if we are not\n    // active/visible. By fail we get a location of 0; the return status\n    // code is always the same and similarly the state never seems to change\n    // (titlebar_info.rgstate).\n    TITLEBARINFOEX titlebar_info = {0};\n    titlebar_info.cbSize = sizeof(TITLEBARINFOEX);\n    SendMessage(hwnd_, WM_GETTITLEBARINFOEX, 0,\n                reinterpret_cast<LPARAM>(&titlebar_info));\n\n    // Under DWM WM_GETTITLEBARINFOEX won't return the right thing until after\n    // WM_NCACTIVATE (maybe it returns classic values?). In an attempt to\n    // return a consistant value we cache the last value across instances and\n    // use it until we get the activate.\n    if (titlebar_info.rgrect[2].left == titlebar_info.rgrect[2].right ||\n        (titlebar_info.rgstate[2] &\n         (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN |\n          STATE_SYSTEM_UNAVAILABLE))) {\n      return 0;\n    }\n    minimize_button_corner = {titlebar_info.rgrect[2].left, 0};\n  }\n\n  // WM_GETTITLEBARINFOEX returns rects in screen coordinates in pixels.\n  // DWMNA_CAPTION_BUTTON_BOUNDS is in window (not client) coordinates,\n  // but it has been converted to screen coordinates above. We need to\n  // convert the minimize button corner offset to DIP before returning it.\n  MapWindowPoints(HWND_DESKTOP, hwnd_, &minimize_button_corner, 1);\n  gfx::Point pixel_point = {minimize_button_corner.x, 0};\n  gfx::Point dip_point =\n      display::win::GetScreenWin()->ClientToDIPPoint(hwnd_, pixel_point);\n  return dip_point.x();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the screen position of the minimize button for a window."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\installer\\test\\pe_image_resources.cc:33-111","function":"EnumResourcesWorker","codesnippet":"{\n  bool success = true;\n  const IMAGE_RESOURCE_DIRECTORY* resource_directory;\n\n  if (!StructureAt(tree_base + directory_offset, tree_size - directory_offset,\n                   &resource_directory) ||\n      directory_offset + sizeof(IMAGE_RESOURCE_DIRECTORY) +\n              (resource_directory->NumberOfNamedEntries +\n               resource_directory->NumberOfIdEntries) *\n                  sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) >\n          tree_size) {\n    LOG(DFATAL) << \"Insufficient room in resource segment for directory entry.\";\n    return false;\n  }\n\n  const IMAGE_RESOURCE_DIRECTORY_ENTRY* scan =\n      reinterpret_cast<const IMAGE_RESOURCE_DIRECTORY_ENTRY*>(\n          tree_base + directory_offset + sizeof(IMAGE_RESOURCE_DIRECTORY));\n  const IMAGE_RESOURCE_DIRECTORY_ENTRY* end =\n      scan + resource_directory->NumberOfNamedEntries +\n      resource_directory->NumberOfIdEntries;\n  for (; success && scan != end; ++scan) {\n    if ((scan->NameIsString != 0) !=\n        (scan - reinterpret_cast<const IMAGE_RESOURCE_DIRECTORY_ENTRY*>(\n                    tree_base + directory_offset +\n                    sizeof(IMAGE_RESOURCE_DIRECTORY)) <\n         resource_directory->NumberOfNamedEntries)) {\n      LOG(DFATAL) << \"Inconsistent number of named or numbered entries.\";\n      success = false;\n      break;\n    }\n    if (scan->NameIsString) {\n      const IMAGE_RESOURCE_DIR_STRING_U* dir_string;\n      if (!StructureAt(tree_base + scan->NameOffset,\n                       tree_size - scan->NameOffset, &dir_string) ||\n          scan->NameOffset + sizeof(WORD) +\n                  dir_string->Length * sizeof(wchar_t) >\n              tree_size) {\n        LOG(DFATAL) << \"Insufficient room in resource segment for entry name.\";\n        success = false;\n        break;\n      }\n      path->push_back(upgrade_test::EntryId(\n          std::wstring(&dir_string->NameString[0], dir_string->Length)));\n    } else {\n      path->push_back(upgrade_test::EntryId(scan->Id));\n    }\n    if (scan->DataIsDirectory) {\n      success =\n          EnumResourcesWorker(image, tree_base, tree_size,\n                              scan->OffsetToDirectory, path, callback, context);\n    } else {\n      const IMAGE_RESOURCE_DATA_ENTRY* data_entry;\n      if (StructureAt(tree_base + scan->OffsetToData,\n                      tree_size - scan->OffsetToData, &data_entry) &&\n          reinterpret_cast<uint8_t*>(\n              image.RVAToAddr(data_entry->OffsetToData)) +\n                  data_entry->Size <=\n              tree_base + tree_size) {\n        // Despite what winnt.h says, OffsetToData is an RVA.\n        callback(*path,\n                 reinterpret_cast<uint8_t*>(\n                     image.RVAToAddr(data_entry->OffsetToData)),\n                 data_entry->Size, data_entry->CodePage, context);\n      } else {\n        LOG(DFATAL) << \"Insufficient room in resource segment for data entry.\";\n        success = false;\n      }\n    }\n    path->pop_back();\n  }\n\n  return success;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Enumerates and processes resource directory entries in an image file."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_hub_apps\\edge_hub_apps_tower_view_manager.cc:351-418","function":"EdgeHubAppsTowerViewManager::SetHubAppsTowerVisibility","codesnippet":"{\n  if (GetBrowser()->is_type_edge_customizable()) {\n    // Hide the tower if it's customizable window.\n    is_visible = false;\n  }\n  bool need_re_layout = is_visible && !hub_apps_tower_view_;\n  if (need_re_layout) {\n    // Make sure tower is created.\n    CreateHubAppsTower(/*force_create =*/true);\n  }\n\n  const bool current_visible = hub_apps_tower_view_ && IsTowerVisible();\n  if (is_visible == current_visible) {\n    // Tower visibility is already set as needed, re-layout BrowserView.\n    if (need_re_layout) {\n      GetTowerViewOwnerView()->InvalidateLayout();\n    }\n    return;\n  }\n\n  if (!hub_apps_tower_view_) {\n    return;\n  }\n\n  if (is_visible) {\n    // If tower was previously floating, but is now pinned, we need to\n    // update the floating state.\n    if (is_pinned && IsFloating()) {\n      hub_apps_tower_view_->UpdateSidebarFloatingState(false);\n    }\n\n    // Update tower visual state.\n    if (is_pinned) {\n      SetState(State::kPinned);\n    } else {\n      SetState(State::kOverlayed);\n    }\n    hub_apps_tower_view_->SetVisible(true);\n    if (!GetBrowser()->is_type_edge_standalone_sidebar()) {\n      hub_apps_tower_view_->UpdatePinSidebarButtonState(is_pinned);\n    }\n    // Ensures the hidesidebar button is disabled if we enter fullscreen without\n    // the tower being created. The exit_fullscreen_called_ variable ensures we\n    // don't enter this condition and disable the hidesidebar button when\n    // exiting fullscreen.\n    if (IsFullscreen() && features::edge::IsEdgeSidebarInFullscreenEnabled() &&\n        !exit_fullscreen_called) {\n      DCHECK(!is_pinned);\n      hub_apps_tower_view_->SetHideSidebarButtonEnabled(false);\n    }\n\n  } else {\n    // Update tower visibility state.\n    SetState(State::kHidden);\n\n    // In normal situations you can't get here if the tower is pinned.\n    // However, that CAN happen if the tower was disabled by policy.\n    hub_apps_tower_view_->SetVisible(false);\n    // Reset tower floating state when tower is hidden.\n    if (IsFloating()) {\n      SetTowerFloating(false);\n    }\n  }\n\n  GetTowerViewOwnerView()->InvalidateLayout();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Manages the visibility and layout of the hub apps tower in a browser interface."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\ukm\\ukm_reporting_service.cc:141-170","function":"UkmReportingService::LogSuccessMetadata","codesnippet":"{\n  // Recover the report from the compressed staged log.\n  // Note: We don't use metrics::DecodeLogDataToProto() since we to use\n  // |uncompressed_log_data| later in the function.\n  std::string uncompressed_log_data;\n  bool uncompress_successful =\n      compression::GzipUncompress(staged_log, &uncompressed_log_data);\n  DCHECK(uncompress_successful);\n  Report report;\n  report.ParseFromString(uncompressed_log_data);\n\n  // Log the relative size of the report with relevant UKM data omitted. This\n  // helps us to estimate the bandwidth usage of logs upload that is not\n  // directly attributed to UKM data, for example the system profile info.\n  // Note that serialized logs are further compressed before upload, thus the\n  // percentages here are not the exact percentage of bandwidth they ended up\n  // taking.\n  std::string log_without_ukm_data;\n  report.clear_sources();\n  report.clear_source_counts();\n  report.clear_entries();\n  report.clear_aggregates();\n  report.SerializeToString(&log_without_ukm_data);\n\n  int non_ukm_percentage =\n      log_without_ukm_data.length() * 100 / uncompressed_log_data.length();\n  DCHECK_GE(non_ukm_percentage, 0);\n  DCHECK_LE(non_ukm_percentage, 100);\n  base::UmaHistogramPercentage(\"UKM.ReportSize.NonUkmPercentage\",\n                               non_ukm_percentage);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Analyzes and logs the percentage of a report's size excluding UKM data after decompression."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_adblock\\core\\browser\\adblock_data_storage.cc:214-236","function":"AdblockDataStorage::QueryTopNAdsInPeriod","codesnippet":"{\n  if (!InitializeIfNeeded()) {\n    return std::move(callback).Run(std::vector<AdsRecord>());\n  }\n  static constexpr char kSqlQueryTotalAdsInPeriod[] =\n      \"SELECT domain, SUM(count) as sum_count FROM BlockedURLAds \"\n      \"WHERE date > ? AND date <= ? \"\n      \"GROUP BY domain \"\n      \"ORDER BY sum_count DESC, domain ASC limit ?\";\n  sql::Statement query(\n      database_->GetCachedStatement(SQL_FROM_HERE, kSqlQueryTotalAdsInPeriod));\n  query.BindInt(0, transformTimeForSql(base::Time::Now() - delta));\n  query.BindInt(1, transformTimeForSql(base::Time::Now()));\n  query.BindInt(2, n);\n  std::vector<AdsRecord> records;\n  while (query.Step()) {\n    std::string domain = query.ColumnString(0);\n    int count = query.ColumnInt(1);\n    records.push_back(AdsRecord(domain, count));\n  }\n  std::move(callback).Run(records);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Retrieves and returns the top blocked ad domains within a specified time period."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\updater\\tools\\tag_main.cc:116-137","function":"TagMain","codesnippet":"{\n  const auto args = ParseCommandLineArgs(argc, argv);\n  if (args.get_tag_string) {\n    const std::string tag_string =\n        tagging::BinaryReadTagString(args.in_filename);\n    if (tag_string.empty()) {\n      std::cout << \"Could not get tag string, see log for details\" << std::endl;\n      std::exit(1);\n    }\n    std::cout << tag_string << std::endl;\n  }\n\n  if (args.set_superfluous_cert) {\n    if (!tagging::BinaryWriteTag(\n            args.in_filename, args.tag_string, args.padded_length,\n            args.out_filename.empty() ? args.in_filename : args.out_filename)) {\n      std::cout << \"Could not write tag, see log for details\" << std::endl;\n      std::exit(1);\n    }\n  }\n\n  return EXIT_SUCCESS;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses command-line arguments to read or write a tag string in a binary file."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\profiles\\edge_ignore_caw_view.cc:173-216","function":"EdgeIgnoreCAWView::CreatePromptBody","codesnippet":"{\n  const int margin_related_controls =\n      ChromeLayoutProvider::Get()->GetDistanceMetric(\n          views::DISTANCE_RELATED_CONTROL_VERTICAL);\n  const int margin_between_controls =\n      ChromeLayoutProvider::Get()->GetDistanceMetric(\n          views::DISTANCE_UNRELATED_CONTROL_VERTICAL);\n\n  // A grid-layout view as the prompt body.\n  auto view = std::make_unique<views::View>();\n  view->SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical,\n      gfx::Insets(margin_between_controls)));\n\n  // Title.\n  auto title = std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_IGNORE_CAW_PROMPT_TITLE));\n  title->SetLineHeight(22);\n  title->SetMultiLine(true);\n  title->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  title->SetFontList(\n      views::LayoutProvider::Get()->GetTypographyProvider().GetFont(\n          views::style::CONTEXT_DIALOG_TITLE, views::style::STYLE_PRIMARY));\n  view->AddChildView(std::move(title));\n\n  // Description.\n  auto text = std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_IGNORE_CAW_PROMPT_DESCRIPTION));\n  text->SetLineHeight(20);\n  text->SetMultiLine(true);\n  text->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  text->SetBorder(views::CreateEmptyBorder(\n      gfx::Insets::TLBR(margin_related_controls, 0, 0, 0)));\n  view->AddChildView(std::move(text));\n\n  // Separator.\n  auto* separator = view->AddChildView(std::make_unique<views::Separator>());\n  separator->SetBorder(\n      views::CreateEmptyBorder(gfx::Insets::VH(margin_between_controls, 0)));\n\n  // Buttons.\n  view->AddChildView(CreateButtons());\n\n  return view;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a vertically arranged prompt view with a title, description, separator, and buttons."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\offline_pages\\core\\request_header\\offline_page_header.cc:33-97","function":"ParseOfflineHeaderValue","codesnippet":"{\n  // If the offline header is not present, treat it as not parsed successfully.\n  if (header_value.empty())\n    return false;\n\n  // TODO(dcheng): Use net::HttpUtil::NameValuePairsIterator instead?\n  bool token_found = false;\n  base::StringTokenizer tokenizer(header_value, \", \");\n  while (tokenizer.GetNext()) {\n    token_found = true;\n    std::string_view pair = tokenizer.token_piece();\n    std::size_t pos = pair.find('=');\n    if (pos == std::string::npos)\n      return false;\n    std::string key = base::ToLowerASCII(pair.substr(0, pos));\n    std::string_view value = pair.substr(pos + 1);\n    std::string lower_value = base::ToLowerASCII(value);\n    if (key == kOfflinePageHeaderPersistKey) {\n      if (lower_value == \"1\")\n        *need_to_persist = true;\n      else if (lower_value == \"0\")\n        *need_to_persist = false;\n      else\n        return false;\n    } else if (key == kOfflinePageHeaderReasonKey) {\n      if (lower_value == kOfflinePageHeaderReasonValueDueToNetError)\n        *reason = OfflinePageHeader::Reason::NET_ERROR;\n      else if (lower_value == kOfflinePageHeaderReasonValueFromDownload)\n        *reason = OfflinePageHeader::Reason::DOWNLOAD;\n      else if (lower_value == kOfflinePageHeaderReasonValueReload)\n        *reason = OfflinePageHeader::Reason::RELOAD;\n      else if (lower_value == kOfflinePageHeaderReasonValueFromNotification)\n        *reason = OfflinePageHeader::Reason::NOTIFICATION;\n      else if (lower_value == kOfflinePageHeaderReasonFileUrlIntent)\n        *reason = OfflinePageHeader::Reason::FILE_URL_INTENT;\n      else if (lower_value == kOfflinePageHeaderReasonContentUrlIntent)\n        *reason = OfflinePageHeader::Reason::CONTENT_URL_INTENT;\n      else if (lower_value == kOfflinePageHeadeReasonValueFromProgressBar)\n        *reason = OfflinePageHeader::Reason::PROGRESS_BAR;\n      else if (lower_value == kOfflinePageHeadeReasonValueFromSuggestion)\n        *reason = OfflinePageHeader::Reason::SUGGESTION;\n      else if (lower_value == kOfflinePageHeaderNetErrorSuggestion)\n        *reason = OfflinePageHeader::Reason::NET_ERROR_SUGGESTION;\n      else\n        return false;\n    } else if (key == kOfflinePageHeaderIDKey) {\n      *id = std::string(value);\n    } else if (key == kOfflinePageHeaderIntentUrlKey) {\n      std::string decoded_url;\n      if (!base::Base64Decode(value, &decoded_url))\n        return false;\n      GURL url = GURL(decoded_url);\n      if (!url.is_valid())\n        return false;\n      *intent_url = std::move(url);\n    } else {\n      return false;\n    }\n  }\n\n  return token_found;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses an offline header to extract and validate key-value pairs for persistence, reason, ID, and intent URL."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_nurturing\\public\\actions\\edge_onramp\\ms_recommendation_telemtery_action.cc:36-92","function":"MsRecommendationActionTelemetryAction::HandleAction","codesnippet":"{\n  std::unique_ptr<base::Value::Dict> response_obj =\n      std::make_unique<base::Value::Dict>();\n#if BUILDFLAG(IS_WIN)\n  if (!payload) {\n    if (callback_)\n      std::move(callback_).Run(response_obj.get());\n    RunUiCallbackAndDeleteAction(action_store, store_index, campaign_id,\n                                 /*action_completion_status*/true);\n    return;\n  }\n  bool local_telemetry = BoolValueOrFalse(payload, \"localTelemetry\");\n  if (local_telemetry) {\n    bool is_default_browser =\n        shell_integration::IsDefaultBrowser(BrowserNameEnumeration::MSEDGE);\n    bool is_default_pdf =\n        shell_integration::win::GetDefaultAppForPDF() == \"EDGE\";\n    bool is_bing_search_engine =\n        search::PermanentDefaultSearchProviderIsBing(profile);\n\n    bool is_standard_launch =\n        BoolValueOrFalse(payload, \"isStandardLaunchEntrypoint\");\n\n    MsRecommendationsCampaignUIType campaign_type = GetCampaignType(\n        is_default_browser, is_default_pdf,\n        is_bing_search_engine, is_standard_launch);\n\n    if (campaign_type != MsRecommendationsCampaignUIType::kNone) {\n      edge::nurturing::TriggerCampaignTypeHistogram(campaign_type, true, false);\n    }\n  }\n  const std::string* iris_response = payload->FindString(\"irisResponse\");\n  const std::string* url = payload->FindString(\"url\");\n  if (iris_response && url) {\n    const GURL iris_response_gurl = GURL(*url);\n    if (iris_response_gurl.is_valid()) {\n      std::unique_ptr<MsRecommendationIrisTelemetryAction>\n        telemetry_action_handler = std::make_unique<\n          MsRecommendationIrisTelemetryAction>();\n      telemetry_action_handler->HandleIrisAction(*iris_response,\n        iris_response_gurl);\n    }\n  }\n#endif\n\n  if (callback_)\n    std::move(callback_).Run(response_obj.get());\n\n  RunUiCallbackAndDeleteAction(action_store, store_index, campaign_id,\n                               /*action_completion_status*/ true);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles telemetry data and triggers campaign actions based on system settings and payload content."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_next_sites\\edge_next_sites_service.cc:591-616","function":"EdgeNextSitesService::TriggerCleanupForPersonalizedLaunch","codesnippet":"{\n  LogMlSuggestionSitesServiceState(\n      edge_ml_sites::MlSuggestionSitesServiceState::\n          kRemovePersonalizedLaunchSites);\n  switch (reason) {\n    case PersonalizedLaunchCleanupReason::kSanConsentRevoked:\n      LogMlSuggestionSitesServiceState(\n          edge_ml_sites::MlSuggestionSitesServiceState::kSanConsentRevoked);\n      break;\n    case PersonalizedLaunchCleanupReason::kMlSettingTurnedOff:\n      LogMlSuggestionSitesServiceState(\n          edge_ml_sites::MlSuggestionSitesServiceState::\n              kMLSuggestedSitesDisabled);\n      break;\n    case PersonalizedLaunchCleanupReason::kOpenTabsDisabled:\n      LogMlSuggestionSitesServiceState(\n          edge_ml_sites::MlSuggestionSitesServiceState::\n          kOpenTabsDisabled);\n      break;\n    case PersonalizedLaunchCleanupReason::kCiConsentRevoked:\n      LogMlSuggestionSitesServiceState(\n          edge_ml_sites::MlSuggestionSitesServiceState::kCiConsentRevoked);\n      break;\n  }\n  pref_service_->ClearPref(prefs::kPersonalizedLaunchMlSuggestedUrlsCache);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs the state change of ML suggestion sites and clears the personalized launch URLs cache."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\peripherals\\logging\\logging.cc:30-52","function":"PeripheralsScopedLogMessage::~PeripheralsScopedLogMessage","codesnippet":"{\n  // For now, only emit logs if they are warning or more severe OR if the flag\n  // is enabled.\n  const std::string string_from_stream =\n      base::JoinString({GetFeaturePrefix(feature_), stream_.str()}, \" \");\n  if (ash::features::IsPeripheralsLoggingEnabled()) {\n    // TODO(dpad): Utilize the logs in the buffer in feedback reports.\n    PeripheralsLogBuffer::GetInstance()->AddLogMessage(\n        PeripheralsLogBuffer::LogMessage(string_from_stream, feature_,\n                                         base::Time::Now(), file_, line_,\n                                         severity_));\n  }\n\n  // Don't emit VERBOSE-level logging to the standard logging system.\n  if (severity_ <= logging::LOGGING_WARNING &&\n      !ash::features::IsPeripheralsLoggingEnabled()) {\n    return;\n  }\n\n  // The destructor of |log_message| also creates a log for the standard logging\n  // system.\n  logging::LogMessage log_message(file_, line_, severity_);\n  log_message.stream() << string_from_stream;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs messages with specific severity levels and optionally to a buffer if a feature is enabled."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\privacy_sandbox\\privacy_sandbox_settings_delegate.cc:350-400","function":"PrivacySandboxSettingsDelegate::\n    AreThirdPartyCookiesBlockedByCookieDeprecationExperiment","codesnippet":"{\n  if (net::cookie_util::IsForceThirdPartyCookieBlockingEnabled()) {\n    return false;\n  }\n\n  if (!IsCookieDeprecationExperimentEligible()) {\n    return false;\n  }\n\n  if (!tpcd::experiment::kDisable3PCookies.Get()) {\n    return false;\n  }\n\n  auto* tracking_protection_onboarding =\n      TrackingProtectionOnboardingFactory::GetForProfile(profile_);\n  if (!tracking_protection_onboarding) {\n    return false;\n  }\n\n  // Third-party cookies are not disabled until the profile gets onboarded.\n  switch (tracking_protection_onboarding->GetOnboardingStatus()) {\n    case privacy_sandbox::TrackingProtectionOnboarding::OnboardingStatus::\n        kIneligible:\n    case privacy_sandbox::TrackingProtectionOnboarding::OnboardingStatus::\n        kEligible:\n      return false;\n    case privacy_sandbox::TrackingProtectionOnboarding::OnboardingStatus::\n        kOnboarded:\n      break;\n  }\n\n  // Respect user preferences.\n\n  auto* tracking_protection_settings =\n      TrackingProtectionSettingsFactory::GetForProfile(profile_);\n  if (tracking_protection_settings &&\n      tracking_protection_settings->AreAllThirdPartyCookiesBlocked()) {\n    return false;\n  }\n\n  const auto cookie_controls_mode =\n      static_cast<content_settings::CookieControlsMode>(\n          profile_->GetPrefs()->GetInteger(prefs::kCookieControlsMode));\n\n  if (cookie_controls_mode ==\n      content_settings::CookieControlsMode::kBlockThirdParty) {\n    return false;\n  }\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if third-party cookies should be allowed based on various conditions and user settings."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\languages\\page_data_provider_languages_customize_dictionary.cc:28-111","function":"CustomizeDictionaryPageDataProvider::SetSections","codesnippet":"{\n  // Page header\n  auto* section = CreateSection(cached_page_ptr_.get());\n  auto* header = CreateHeaderInSection(section);\n  RegisterSearchableString(section, &(header->title),\n                           IDS_SETTINGS_LANGUAGES_SPELL_CHECK_MANAGE,\n                           nullptr /* row */);\n  auto parent_info = std::vector<std::pair<mojom::SettingsPageIds, int>>{\n      {mojom::SettingsPageIds::Languages, IDS_SETTINGS_LANGUAGES_PAGE_TITLE}};\n  CreateParentInfoInHeader(header, parent_info);\n\n  mojom::Row* row = nullptr;\n\n  // Row: Words you've added\n  // TODO :: wenjiangxu@microsoft.com this row may has managed icon or\n  // something, check:\n  // generateManagedIconForPref(this.props.prefs.enableSpellcheckPref)}\n  // chrome/browser/resources/edge_settings_react/src/sections/languages/edit-dictionary-section.tsx\n  row = CreateRowInSection(section);\n  row->clickable = false;\n  row->type = mojom::RowType::Button;\n  RegisterSearchableString(section, &(row->title),\n                           IDS_SETTINGS_LANGUAGES_DICTIONARY_WORDS, row);\n  auto* button = CreateButtonInRow(row);\n  button->id = mojom::FormControlIds::CustomizeDictionaryAddWordButton;\n  button->buttonType = mojom::ButtonType::DialogButton;\n  button->actionType = mojom::ActionType::Command;\n  RegisterSearchableString(section, &(button->text),\n                           IDS_SETTINGS_LANGUAGES_ADD_DICTIONARY_WORD_BUTTON,\n                           row);\n\n  base::Value::List validators = base::Value::List();\n  validators.Append(\n      CreateNotEmptyValidator(IDS_EDGE_FEEDBACK_DESCRIPTION_REQUIRED_LABEL));\n\n  // This row has button to pop up a dialog\n  dialog_utils::CustomFormDialog add_word_dialog(\n      mojom::FormControlIds::CustomizeDictionaryAddWordDialog);\n  add_word_dialog.Title(IDS_SETTINGS_LANGUAGES_ADD_DICTIONARY_WORD_BUTTON)\n      .AppendField(\n          dialog_utils::InputField()\n              .Name(\"word\")\n              .SetIsRequired(true)\n              .ValueType(\"text\")\n              .Validators(std::move(validators))\n              .AddValidator(\n                  \"Under100LetterValidation\",\n                  GetResourceString(\n                      IDS_SETTINGS_LANGUAGES_ADD_DICTIONARY_WORD_LENGTH_ERROR))\n              .Placeholder(IDS_SETTINGS_LANGUAGES_DICTIONARY_DIALOG_PLACEHOLDER)\n              .AriaLabel(IDS_SETTINGS_LANGUAGES_DICTIONARY_DIALOG_PLACEHOLDER))\n      .CancelButtonText(IDS_SETTINGS_LANGUAGES_DICTIONARY_DIALOG_CANCEL)\n      .ConfirmButtonText(IDS_SETTINGS_LANGUAGES_DICTIONARY_DIALOG_ADD);\n  button->info = add_word_dialog.ToString();\n\n  // Row: dictionary words\n  // chrome/browser/resources/edge_settings_react/src/sections/languages/edit-dictionary-section.tsx\n  // LanguageSettingsPrivateGetSpellcheckWordsFunction::Run()\n  if (IsTestingProfile() && skip_initialize_dictionaries_in_test) {\n    return;\n  }\n  spell_check_service_ =\n      SpellcheckServiceFactory::GetForContext(profile_.get());\n  SpellcheckCustomDictionary* dictionary =\n      spell_check_service_->GetCustomDictionary();\n  if (dictionary->IsLoaded()) {\n    const std::set<std::string>& words = dictionary->GetWords();\n    if (words.empty()) {\n      row = CreateRowInSection(section);\n      row->clickable = false;\n      RegisterSearchableString(section, &(row->description),\n                               IDS_SETTINGS_LANGUAGES_DICTIONARY_NO_WORDS, row);\n    } else {\n      for (auto it = words.begin(); it != words.end(); ++it) {\n        base::Value::Dict info;\n        info.Set(\"word\", *it);\n        row = CreateActionButtonRowInSection(\n            section, mojom::FormControlIds::CustomizeDictionaryRemoveWordButton,\n            *it, \"closeIcon\", info,\n            IDS_SETTINGS_LANGUAGES_DELETE_DICTIONARY_WORD_A11Y_LABEL, *it);\n        row->indent = true;\n      }\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and manages a section for spell check settings, allowing users to add and remove custom dictionary words."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_mobile_top_sites\\core\\browser\\metrics\\top_sites_metrics.cc:268-299","function":"RecordBooleanSettingAction","codesnippet":"{\n  switch (setting_name) {\n    case TopSitesSettingName::OPTIMIZE_ENABLED:\n      if (enabled) {\n        base::UmaHistogramEnumeration(\n            kTopSitesSettingActionHistogram,\n            TopSitesSettingAction::kEnableQualityOptimize,\n            TopSitesSettingAction::kMaxValue);\n      } else {\n        base::UmaHistogramEnumeration(\n            kTopSitesSettingActionHistogram,\n            TopSitesSettingAction::kDisableQualityOptimize,\n            TopSitesSettingAction::kMaxValue);\n      }\n      break;\n    case TopSitesSettingName::OPTIMIZE_POLICY_ENABLED:\n      if (enabled) {\n        base::UmaHistogramEnumeration(\n            kTopSitesSettingActionHistogram,\n            TopSitesSettingAction::kEnableQualityOptimizeAADPolicy,\n            TopSitesSettingAction::kMaxValue);\n      } else {\n        base::UmaHistogramEnumeration(\n            kTopSitesSettingActionHistogram,\n            TopSitesSettingAction::kDisableQualityOptimizeAADPolicy,\n            TopSitesSettingAction::kMaxValue);\n      }\n      break;\n    default:\n      break;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs actions related to enabling or disabling top sites optimization settings."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\utility\\image_writer\\image_writer_handler.cc:35-67","function":"ImageWriterHandler::Write","codesnippet":"{\n  client_.Bind(std::move(client));\n  client_.set_disconnect_handler(\n      base::BindOnce(&ImageWriterHandler::Cancel, base::Unretained(this)));\n\n  base::FilePath target_device = device;\n  const bool test_mode = IsTestDevice(device);\n  if (test_mode)\n    target_device = MakeTestDevicePath(image);\n\n  if (ShouldResetImageWriter(image, target_device))\n    image_writer_ = std::make_unique<ImageWriter>(this, image, target_device);\n\n  if (image_writer_->IsRunning()) {\n    SendFailed(error::kOperationAlreadyInProgress);\n    return;\n  }\n\n  if (test_mode) {\n    image_writer_->Write();\n    return;\n  }\n\n  if (!image_writer_->IsValidDevice()) {\n    SendFailed(error::kInvalidDevice);\n    return;\n  }\n\n  image_writer_->UnmountVolumes(\n      base::BindOnce(&ImageWriter::Write, image_writer_->AsWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and manages the image writing process to a specified device."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\ip_protection\\common\\ip_protection_token_manager_impl.cc:163-196","function":"IpProtectionTokenManagerImpl::ScheduleMaybeRefillCache","codesnippet":"{\n  // Early return cases:\n  // 1. If currently retrieving tokens, the call will be rescheduled when that\n  //    completes, so there is no need to call a refill here.\n  // 2. If there is no config getter or config cache, there is nothing to do.\n  // 3. If testing requires disabling the cache management.\n  if (fetching_auth_tokens_ || !fetcher_ || !ip_protection_core_ ||\n      disable_cache_management_for_testing_) {\n    next_maybe_refill_cache_.Stop();\n    return;\n  }\n\n  base::Time now = base::Time::Now();\n  base::TimeDelta delay;\n\n  if (NeedsRefill(current_geo_id_)) {\n    if (try_get_auth_tokens_after_.is_null()) {\n      delay = base::TimeDelta();\n    } else {\n      delay = try_get_auth_tokens_after_ - now;\n    }\n  } else {\n    // Delay refill to when the next token expires.\n    delay = cache_by_geo_[current_geo_id_].front().expiration - now;\n  }\n\n  if (delay.is_negative()) {\n    delay = base::TimeDelta();\n  }\n\n  next_maybe_refill_cache_.Start(\n      FROM_HERE, delay,\n      base::BindOnce(&IpProtectionTokenManagerImpl::MaybeRefillCache,\n                     weak_ptr_factory_.GetWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Schedules a cache refill based on token expiration and current conditions."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_themes\\ai_themes\\edge_ai_themes_handler.cc:141-173","function":"EdgeAiThemesHandler::FetchGeneratedImageUrl","codesnippet":"{\n  std::string puid = GetPuid(profile_.get());\n  if (puid.empty()) {\n    // Profile Authentication Error\n    edge_ai_themes::mojom::ImageFetchResponsePtr fetch_response;\n    fetch_response = edge_ai_themes::mojom::ImageFetchResponse::NewError(\n        edge_image_theme::mojom::Error::New(\n            \"UserIssue\",\n            l10n_util::GetStringUTF8(IDS_AI_THEMES_ERROR_USERISSUE)));\n    std::move(callback).Run(std::move(fetch_response));\n    return;\n  }\n\n  if (!edge::themes::IsAiGenThemesPolicyEnabled(profile_.get())) {\n    edge_ai_themes::mojom::ImageFetchResponsePtr fetch_response;\n    fetch_response = edge_ai_themes::mojom::ImageFetchResponse::NewError(\n        edge_image_theme::mojom::Error::New(\n            \"DefaultError\",\n            l10n_util::GetStringUTF8(IDS_AI_THEMES_DEFAULT_ERROR)));\n    std::move(callback).Run(std::move(fetch_response));\n    return;\n  }\n\n  edge::themes::FetchAIGenResponseCallback image_url_fetch_callback =\n      base::BindOnce(&EdgeAiThemesHandler::OnFetchRequestCompleted,\n                     weak_ptr_factory_.GetWeakPtr(), request_id,\n                     std::move(callback));\n\n  theme_manager_->FetchAIGenImageUrls(prompt, puid, request_id,\n                                      std::move(image_url_fetch_callback));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Fetches AI-generated image URLs or returns an error response if authentication or policy checks fail."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\commerce\\core\\webui\\shopping_service_handler.cc:257-311","function":"ConvertProductSpecificationsToProto","codesnippet":"{\n  for (auto pair : specs.product_dimension_map) {\n    optimization_guide::proto::ProductSpecificationSection* section =\n        product_spec_data->add_product_specification_sections();\n    section->set_key(base::NumberToString(pair.first));\n    section->set_title(pair.second);\n  }\n\n  for (auto product : specs.products) {\n    optimization_guide::proto::ProductSpecification* product_spec =\n        product_spec_data->add_product_specifications();\n    product_spec->mutable_identifiers()->set_gpc_id(product.product_cluster_id);\n    product_spec->mutable_identifiers()->set_mid(product.mid);\n    product_spec->set_title(product.title);\n    product_spec->set_image_url(product.image_url.spec());\n\n    for (auto pair : product.product_dimension_values) {\n      optimization_guide::proto::ProductSpecificationValue*\n          product_specification_value =\n              product_spec->add_product_specification_values();\n      product_specification_value->set_key(base::NumberToString(pair.first));\n\n      for (auto description : pair.second.descriptions) {\n        optimization_guide::proto::ProductSpecificationDescription*\n            product_specification_description =\n                product_specification_value->add_specification_descriptions();\n        product_specification_description->set_label(description.label);\n        product_specification_description->set_alternative_text(\n            description.alt_text);\n        for (auto option : description.options) {\n          optimization_guide::proto::ProductSpecificationDescription::Option*\n              option_proto = product_specification_description->add_options();\n          for (auto option_description : option.descriptions) {\n            optimization_guide::proto::DescriptionText* description_text =\n                option_proto->add_description();\n            ConvertDescriptionTextToProto(option_description, description_text);\n          }\n        }\n      }\n\n      for (auto summary : pair.second.summary) {\n        optimization_guide::proto::DescriptionText* summary_description =\n            product_specification_value->add_summary_description();\n        ConvertDescriptionTextToProto(summary, summary_description);\n      }\n    }\n\n    for (auto description_text : product.summary) {\n      optimization_guide::proto::DescriptionText* summary_description =\n          product_spec->add_summary_description();\n      ConvertDescriptionTextToProto(description_text, summary_description);\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Populates product specification data with details from product dimensions and descriptions."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\privacy\\edge_profile_id_manager.cc:252-301","function":"EdgeProfileIDManager::UploadEdgeProfileID","codesnippet":"{\n  // If an upload is in progress, skip this upload.\n  if (simple_url_loader_) {\n    return;\n  }\n\n  std::string edge_profile_id = profile_->GetEdgeProfileID();\n  if (edge_profile_id.empty()) {\n    return;\n  }\n\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"edge_profile_id_upload_ping\", R\"(\n          semantics {\n            sender: \"Edge Profile ID manager\"\n            description:\n              \"This request is used by the Edge Profile ID manager to upload\"\n              \"an identifier for the browser profile.\"\n            trigger:\n              \"Profile startup and MUID changes.\"\n            data: \"An identifier for the browser profile.\"\n            destination: MICROSOFT_OWNED_SERVICE\n          }\n          policy {\n            cookies_allowed: NO\n            setting: \"This feature can be disabled in settings.\"\n            policy_exception_justification:\n              \"Controlled by Edge policy: PersonalizationReportingEnabled.\"\n          })\");\n\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n\n  resource_request->url =\n      GURL(kBingEndpointUrlWithParams + edge_profile_id);\n  resource_request->method = \"GET\";\n  resource_request->load_flags = net::LOAD_DO_NOT_SAVE_COOKIES;\n\n  simple_url_loader_ = network::SimpleURLLoader::Create(\n      std::move(resource_request), traffic_annotation);\n  simple_url_loader_->SetTimeoutDuration(base::Seconds(30));\n  simple_url_loader_->SetAllowHttpErrorResults(true);\n\n  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =\n      profile_->GetDefaultStoragePartition()\n          ->GetURLLoaderFactoryForBrowserProcess();\n  simple_url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      url_loader_factory.get(),\n      base::BindOnce(&EdgeProfileIDManager::OnUploadResult,\n                     weak_factory_.GetWeakPtr(), upload_reason));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Uploads the browser profile identifier to a Microsoft service."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\password_manager\\core\\browser\\edge_scoped_db_error_handler.cc:179-259","function":"EdgeScopedDbErrorHandler::DiagnoseOpenError","codesnippet":"{\n  using edge_password_manager::metrics_util::EdgePasswordLoginDbProcessLockType;\n  using edge_password_manager::metrics_util::\n      LogLoginDBProcessTerminatedSameAsLocked;\n  using edge_password_manager::metrics_util::LogPasswordLoginDbProcessErrorCode;\n\n  DCHECK(db_);\n  DCHECK(!db_->is_open());\n  DCHECK(!sql::IsSqliteSuccessCode(result_code));\n\n  if (!IsLastSeenErrorLockRelated()) {\n    return false;\n  }\n\n  if (!base::FeatureList::IsEnabled(features::kDumpProcessHandlesOnError)) {\n    return false;\n  }\n\n#if BUILDFLAG(IS_WIN)\n  std::vector<edge_import::LockProcessInfo> process_infos;\n  HRESULT hr =\n      edge_import::GetProcessInfosHoldingFileLock(db_path, process_infos);\n  if (FAILED(hr)) {\n    LogPasswordLoginDbProcessErrorCode(static_cast<int>(hr));\n    return false;\n  }\n\n  if (process_infos.empty()) {\n    if (CanOpenFileExclusively(db_path)) {\n      return true;\n    }\n\n    TRACE_EVENT_INSTANT0(\"perftrack\", \"EdgeLoginDbError.LockedFileNoPid\",\n                         TRACE_EVENT_SCOPE_THREAD);\n    LogPasswordLoginDbProcessErrorCode(E_ACCESSDENIED);\n    return false;\n  }\n\n  TRACE_EVENT_INSTANT0(\"perftrack\", \"EdgeLoginDbError.LockedFileWithPid\",\n                       TRACE_EVENT_SCOPE_THREAD);\n\n  bool found_nonedge_locker = false;\n  const auto current_pid = base::GetCurrentProcId();\n  base::ProcessId edge_process_id = 0;\n  uint32_t terminated_process_id = *(GetTerminatedEdgeProcessID());\n  TRACE_EVENT_INSTANT1(\"perftrack\", \"EdgeLoginDbError.AttemptTerminateProcess\",\n                       TRACE_EVENT_SCOPE_THREAD, \"Pid\", terminated_process_id);\n  for (const auto& process_info : process_infos) {\n    if (process_info.pid == current_pid) {\n      continue;\n    }\n\n    LogLoginDBProcessTerminatedSameAsLocked(terminated_process_id ==\n                                            process_info.pid);\n\n    TRACE_EVENT_INSTANT1(\"perftrack\", \"EdgeLoginDbError.LockedFileProcess\",\n                         TRACE_EVENT_SCOPE_THREAD, \"Pid\", process_info.pid);\n    if (process_info.process_name.starts_with(L\"msedge\") ||\n        process_info.process_name.starts_with(L\"Microsoft Edge\")) {\n      LogPasswordLoginDbProcessLockType(\n          EdgePasswordLoginDbProcessLockType::kEdgeProcess);\n      edge_process_id = process_info.pid;\n    } else {\n      LogPasswordLoginDbProcessLockType(\n          EdgePasswordLoginDbProcessLockType::kNonEdgeProcess);\n      found_nonedge_locker = true;\n    }\n  }\n\n  if (found_nonedge_locker) {\n    base::debug::DumpWithoutCrashing();\n  } else if (edge_process_id != 0) {\n    const EdgeProcessInformation process_information =\n        GetEdgeProcessInformationWin(edge_process_id);\n    DumpEdgeProcess(edge_process_id, process_information);\n  }\n#endif  // BUILDFLAG(IS_WIN)\n\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Identifies and logs processes holding a lock on a database file, specifically targeting Microsoft Edge processes."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_session_context\\edge_session_context.cc:342-362","function":"SessionContext::InitializeOperatingSystem","codesnippet":"{\n#if BUILDFLAG(IS_WIN)\n  os_version_ = base::win::GetVersion();\n  if (os_version_ >= base::win::Version::WIN10) {\n    operating_system_ = OperatingSystemEnumeration::WIN10;\n  } else if (os_version_ == base::win::Version::WIN8 ||\n             os_version_ == base::win::Version::WIN8_1) {\n    operating_system_ = OperatingSystemEnumeration::WIN8;\n  } else if (os_version_ == base::win::Version::WIN7) {\n    operating_system_ = OperatingSystemEnumeration::WIN7;\n  }\n#elif BUILDFLAG(IS_MAC)\n  operating_system_ = OperatingSystemEnumeration::MACOS;\n#elif BUILDFLAG(IS_LINUX)\n  operating_system_ = OperatingSystemEnumeration::LINUX;\n#elif BUILDFLAG(IS_ANDROID)\n  operating_system_ = OperatingSystemEnumeration::ANDROID_OS;\n#else\n  // this folder  not built on IOS, so IOS_OS currently unused\n  operating_system_ = OperatingSystemEnumeration::OTHER;\n#endif\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the operating system and assigns the corresponding enumeration value."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\commands\\fetch_install_info_from_install_url_command.cc:357-393","function":"FetchInstallInfoFromInstallUrlCommand::EdgeOnManifestWaitComplete","codesnippet":"{\n  edge_wait_for_manifest_task_.reset();\n  switch (result) {\n    case EdgeWaitForManifestTask::Result::WebContentDestroyed:\n      CompleteCommandAndSelfDestruct(\n          FetchInstallInfoResult::kWebContentsDestroyed,\n          /*install_info=*/nullptr);\n      break;\n    case EdgeWaitForManifestTask::Result::Timeout:\n      // The preinstalled app recovery should always have a manifest.\n      if (install_source_.has_value() &&\n          IsEdgePreinstalledAppRecovery(install_source_.value())) {\n        CompleteCommandAndSelfDestruct(\n            FetchInstallInfoResult::kUrlLoadingFailure,\n            /*install_info=*/nullptr);\n        break;\n      }\n\n      // Because we allowed for redirects, we need to check that the final URL\n      // is still valid for installation.\n      if (!web_app::IsValidWebAppUrl(\n              lock_->shared_web_contents().GetLastCommittedURL())) {\n        CompleteCommandAndSelfDestruct(\n            FetchInstallInfoResult::kUrlLoadingFailure,\n            /*install_info=*/nullptr);\n        return;\n      }\n\n      // App recovery handles reinstall of both PWA and site-as-app installed\n      // apps which may not have a PWA manifest on their page.\n      [[fallthrough]];\n    case EdgeWaitForManifestTask::Result::ManifestFound:\n      OnWebAppUrlLoadedGetWebAppInstallInfo(\n          webapps::WebAppUrlLoader::Result::kUrlLoaded);\n      break;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles the completion of a web app installation process based on the manifest retrieval result."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\app_list\\search\\local_image_search\\image_annotation_worker.cc:278-341","function":"ImageAnnotationWorker::OnDlcInstalled","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  bool is_ica_dlc_installed =\n      image_content_annotator_ && image_content_annotator_->IsDlcInitialized();\n  bool is_ocr_dlc_installed = optical_character_recognizer_ &&\n                              optical_character_recognizer_->is_ready();\n\n  if ((use_ocr_ && !is_ocr_dlc_installed) ||\n      (use_ica_ && !is_ica_dlc_installed)) {\n    DVLOG(1) << \"DLCs are not ready. OCR: \" << is_ocr_dlc_installed << \"/\"\n             << use_ocr_ << \" ICA: \" << is_ica_dlc_installed << \"/\" << use_ica_\n             << \". Waiting.\";\n\n    if (num_retries_passed_ > kMaxNumRetries) {\n      if (use_ica_ && !is_ica_dlc_installed) {\n        LOG(ERROR) << \"Failed to initialize ICA.\";\n        LogStatusUma(Status::kFailedToInitializeIca);\n      }\n      if (use_ocr_ && !is_ocr_dlc_installed) {\n        LOG(ERROR) << \"Failed to initialize OCR.\";\n        LogStatusUma(Status::kFailedToInitializeOcr);\n      }\n      return;\n    }\n\n    // The installation status of `image_content_annotator_` only updates when\n    // function `EnsureAnnotatorIsConnected()` is called. Thus, at each retry we\n    // should trigger it again so that it attempts to bind the annotator.\n    if (use_ica_) {\n      image_content_annotator_->EnsureAnnotatorIsConnected();\n    }\n\n    // It is expected to be ready on a first try. Also, it is not a time\n    // sensitive task, so we do not need to implement a full-fledged observer.\n    main_task_runner_->PostDelayedTask(\n        FROM_HERE,\n        base::BindOnce(&ImageAnnotationWorker::OnDlcInstalled,\n                       weak_ptr_factory_.GetWeakPtr()),\n        base::Seconds(std::pow(kRetryDelay, num_retries_passed_)));\n    num_retries_passed_ += 1;\n    image_content_annotator_->set_num_retries_passed(num_retries_passed_);\n    return;\n  }\n\n  if (use_file_watchers_) {\n    DVLOG(1) << \"DLCs are ready. Watching for file changes: \" << root_path_;\n    file_watcher_ = std::make_unique<base::FilePathWatcher>();\n\n    // `file_watcher_` needs to be deleted in the same sequence it was\n    // initialized.\n    file_watcher_->WatchWithOptions(\n        root_path_,\n        {.type = base::FilePathWatcher::Type::kRecursive,\n         .report_modified_path = true},\n        on_file_change_callback_);\n  }\n\n  if (search_features::IsLauncherImageSearchDebugEnabled()) {\n    LOG(ERROR) << \"DLC initialization succeed.\";\n  }\n\n  LogStatusUma(Status::kOk);\n  OnFileChange(root_path_, /*error=*/false);\n  FindAndRemoveDeletedFiles(annotation_storage_->GetAllFiles());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and monitors DLC components for image content annotation and OCR, handling retries and logging status."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\variations\\variations_seed_processor.cc:78-100","function":"GetKeyForWebExperiment","codesnippet":"{\n  if (!VariationsSeedProcessor::HasGoogleWebExperimentId(experiment)) {\n    return std::nullopt;\n  }\n  bool has_web_experiment_id = experiment.has_google_web_experiment_id();\n  bool has_web_trigger_experiment_id =\n      experiment.has_google_web_trigger_experiment_id();\n\n  // An experiment cannot have both |google_web_experiment_id| and\n  // |google_trigger_web_experiment_id|. This is enforced by the variations\n  // server before generating a variations seed.\n  CHECK(!(has_web_experiment_id && has_web_trigger_experiment_id));\n\n  Study::GoogleWebVisibility visibility = experiment.google_web_visibility();\n  if (visibility == Study::FIRST_PARTY) {\n    return has_web_trigger_experiment_id\n               ? GOOGLE_WEB_PROPERTIES_TRIGGER_FIRST_PARTY\n               : GOOGLE_WEB_PROPERTIES_FIRST_PARTY;\n  }\n  return has_web_trigger_experiment_id\n             ? GOOGLE_WEB_PROPERTIES_TRIGGER_ANY_CONTEXT\n             : GOOGLE_WEB_PROPERTIES_ANY_CONTEXT;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the Google web properties context based on experiment visibility and IDs."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\smb_client\\smb_share_finder.cc:23-53","function":"SmbShareFinder::GatherSharesInNetwork","codesnippet":"{\n  const bool is_host_discovery_pending = !discovery_callbacks_.empty();\n  const bool is_share_discovery_pending = !share_callbacks_.empty();\n\n  if (is_host_discovery_pending) {\n    // Host discovery is currently running, add both |discovery_callback| and\n    // |share_callback| to their respective vectors.\n    InsertDiscoveryAndShareCallbacks(std::move(discovery_callback),\n                                     std::move(shares_callback));\n    return;\n  }\n\n  if (is_share_discovery_pending) {\n    // Host discovery is complete but there are still share callbacks pending.\n    // Run |discovery_callback| because pending share discoveries and no pending\n    // host discoveries indicate that a host discovery must have recently\n    // completed.\n    std::move(discovery_callback).Run();\n    InsertShareCallback(std::move(shares_callback));\n    return;\n  }\n\n  // No host discovery or share discovery in progress. This is only because\n  // GatherSharesInNetwork has not been called yet or the previous host\n  // discovery has been fully completed.\n  InsertDiscoveryAndShareCallbacks(std::move(discovery_callback),\n                                   std::move(shares_callback));\n  scanner_.FindHostsInNetwork(base::BindOnce(&SmbShareFinder::OnHostsFound,\n                                             weak_ptr_factory_.GetWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles and queues discovery and share callbacks based on current discovery status."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\media\\router\\providers\\cast\\cast_session_tracker.cc:87-111","function":"CastSessionTracker::HandleReceiverStatusMessage","codesnippet":"{\n  const base::Value::Dict* status = message.FindDict(\"status\");\n  auto session = status ? CastSession::From(sink, *status) : nullptr;\n  const MediaSink::Id& sink_id = sink.sink().id();\n  if (!session) {\n    if (sessions_by_sink_id_.erase(sink_id)) {\n      for (auto& observer : observers_) {\n        observer.OnSessionRemoved(sink);\n      }\n    }\n    return;\n  }\n\n  auto it = sessions_by_sink_id_.find(sink_id);\n  if (it == sessions_by_sink_id_.end()) {\n    it = sessions_by_sink_id_.emplace(sink_id, std::move(session)).first;\n  } else {\n    it->second->UpdateSession(std::move(session));\n  }\n\n  for (auto& observer : observers_) {\n    observer.OnSessionAddedOrUpdated(sink, *it->second);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates or removes a session based on its status and notifies observers."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\updater\\app\\app_uninstall.cc:105-135","function":"UninstallEnterpriseCompanionApp","codesnippet":"{\n  std::optional<base::FilePath> exe_path =\n      enterprise_companion::FindExistingInstall();\n  if (!exe_path) {\n    VLOG(1) << __func__\n            << \": Could not locate an enterprise companion app installation.\";\n    return kErrorOk;\n  }\n\n  base::CommandLine command_line(*exe_path);\n  command_line.AppendSwitch(kUninstallCompanionAppSwitch);\n  int exit_code = -1;\n  std::string output;\n  if (!base::GetAppOutputWithExitCode(command_line, &output, &exit_code)) {\n    return kErrorFailedToUninstallCompanionApp;\n  }\n  VLOG(1) << __func__ << \": Ran: \" << command_line.GetCommandLineString()\n          << \": \" << output << \": \" << exit_code;\n\n  // Wait until the enterprise companion install is completely removed. For\n  // instance, enterprise companion spawns a separate cmd script on Windows to\n  // complete the uninstall.\n  for (const auto deadline = base::TimeTicks::Now() + base::Seconds(20);\n       enterprise_companion::FindExistingInstall() &&\n       (base::TimeTicks::Now() < deadline);\n       base::PlatformThread::Sleep(base::Milliseconds(100))) {\n  }\n  VLOG(1) << __func__ << \": !enterprise_companion::FindExistingInstall(): \"\n          << !enterprise_companion::FindExistingInstall();\n\n  return exit_code == 0 ? kErrorOk : kErrorFailedToUninstallCompanionApp;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Uninstalls the enterprise companion app if installed."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\renderer\\edge_pepper\\pepper_flash_font_file_host.cc:27-60","function":"PepperFlashFontFileHost::PepperFlashFontFileHost","codesnippet":"{\n#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)\n  // The global SkFontConfigInterface is configured and initialized with a\n  // SkFontconfigInterface compatible font_service::FontLoader in\n  // RendererBlinkPlatformImpl (called from RenderThreadImpl::Init) at startup\n  // of the mimehandler process, which is a renderer type process. We can reuse\n  // it here to call a plugin specific font matching method out of process here.\n  // TODO(drott): Find a way to pass this through instead of casting.\n  font_service::FontLoader* font_loader_casted =\n      reinterpret_cast<font_service::FontLoader*>(\n          SkFontConfigInterface::RefGlobal().get());\n  font_loader_casted->MatchFontWithFallback(\n      description.face,\n      description.weight >= PP_BROWSERFONT_TRUSTED_WEIGHT_BOLD,\n      description.italic, charset, PP_BROWSERFONT_TRUSTED_FAMILY_DEFAULT,\n      &font_file_);\n#elif BUILDFLAG(IS_WIN)\n  int weight = description.weight;\n  if (weight == FW_DONTCARE)\n    weight = SkFontStyle::kNormal_Weight;\n  SkFontStyle style(weight, SkFontStyle::kNormal_Width,\n                    description.italic ? SkFontStyle::kItalic_Slant\n                                       : SkFontStyle::kUpright_Slant);\n  sk_sp<SkFontMgr> font_mgr = skia::DefaultFontMgr();\n\n  typeface_ = sk_sp<SkTypeface>(\n      font_mgr->matchFamilyStyle(description.face.c_str(), style));\n#endif\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Matches fonts with specified styles and fallbacks for different operating systems."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_embedded_browser\\embedded_browser_content_browser_client.cc:142-167","function":"EmbeddedBrowserContentBrowserClient::\n    EdgeCreateThrottlesForNavigationThatWillCommitWithoutUrlLoader","codesnippet":"{\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n  embedded_browser::EmbeddedBrowser* embedded_browser =\n      embedded_browser::EmbeddedBrowser::FromWebContents(\n          navigation_handle->GetWebContents());\n  if ((embedded_browser_webview_features::\n           IsEdgeWebViewCancellableAboutNavigationsEnabled() ||\n       (embedded_browser_webview_features::\n            IsEdgeWebViewCancelInitialNavigationEnabled() &&\n        // Always create the throttle that will cancel the initial\n        // navigation to about:blank\n        embedded_browser && embedded_browser->InInitializingNavigation())) &&\n      !navigation_handle->IsSameDocument()) {\n    std::unique_ptr<content::NavigationThrottle> embedded_browser_throttle =\n        EmbeddedBrowserNavigationThrottle::MaybeCreateThrottleFor(\n            navigation_handle);\n\n    if (embedded_browser_throttle) {\n      throttles.push_back(std::move(embedded_browser_throttle));\n    }\n  }\n\n  return throttles;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates navigation throttles for embedded browser conditions."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_wallet\\express_checkout\\wallet_popup_row_content_view.cc:411-440","function":"WalletPopupRowContentView::ToggleButtonClicked","codesnippet":"{\n  toggle_is_on_ = !toggle_is_on_;\n  toggle_button_->SetIsOn(toggle_is_on_);\n  if (tokenized_suggestion_type_ ==\n      edge_wallet::TokenizedSuggestionType::TOKENIZED_CARD) {\n    auto metric = toggle_is_on_\n                      ? autofill::EdgeAutofillMetrics::\n                            WalletTokenizationAutofillEventMetric::\n                                TOKENIZED_CARD_SUGGESTION_TOGGLE_TURNED_ON\n                      : autofill::EdgeAutofillMetrics::\n                            WalletTokenizationAutofillEventMetric::\n                                TOKENIZED_CARD_SUGGESTION_TOGGLE_TURNED_OFF;\n    autofill::EdgeAutofillMetrics::LogWalletTokenizationAutofillEventMetrics(\n        metric);\n    auto backend_id =\n        suggestion_.GetPayload<autofill::Suggestion::Guid>().value();\n    std::string server_id = backend_id;\n    autofill::CreditCard* credit_card =\n        const_cast<autofill::CreditCard*>(controller_->GetPersonalDataManager()\n                                              ->payments_data_manager()\n                                              .GetCreditCardByGUID(backend_id));\n    if (credit_card) {\n      server_id = credit_card->server_id();\n    }\n\n    controller_->UpdateCreditCardExtendedInfo(server_id, toggle_is_on_);\n    controller_->LogUseTokenizedCardToggleClickMetrics(server_id,\n                                                       toggle_is_on_);\n    return;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Toggles a card suggestion state and logs related metrics."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\services\\edge_entity_extraction\\onnx\\postprocessor_for_autofill.cc:619-665","function":"PostprocessorForAutofill::Run","codesnippet":"{\n  if (should_stop_execution && *should_stop_execution) {\n    base::Value::Dict empty_result;\n    std::unique_ptr<InferenceStepInput> result =\n        std::make_unique<InferenceResult>(std::move(empty_result));\n    return result;\n  }\n  TRACE_EVENT_BEGIN0(kTracingCategory,\n                     \"OnnxTraceEvent:PostprocessorForAutofill::Run\");\n  base::TimeTicks postprocessing_begin_time = base::TimeTicks::Now();\n  DCHECK(input);\n  entity_extraction::onnx::PostprocessInputForAutofill* postprocess_input =\n      static_cast<entity_extraction::onnx::PostprocessInputForAutofill*>(\n          input.get());\n\n  std::vector<int> predictions_unique;\n  std::vector<float> predictions_confidence_unique;\n  GetPredictedLabels(postprocess_input, predictions_unique,\n                     predictions_confidence_unique);\n  std::map<std::string, std::vector<std::map<std::string, std::string>>>\n      predictions_utf8;\n  base::Value::Dict raw_predictions;\n\n  PopulateRawPredictions(postprocess_input, predictions_unique,\n                         predictions_confidence_unique, predictions_utf8,\n                         raw_predictions);\n\n  // Add postprocessing for universal autofill\n  base::Value::Dict postprocessed_predictions;\n  PopulatePostprocessedPredictions(postprocess_input, predictions_utf8,\n                                   postprocessed_predictions);\n\n  base::Value::Dict output;\n  PopulateOnnxEntities(onnx_data, postprocess_input->page_locale(),\n                       raw_predictions, postprocessed_predictions, output);\n\n  entity_extraction::RecordTimeHistogramsForONNX(\n      postprocessing_begin_time, \".RunPostprocessingForAutofill\");\n\n  std::unique_ptr<InferenceStepInput> result =\n      std::make_unique<InferenceResult>(std::move(output));\n  TRACE_EVENT_END0(kTracingCategory,\n                   \"OnnxTraceEvent:PostprocessorForAutofill::Run\");\n  return result;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Processes input data to generate and return predictions for autofill."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\lens\\lens_overlay_entry_point_controller.cc:139-189","function":"LensOverlayEntryPointController::IsEnabled","codesnippet":"{\n  // This class is initialized if and only if it is observing.\n  if (!fullscreen_observation_.IsObserving()) {\n    return false;\n  }\n\n  // Feature is disabled via finch.\n  if (!lens::features::IsLensOverlayEnabled()) {\n    return false;\n  }\n\n  // Disable in fullscreen without top-chrome.\n  if (!lens::features::GetLensOverlayEnableInFullscreen() &&\n      browser_window_interface_->GetExclusiveAccessManager()\n          ->context()\n          ->IsFullscreen() &&\n      !browser_window_interface_->IsTabStripVisible()) {\n    return false;\n  }\n\n  const PrefService* pref_service =\n      browser_window_interface_->GetProfile()->GetPrefs();\n  // Lens Overlay is disabled via the legacy enterprise policy.\n  lens::prefs::LensOverlaySettingsPolicyValue old_policy_value =\n      static_cast<lens::prefs::LensOverlaySettingsPolicyValue>(\n          pref_service->GetInteger(lens::prefs::kLensOverlaySettings));\n  if (old_policy_value ==\n      lens::prefs::LensOverlaySettingsPolicyValue::kDisabled) {\n    return false;\n  }\n\n  // Lens Overlay is disabled via the GenAI enterprise policy.\n  lens::prefs::GenAiLensOverlaySettingsPolicyValue policy_value =\n      static_cast<lens::prefs::GenAiLensOverlaySettingsPolicyValue>(\n          pref_service->GetInteger(lens::prefs::kGenAiLensOverlaySettings));\n  if (policy_value ==\n      lens::prefs::GenAiLensOverlaySettingsPolicyValue::kDisabled) {\n    // Disabled via the enterprise policy.\n    return false;\n  }\n\n  // Lens Overlay is only enabled if the user's default search engine is Google.\n  if (lens::features::IsLensOverlayGoogleDseRequired() &&\n      !search::DefaultSearchProviderIsGoogle(\n          browser_window_interface_->GetProfile())) {\n    return false;\n  }\n\n  // Finally, only enable the overlay if user meets our minimum RAM requirement.\n  static int phys_mem_mb = base::SysInfo::AmountOfPhysicalMemoryMB();\n  return phys_mem_mb > lens::features::GetLensOverlayMinRamMb();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if the Lens Overlay feature should be enabled based on various conditions."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\passwords\\edge_password_items_view.cc:90-135","function":"BuildColumnSet","codesnippet":"{\n  // Passwords are split 60/40 (6:4) as the username is more important\n  // than obscured password digits. Otherwise two columns are 50/50 (1:1).\n  constexpr float kFirstColumnWeight = 60.0f;\n  constexpr float kSecondColumnWeight = 40.0f;\n  const int between_column_padding =\n      GetLayoutConstant(EDGE_AUTOFILL_SAVED_PASSWORD_HORIZONTAL_GAP);\n  table_layout\n      // favicon column\n      ->AddColumn(views::LayoutAlignment::kStretch,\n                  views::LayoutAlignment::kStretch,\n                  views::TableLayout::kFixedSize,\n                  views::TableLayout::ColumnSize::kUsePreferred, 0, 0)\n      .AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kStretch,\n                 views::LayoutAlignment::kStretch, kFirstColumnWeight,\n                 views::TableLayout::ColumnSize::kFixed, 0, 0)\n      .AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kStretch,\n                 views::LayoutAlignment::kStretch, kSecondColumnWeight,\n                 views::TableLayout::ColumnSize::kFixed, 0, 0);\n\n  if (type_id == MULTI_STORE_PASSWORD_COLUMN_SET) {\n    // All rows show a store indicator or leave the space blank.\n    table_layout\n        ->AddPaddingColumn(views::TableLayout::kFixedSize,\n                           between_column_padding)\n        .AddColumn(views::LayoutAlignment::kStretch,\n                   views::LayoutAlignment::kStretch,\n                   views::TableLayout::kFixedSize,\n                   views::TableLayout::ColumnSize::kUsePreferred, 0, 0)\n        // Add a column for the vertical bar.\n        .AddPaddingColumn(views::TableLayout::kFixedSize,\n                          between_column_padding)\n        .AddColumn(views::LayoutAlignment::kStretch,\n                   views::LayoutAlignment::kCenter,\n                   views::TableLayout::kFixedSize,\n                   views::TableLayout::ColumnSize::kUsePreferred, 0, 0);\n  }\n  // All rows end with a trailing column for the undo/trash button.\n  table_layout\n      ->AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kEnd, views::LayoutAlignment::kStretch,\n                 views::TableLayout::kFixedSize,\n                 views::TableLayout::ColumnSize::kUsePreferred, 0, 0);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Configures a table layout for displaying saved passwords with specific column weights and padding."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_e_drop\\core\\browser\\sync\\base_push_server_request.cc:101-149","function":"BasePushServerRequest::OnTokenFetched","codesnippet":"{\n  DCHECK(!url_loader_);\n\n  if (!success) {\n    OnError(Error::TOKEN_NOT_ACQUIRED, 0);\n    return;\n  }\n\n  auto token_piece = std::string_view(token);\n\n  // On Android there is a strange 't=' added before the token, should remove it\n  // so that our service could parse the token.\n  if (base::StartsWith(token_piece, \"t=\"))\n    token_piece.remove_prefix(2);\n\n  std::string final_token = \"Bearer \" + std::string(token_piece);\n\n  std::unique_ptr<network::ResourceRequest> resource_request =\n      std::make_unique<network::ResourceRequest>();\n  resource_request->url = url_;\n  resource_request->method = method_;\n\n  // Set token.\n  resource_request->headers.SetHeader(\"Authorization\", final_token);\n\n  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),\n                                                 traffic_annotation);\n  url_loader_->SetAllowHttpErrorResults(true);\n\n  // Request body.\n  std::string request_body = GetRequestBody();\n  DVLOG(2) << __func__ << \" Request json: \" << request_body;\n\n  if (method_ != net::HttpRequestHeaders::kGetMethod)\n    url_loader_->AttachStringForUpload(request_body, kJsonContentType);\n\n  // Do send request.\n  DCHECK(url_loader_factory_);\n  if (GetResponseLengthLimit() <= 0) {\n    url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n        url_loader_factory_.get(),\n        base::BindOnce(&BasePushServerRequest::OnURLLoaderComplete, this));\n  } else {\n    url_loader_->DownloadToString(\n        url_loader_factory_.get(),\n        base::BindOnce(&BasePushServerRequest::OnURLLoaderComplete, this),\n        GetResponseLengthLimit());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sends an HTTP request with an authorization token."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync\\test\\single_type_mock_server.cc:69-94","function":"SingleTypeMockServer::TombstoneFromServer","codesnippet":"{\n  int64_t old_version = GetServerVersion(tag_hash);\n  int64_t version = old_version + version_offset;\n  if (version > old_version) {\n    SetServerVersion(tag_hash, version);\n  }\n\n  sync_pb::SyncEntity entity;\n\n  entity.set_id_string(GenerateId(tag_hash));\n  entity.set_parent_id_string(type_root_id_);\n  entity.set_version(version);\n  entity.set_client_tag_hash(tag_hash.value());\n  entity.set_deleted(true);\n  AddDefaultFieldValue(type_, entity.mutable_specifics());\n\n  // Unimportant fields, set for completeness only.\n  base::Time ctime = base::Time::UnixEpoch() + base::Days(1);\n  base::Time mtime = ctime + base::Seconds(version);\n  entity.set_ctime(TimeToProtoTime(ctime));\n  entity.set_mtime(TimeToProtoTime(mtime));\n  entity.set_name(\"Tombstone\");\n\n  return entity;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a tombstone sync entity with updated version information."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\find_bar\\find_bar_controller.cc:381-406","function":"FindBarController::MaybeSetPrepopulateText","codesnippet":"{\n  // Having a per-tab find_string is not compatible with a global find\n  // pasteboard, so we always have the same find text in all find bars. This is\n  // done through the find pasteboard mechanism (see FindBarPlatformHelperMac),\n  // so don't set the text here.\n  if (find_bar_->HasGlobalFindPasteboard()) {\n    return;\n  }\n\n  // Find out what we should show in the find text box. Usually, this will be\n  // the last search in this tab, but if no search has been issued in this tab\n  // we use the last search string (from any tab).\n  find_in_page::FindTabHelper* find_tab_helper =\n      find_in_page::FindTabHelper::FromWebContents(web_contents());\n  std::u16string find_string = find_tab_helper->find_text();\n  if (find_string.empty()) {\n    find_string = find_tab_helper->GetInitialSearchText();\n  }\n\n  // Update the find bar with existing results and search text, regardless of\n  // whether or not the find bar is visible, so that if it's subsequently\n  // shown it is showing the right state for this tab. We update the find text\n  // _first_ since the FindBarView checks its emptiness to see if it should\n  // clear the result count display when there's nothing in the box.\n  find_bar_->SetFindTextAndSelectedRange(find_string,\n                                         find_tab_helper->selected_range());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Synchronizes the find text across tabs and updates the find bar with the current search state."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_e_drop\\core\\browser\\token_fetcher\\oauth_token_fetcher.cc:37-94","function":"OAuthTokenFetcher::GetAccessToken","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n\n  if (!identity_manager_) {\n    std::move(callback).Run(\"\", false);\n    return;\n  }\n\n  auto token_fetcher_pair = ongoing_access_token_fetcher_map_.find(token_type);\n  DCHECK(token_fetcher_pair != ongoing_access_token_fetcher_map_.end());\n\n  auto callbacks_pair = callbacks_map_.find(token_type);\n  DCHECK(callbacks_pair != callbacks_map_.end());\n\n  auto& ongoing_access_token_fetcher = token_fetcher_pair->second;\n  auto& callbacks = callbacks_pair->second;\n\n  CoreAccountInfo account_info =\n      identity_manager_->GetPrimaryAccountInfo(signin::ConsentLevel::kSignin);\n\n  // Can not get account, return an empty string,\n  if (account_info.IsEmpty()) {\n    std::move(callback).Run(\"\", false);\n    return;\n  }\n\n  // There is no expiration time in the token, OneAuth and Windows Api will\n  // handle the cache for us.\n  // Store the callback and will call after token fetched.\n  callbacks.push_back(std::move(callback));\n\n  // If there is an ongoing request, the callback stored will be called when\n  // this request has been finished.\n  if (ongoing_access_token_fetcher) {\n    return;\n  }\n\n  auto count_pair = record_time_tick_count_map_.find(token_type);\n  DCHECK(count_pair != record_time_tick_count_map_.end());\n  // The time-consuming for each type is only recorded ten times\n  if (count_pair->second < 10) {\n    record_time_tick_map_.insert_or_assign(token_type, base::TimeTicks::Now());\n    auto& count = count_pair->second;\n    count += 1;\n  }\n\n  // Otherwise start a new request.\n  // Start request the token.\n  // |ongoing_access_token_fetcher| is owned by this class, so it is safe to\n  // use base::Unretained here.\n  ongoing_access_token_fetcher =\n      identity_manager_->CreateAccessTokenFetcherForAccount(\n          account_info.account_id, kEdgeFlowTokenConsumerId,\n          {GetScopeByType(token_type)},\n          base::BindOnce(&OAuthTokenFetcher::OnTokenFetched,\n                         base::Unretained(this), token_type),\n          signin::AccessTokenFetcher::Mode::kImmediate);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initiates access token fetching for an account if no ongoing request exists."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_hub_apps\\service\\hub_apps_prefs_handler.cc:26-62","function":"HubAppsPrefsHandler::HubAppsPrefsHandler","codesnippet":"{\n  DCHECK(hub_model_);\n  DCHECK(pref_service_);\n  notification_prefs_handler_ =\n      std::make_unique<HubNotificationPrefsHandler>(pref_service_);\n  hub_app_icons_auto_show_prefs_handler_ =\n      std::make_unique<HubAppIconsAutoShowPrefsHandler>(pref_service_);\n  hub_apps_is_pinned_prefs_handler_ =\n      std::make_unique<HubAppsIsPinnedPrefsHandler>(pref_service_);\n  hub_apps_usage_prefs_handler_ =\n      std::make_unique<HubAppsUsagePrefsHandler>(pref_service_);\n  hub_apps_width_prefs_handler_ =\n      std::make_unique<HubAppsWidthPrefsHandler>(pref_service_);\n  hub_apps_auto_show_prefs_handler_ =\n      std::make_unique<HubAppsAutoShowPrefsHandler>(hub_model_, pref_service_,\n                                                    delegate);\n  hub_apps_last_path_prefs_handler_ =\n      std::make_unique<HubAppsLastPathPrefsHandler>(hub_model_, pref_service_);\n  hub_apps_dormancy_prefs_handler_ =\n      std::make_unique<HubAppsDormancyPrefsHandler>(pref_service_);\n  copilot_apps_prefs_handler_ =\n      std::make_unique<CopilotAppsPrefsHandler>(pref_service_);\n  customize_pane_prefs_handler_ =\n      std::make_unique<CustomizePanePrefsHandler>(pref_service_);\n\n  // Create PrefsHandler for each sidebar mode.\n  for (auto mode : GetAllSidebarMode()) {\n    user_generated_pref_handler_[mode] =\n        std::make_unique<UserGeneratedHubAppsPrefsHandler>(\n            hub_model_, pref_service_, delegate, mode);\n\n    hub_apps_visibility_prefs_handler_[mode] =\n        std::make_unique<HubAppsVisibilityPrefsHandler>(pref_service_, mode);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes preference handlers for various hub and sidebar modes."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync_sessions\\session_store.cc:192-225","function":"SessionStore::WriteBatch::DeleteForeignEntityAndUpdateTracker","codesnippet":"{\n  std::string session_tag;\n  int tab_node_id;\n  bool success = DecodeStorageKey(storage_key, &session_tag, &tab_node_id);\n  DCHECK(success);\n  DCHECK_NE(session_tag, session_tracker_->GetLocalSessionTag());\n\n  std::vector<std::string> deleted_storage_keys;\n  deleted_storage_keys.push_back(storage_key);\n\n  if (tab_node_id == TabNodePool::kInvalidTabNodeID) {\n    // Removal of a foreign header entity cascades the deletion of all tabs in\n    // the same session too.\n    for (int cascading_tab_node_id :\n         session_tracker_->LookupTabNodeIds(session_tag)) {\n      std::string tab_storage_key =\n          GetTabStorageKey(session_tag, cascading_tab_node_id);\n      // Note that DeleteForeignSession() below takes care of removing all tabs\n      // from the tracker, so no DeleteForeignTab() needed.\n      batch_->DeleteData(tab_storage_key);\n      deleted_storage_keys.push_back(std::move(tab_storage_key));\n    }\n\n    // Delete session itself.\n    session_tracker_->DeleteForeignSession(session_tag);\n  } else {\n    // Removal of a foreign tab entity.\n    session_tracker_->DeleteForeignTab(session_tag, tab_node_id);\n  }\n\n  batch_->DeleteData(storage_key);\n  return deleted_storage_keys;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Deletes a foreign session or tab and returns the list of deleted storage keys."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\supervised_user\\supervised_user_service_factory.cc:70-95","function":"SupervisedUserServiceFactory::BuildInstanceFor","codesnippet":"{\n  std::unique_ptr<SupervisedUserServicePlatformDelegate> platform_delegate =\n      std::make_unique<SupervisedUserServicePlatformDelegate>(*profile);\n  signin::IdentityManager* identity_manager =\n      IdentityManagerFactory::GetForProfile(profile);\n  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =\n      profile->GetDefaultStoragePartition()\n          ->GetURLLoaderFactoryForBrowserProcess();\n  return std::make_unique<supervised_user::SupervisedUserService>(\n      identity_manager, url_loader_factory, *profile->GetPrefs(),\n      *SupervisedUserSettingsServiceFactory::GetInstance()->GetForKey(\n          profile->GetProfileKey()),\n      SyncServiceFactory::GetInstance()->GetForProfile(profile),\n      std::make_unique<supervised_user::SupervisedUserURLFilter>(\n          *profile->GetPrefs(), std::make_unique<FilterDelegateImpl>(),\n#if !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n          std::make_unique<\n              supervised_user::KidsChromeManagementURLCheckerClient>(\n              identity_manager, url_loader_factory, *profile->GetPrefs(),\n              platform_delegate->GetCountryCode(),\n              platform_delegate->GetChannel())),\n#else\n          nullptr),\n#endif  // !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      std::move(platform_delegate));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a supervised user service instance for a given profile."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\icon_transcoder\\svg_icon_transcoder.cc:87-114","function":"SvgIconTranscoder::Transcode","codesnippet":"{\n  if (!PrepareWebContents()) {\n    LOG(ERROR) << \"Can't transcode svg. WebContents not ready.\";\n    std::move(callback).Run(std::string());\n    return;\n  }\n\n  auto pos = svg_data.find(\"<svg\");\n  if (pos == std::string::npos) {\n    LOG(ERROR) << \"Invalid data. Couldn't find <svg.\";\n    std::move(callback).Run(std::string());\n    return;\n  }\n  // Form a data: uri from the svg_data starting at the <svg. Excess ASCII\n  // whitespace is also removed.\n  std::string base64_svg = base::Base64Encode(\n      base::CollapseWhitespaceASCII(svg_data.substr(pos), false));\n\n  GURL data_url(kSvgDataUrlPrefix + base64_svg);\n\n  web_contents_->DownloadImage(\n      data_url, /*is_favicon=*/false, preferred_size, /*max_bitmap_size=*/0,\n      /*bypass_cache=*/true,\n      base::BindOnce(&SvgIconTranscoder::OnDownloadImage, GetWeakPtr(),\n                     std::move(png_path), std::move(callback)));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Transcodes SVG data to a downloadable image URL."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_hub_apps\\standalone\\desktop_dock_helper_edgebar_win.cc:220-319","function":"DesktopDockHelperEdgebarWin::OnWndProc","codesnippet":"{\n  // Return early if we don't have an AppBar.\n  if (!app_bar_message_helper_) {\n    return CallWindowProc(previous_wnd_proc_, hwnd, message, wparam, lparam);\n  }\n  // Handles the AppBar messages.\n  if (message == app_bar_message_helper_->callback_msg_id()) {\n    switch (wparam) {\n      case ABN_POSCHANGED: {\n        UpdateSidebarAndAppPaneBounds();\n\n        // don't need to handle this message via |previous_wnd_proc_|.\n        return 0;\n      }\n      case ABN_FULLSCREENAPP: {\n        bool always_on_top = !lparam;\n        UpdateZOrder(hwnd, always_on_top);\n        UpdateAppPaneZOrder(always_on_top);\n\n        // don't need to handle this message via |previous_wnd_proc_|.\n        return 0;\n      }\n    }\n  } else if (message == app_bar_message_helper_->taskbar_created_msg_id()) {\n    // re-register appbar when the taskbar is re-created after explorer.exe\n    // crashes.\n    app_bar_message_helper_->ReRegisterAppBar();\n    ForceUpdateCurrentAppBarBounds();\n  } else {\n    switch (message) {\n      case WM_MOUSEMOVE: {\n        if (is_edge_bar_hidden_ && !is_in_animation_) {\n          current_appbar_width_ = kMinAutoHideWidth;\n          // Debounce logic to avoid flickering\n          SetTimer(hwnd, TIMER_UNHIDE, kDebounceForUnhideMS, nullptr);\n        }\n        break;\n      }\n      case WM_MOUSELEAVE: {\n        KillTimer(hwnd, TIMER_ANIMATE_SHOW);\n        // Debounce logic to avoid flickering. Note that we should not check\n        // if is_edge_bar_hidden_ here, because the mouse could leave the bar\n        // before the showing animation is finished.\n        SetTimer(hwnd, TIMER_HIDE, kDebounceForHideMS, nullptr);\n        break;\n      }\n      case WM_TIMER: {\n        HandleTimerMessages(wparam, hwnd);\n        break;\n      }\n      case WM_ACTIVATE: {\n        // Follows guidance from\n        // https://learn.microsoft.com/en-us/windows/win32/shell/abm-activate\n        app_bar_message_helper_->SendAbmActivate();\n        break;\n      }\n      case WM_WINDOWPOSCHANGING: {\n        LPWINDOWPOS window_pos = reinterpret_cast<LPWINDOWPOS>(lparam);\n        if (!(window_pos->flags & SWP_NOMOVE)) {\n          // When app bar is registered, Windows tries to move all apps out of\n          // the app bar region even if this is the app bar. We want to keep the\n          // original bounds.\n          gfx::Rect bounds(window_pos->x, window_pos->y, window_pos->cx,\n                           window_pos->cy);\n          if (bounds != scaled_sidepane_bounds_) {\n            window_pos->x = scaled_sidepane_bounds_.x();\n            window_pos->y = scaled_sidepane_bounds_.y();\n            window_pos->cx = scaled_sidepane_bounds_.width();\n            window_pos->cy = scaled_sidepane_bounds_.height();\n          }\n        }\n        return 1;\n      }\n      case WM_WINDOWPOSCHANGED: {\n        // Follows guidance from\n        // https://learn.microsoft.com/en-us/windows/win32/shell/abm-windowposchanged\n        app_bar_message_helper_->SendAbmWindowPosChanged();\n        RedrawWindow(\n            hwnd, nullptr, nullptr,\n            RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_FRAME);\n        break;\n      }\n      case WM_SHOWWINDOW:\n      case WM_CREATE:\n        RedrawWindow(\n            hwnd, nullptr, nullptr,\n            RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_FRAME);\n        break;\n      case WM_SYSCOMMAND:\n        if (wparam == SC_CLOSE) {\n          is_system_command_closing_ = true;\n        }\n        break;\n    }\n  }\n\n  return CallWindowProc(previous_wnd_proc_, hwnd, message, wparam, lparam);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles various window messages for an AppBar, including updating bounds, managing visibility, and re-registering after taskbar recreation."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\net\\secure_dns_manager.cc:416-448","function":"SecureDnsManager::UpdateChromeDoHConfig","codesnippet":"{\n  bool mode_changed = new_mode != cached_chrome_mode_;\n  bool template_uris_changed =\n      new_template_uris != cached_chrome_template_uris_;\n  if (!mode_changed && !template_uris_changed && !force_update) {\n    // The secure DNS configuration has not changed\n    return;\n  }\n\n  // Update cached DoH configs.\n  cached_chrome_mode_ = new_mode;\n  cached_chrome_template_uris_ = new_template_uris;\n\n  // Broadcast DoH config updates for Chrome.\n  for (auto& observer : observers_) {\n    if (template_uris_changed || force_update) {\n      observer.OnTemplateUrisChanged(cached_chrome_template_uris_);\n    }\n    if (mode_changed || force_update) {\n      observer.OnModeChanged(cached_chrome_mode_);\n    }\n  }\n\n  // Set the DoH URI template pref which is synced with Lacros and the\n  // NetworkService.\n  // TODO(acostinas, b/331903009): Storing the effective DoH providers in a\n  // local_state pref on Chrome OS has downsides. Replace this pref with an\n  // in-memory mechanism to sync effective DoH prefs.\n  local_state_->SetString(::prefs::kDnsOverHttpsEffectiveTemplatesChromeOS,\n                          cached_chrome_template_uris_);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates and broadcasts changes to the secure DNS configuration."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_dual_engine\\dual_engine_neutral_site_recorder_win.cc:49-99","function":"NeutralSiteRecorder::OnContinueNavigationInEdge","codesnippet":"{\n  const GURL case_insensitive_url = GURL(base::ToLowerASCII(url.spec()));\n  // Reset the redirected URL if it's different from the last one IE sent.\n  // Otherwise, increment the loop count indicating that we have seen this\n  // redirected URL before.\n  if (redirected_url_.is_empty() ||\n      redirected_url_.host_piece() != case_insensitive_url.host_piece()) {\n    redirected_url_ = case_insensitive_url;\n    loop_count_ = 1;\n    VLOG(kVlogDualEngineLevel)\n        << \"NeutralSiteRecorder - Detected redirection to \" << redirected_url_;\n  } else {\n    loop_count_++;\n    VLOG(kVlogDualEngineLevel)\n        << \"NeutralSiteRecorder - Loop detected for \" << redirected_url_\n        << \". Count = \" << loop_count_;\n  }\n\n  // If the loop exceeds the threshold, we are most definitely in a loop. Log\n  // the redirect chain and that this redirected URL should probably be\n  // configured as NEUTRAL.\n  if (loop_count_ >= kNavigationRecorderLoopCountThreshold && !loop_detected_) {\n    loop_detected_ = true;\n    DualEngineService* dual_engine_service =\n        dual_engine_tab_helper_->GetDualEngineService();\n    if (dual_engine_service &&\n        dual_engine_service->ShouldSendSuggestion(\n            CloudReportingSource::kNeutralSiteDetector)) {\n      dual_engine_service->SendNeutralSiteSuggestion(url);\n    }\n\n    VLOG(kVlogDualEngineLevel)\n        << \"NeutralSiteRecorder - When navigating to \" << navigation_url_\n        << \" in Internet Explorer, \" << url.host_piece()\n        << \" might be used for authentication.\";\n\n    VLOG(kVlogDualEngineLevel)\n        << \"NeutralSiteRecorder - The redirect chain leading to the above \"\n           \"site: \";\n    VLOG(kVlogDualEngineLevel)\n        << \"                       - \" << navigation_url_;\n    for (const auto& redirection_url : redirection_chain_urls_) {\n      VLOG(kVlogDualEngineLevel)\n          << \"                       - \" << redirection_url;\n    }\n    VLOG(kVlogDualEngineLevel)\n        << \"                       - \" << redirected_url_;\n\n    VLOG(kVlogDualEngineLevel)\n        << \"Consider configuring \\\"\" << url.host_piece() << \"\\\" as NEUTRAL.\";\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Detects URL redirection loops and logs potential neutral site suggestions."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\subresource_filter\\content\\renderer\\subresource_filter_agent.cc:312-338","function":"SubresourceFilterAgent::DidCreateNewDocument","codesnippet":"{\n  // TODO(csharrison): Use WebURL and WebSecurityOrigin for efficiency here,\n  // which requires changes to the unit tests.\n  const GURL& url = GetDocumentURL();\n\n  // A new browser-side host is created for each new page (i.e. new document in\n  // a subresource filter root frame) so we have to reset the remote so we\n  // re-bind on the next message.\n  if (!IsSubresourceFilterChild()) {\n    subresource_filter_host_.reset();\n  }\n\n  const mojom::ActivationState activation_state =\n      ShouldInheritActivation(url) ? GetInheritedActivationStateForNewDocument()\n                                   : activation_state_for_next_document_;\n\n  ResetInfoForNextDocument();\n\n  // Do not pollute the histograms with uninteresting root frame documents.\n  const bool should_record_histograms = IsSubresourceFilterChild() ||\n                                        url.SchemeIsHTTPOrHTTPS() ||\n                                        url.SchemeIsFile();\n  if (should_record_histograms) {\n    RecordHistogramsOnFilterCreation(activation_state);\n  }\n\n  ConstructFilter(activation_state, url);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and configures a subresource filter for a new document."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\support_tool\\signin_data_collector.cc:79-110","function":"SigninDataCollector::CollectDataAndDetectPII","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  // `profile_` can't be null because `SigninDataCollector` will be created\n  // after profile is created. Check `SupportToolHandler` and\n  // chrome/browser/support_tool/support_tool_util.h for more details.\n  CHECK(profile_);\n\n  if (profile_->IsIncognitoProfile()) {\n    SupportToolError error = {\n        SupportToolErrorCode::kDataCollectorError,\n        \"SigninDataCollector can't work without profile or in incognito mode.\"};\n    std::move(on_data_collected_callback).Run(error);\n    return;\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  // See AboutSigninInternals::SigninStatus::ToValue.\n  base::Value::Dict status = about_signin_internals->GetSigninStatus();\n  base::JSONWriter::WriteWithOptions(\n      status, base::JSONWriter::OPTIONS_PRETTY_PRINT, &signin_status_);\n\n  task_runner_for_redaction_tool->PostTaskAndReplyWithResult(\n      FROM_HERE,\n      base::BindOnce(&DetectPII, signin_status_, redaction_tool_container),\n      base::BindOnce(&SigninDataCollector::OnPIIDetected,\n                     weak_ptr_factory_.GetWeakPtr(),\n                     std::move(on_data_collected_callback)));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Collects and processes sign-in status data, handling errors for incognito profiles."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\user_education\\common\\feature_promo\\impl\\feature_promo_controller_25.cc:312-342","function":"FeaturePromoController25::GetNextPromoData","codesnippet":"{\n  PromoData result;\n\n  if (current_promo() && current_promo()->is_demo()) {\n    // If a demo promo is showing, all other promos fail immediately.\n    // New demo promos will also clear out the current promo and fail all promos\n    // in the queue.\n    private_->queues.FailAll(kDemoOverrideFailure);\n  } else if (IsDemoPending()) {\n    // Demo takes precedence over other promos.\n    result.for_demo = true;\n    if (const auto* const pending =\n            private_->demo_queue.UpdateAndIdentifyNextEligiblePromo()) {\n      result.eligible_promo =\n          private_->demo_queue.UnqueueEligiblePromo(*pending);\n      private_->queues.FailAll(kDemoOverrideFailure);\n    }\n  } else if (const auto pending =\n                 private_->queues.UpdateAndIdentifyNextEligiblePromo()) {\n    // If there's a pending promo determine if it can show right now.\n    const bool is_high_priority =\n        pending->second == FeaturePromoPriorityProvider::PromoPriority::kHigh;\n    if (private_->messaging_coordinator.CanShowPromo(is_high_priority)) {\n      result.eligible_promo = private_->queues.UnqueueEligiblePromo(*pending);\n    } else {\n      result.pending_priority = pending->second;\n    }\n  }\n\n  return result;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the next eligible promotional data to display."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\web_app_database.cc:227-267","function":"WebAppDatabase::MigrateShortcutAppsToDiyApps","codesnippet":"{\n  // Migrating from version 1 to version 2.\n  CHECK_LT(state.metadata.version(), 2);\n  int shortcut_to_diy_apps = 0;\n  for (auto& [app_id, app_proto] : state.apps) {\n    bool is_shortcut =\n        !app_proto.has_scope() || app_proto.scope().empty() ||\n        (app_proto.has_latest_install_source() &&\n         app_proto.latest_install_source() ==\n             static_cast<uint32_t>(\n                 webapps::WebappInstallSource::MENU_CREATE_SHORTCUT));\n    if (!is_shortcut) {\n      continue;\n    }\n    changed_apps.insert(app_id);\n    app_proto.set_is_diy_app(true);\n    app_proto.set_was_shortcut_app(true);\n    shortcut_to_diy_apps++;\n    if (app_proto.has_scope() && !app_proto.scope().empty() &&\n        GURL(app_proto.scope()).is_valid()) {\n      continue;\n    }\n    // Populate the scope if it was empty or invalid.\n    if (!app_proto.has_sync_data() || !app_proto.sync_data().has_start_url()) {\n      DLOG(ERROR) << \"Missing sync data or start_url for shortcut app \"\n                  << app_id;\n      continue;\n    }\n    GURL start_url(app_proto.sync_data().start_url());\n    if (!start_url.is_valid()) {\n      // Cannot recover scope, mark for potential cleanup later if needed.\n      DLOG(ERROR) << \"Invalid start_url for shortcut app \" << app_id << \":\"\n                  << start_url.possibly_invalid_spec();\n      continue;\n    }\n    app_proto.set_scope(start_url.GetWithoutFilename().spec());\n  }\n  base::UmaHistogramCounts1000(\"WebApp.Migrations.ShortcutAppsToDiy2\",\n                               shortcut_to_diy_apps);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Converts shortcut apps to DIY apps and updates their scope if necessary."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\input_method\\indexed_suggestion_candidate_button.cc:79-117","function":"IndexedSuggestionCandidateButton::BuildCandidate","codesnippet":"{\n  is_legacy_candidate_ = false;\n\n  // Displaying the candidate text (i.e. the \"A\" in the diagram below).\n  //   +---+\n  //   | A | <-- label being created\n  //   |   |\n  //   | 1 |\n  //   +---+\n\n  // Wrapper uses views::Label since it doesn't override the hover state of the\n  // button.\n  auto* candidate_wrapper = AddChildView(std::make_unique<views::Label>());\n  views::FlexLayout* candidate_wrapper_layout =\n      candidate_wrapper->SetLayoutManager(\n          std::make_unique<views::FlexLayout>());\n  candidate_wrapper_layout->SetCrossAxisAlignment(\n      views::LayoutAlignment::kCenter);\n  candidate_wrapper_layout->SetMainAxisAlignment(\n      views::LayoutAlignment::kCenter);\n  candidate_wrapper->SetProperty(views::kBoxLayoutFlexKey,\n                                 views::BoxLayoutFlexSpecification());\n  candidate_wrapper->SetPreferredSize(\n      gfx::Size(kCandidateSquareSide, kCandidateSquareSide));\n  candidate_wrapper->AddChildView(\n      std::make_unique<views::Label>(candidate_text, kCandidateTextFont));\n\n  // Displaying the index (i.e. the \"1\" in the diagram below).\n  //   +---+\n  //   | A |\n  //   |   |\n  //   | 1 | <-- label being created\n  //   +---+\n  auto* candidate_text_label =\n      AddChildView(std::make_unique<views::Label>(index_text, kIndexFont));\n  candidate_text_label->SetEnabledColor(\n      ResolveSemanticColor(cros_styles::ColorName::kTextColorSecondary));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and displays a labeled candidate box with text and index."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_trust\\tracking_protection\\classifier\\list_parser.cc:73-111","function":"ListParser::ParseBlockLists","codesnippet":"{\n  // We'll go through all of our lists and read them into memory mapped to the\n  // type of TrackingSource they are. There may be multiple configurations that\n  // include the same categories so each TrackingSource is a unique flag. At\n  // lookup time we can compare the TrackingSource to the group of categories\n  // the current lookup cares about and make a decision to block or not. This\n  // lets us keep only 1 copy of all the trackers in memory while efficiently\n  // providing various lookup combinations.\n\n  // Iterate over our max-category list set, strict, and process each list one\n  // by one.\n  for (const base::FilePath::CharType* filename\n    : edge_trust::kStrictListSet) {\n    const TrackingSource tracking_source =\n        GetTrackingSource(base::FilePath().Append(filename));\n    const ListStorageMethod list_storage_method =\n        [&block_list, tracking_source](const std::string& list_line) {\n          block_list->emplace(list_line, tracking_source);\n        };\n\n    // Import our file from both of our list sets. We should have two copies to\n    // load.\n    const base::FilePath list_file_path =\n        list_source_directory.Append(filename);\n    const TrackingError import_result =\n        ParseList(list_file_path, list_storage_method);\n\n    // We want to fire our error telemetry even if no error exists so we can\n    // track our success/failure rate.\n    helpers::FireErrorTelemetryEvent(import_result);\n    if (import_result != TrackingError::NONE) {\n      block_list->clear();\n      DVLOG(0) << \"Tracking list parse error. '\" << list_file_path\n               << \"' didn't parse, rejecting block rule sets.\";\n      break;\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Imports tracking lists into memory and logs parsing errors."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\segmentation_platform\\internal\\database\\signal_storage_config.cc:142-207","function":"SignalStorageConfig::MeetsSignalCollectionRequirement","codesnippet":"{\n  base::TimeDelta min_signal_collection_length =\n      model_metadata.min_signal_collection_length() *\n      metadata_utils::GetTimeUnit(model_metadata);\n\n  // Loop through all the signals specified in the model, and check if they have\n  // been collected long enough.\n  bool meets_requirement = true;\n  auto feature_visit = base::BindRepeating(\n      [](SignalStorageConfig* config,\n         base::TimeDelta min_signal_collection_length, bool* meets_requirement,\n         const proto::UMAFeature& feature) {\n        // Skip the signals that has bucket_count set to 0. These ones are\n        // only for collection purposes and hence don't get used in model\n        // evaluation.\n        if (feature.bucket_count() == 0) {\n          return;\n        }\n\n        if (metadata_utils::ValidateMetadataUmaFeature(feature) !=\n            metadata_utils::ValidationResult::kValidationSuccess) {\n          return;\n        }\n\n        if (!config->MeetsSignalCollectionRequirementForSignal(\n                min_signal_collection_length, feature.name_hash(),\n                CleanupItem::kNonUkmEventHash, feature.type())) {\n          *meets_requirement = false;\n          return;\n        };\n      },\n      base::Unretained(this), min_signal_collection_length,\n      base::Unretained(&meets_requirement));\n  metadata_utils::VisitAllUmaFeatures(model_metadata, include_outputs,\n                                      std::move(feature_visit));\n  if (!meets_requirement) {\n    return false;\n  }\n\n  // Loop through sql features.\n  for (auto const& feature : model_metadata.input_features()) {\n    if (!feature.has_sql_feature())\n      continue;\n\n    if (metadata_utils::ValidateMetadataSqlFeature(feature.sql_feature()) !=\n        metadata_utils::ValidationResult::kValidationSuccess) {\n      continue;\n    }\n\n    const proto::SignalFilterConfig& sql_config =\n        feature.sql_feature().signal_filter();\n\n    for (auto const& event : sql_config.ukm_events()) {\n      for (auto const& metric_hash : event.metric_hash_filter()) {\n        if (!MeetsSignalCollectionRequirementForSignal(\n                min_signal_collection_length, metric_hash, event.event_hash(),\n                proto::SignalType::UKM_EVENT)) {\n          return false;\n        };\n      }\n    }\n  }\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks if all required signals meet the minimum collection length criteria."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_hub_apps\\app_icon_auto_show\\tab_content_observer_for_hub_app_helper.cc:97-119","function":"TabContentObserverForHubAppHelper::OnShorelineTowerVisibilityChanged","codesnippet":"{\n  // just handle the visible case. do not remove the icon when the tower is not\n  // visible.\n  if (visible) {\n    auto visibility = web_contents()->GetVisibility();\n    if (visibility == content::Visibility::HIDDEN) {\n      if (!valid_pending_url_.is_valid() && has_active_media_session_) {\n        MayShowAppIconForTabs(web_contents()->GetLastCommittedURL());\n      } else if ((valid_pending_url_.is_valid() && has_active_media_session_ &&\n                  meta_data_.normalized_url.is_valid())) {\n        base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\n            FROM_HERE,\n            base::BindOnce(\n                &TabContentObserverForHubAppHelper::\n                    HandleThirdPartyHubAppMetaData,\n                weak_factory_.GetWeakPtr(), valid_pending_url_,\n                ThirdPartyHubAppMetaData::FromValue(meta_data_.ToValue())\n                    .value()),\n            base::Milliseconds(100));\n      }\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles app icon visibility and metadata processing for web content."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\profile\\page_data_provider_workspaces.cc:78-102","function":"WorkspacesPageDataProvider::GetWorkspaceChoiceOptionsAndSelectedValue","codesnippet":"{\n  select_value = edge::workspaces::kLastWindowDefaultWorkspace.data();\n  options.push_back(\n      {std::string(edge::workspaces::kLastWindowDefaultWorkspace.data()),\n       l10n_util::GetStringUTF8(\n           IDS_EDGE_SETTINGS_CUSTOM_WORKSPACE_FOR_LINK_OPEN_WORKSPACE_CHOICE_DEFAULT)});\n\n  auto* workspace_manager =\n      edge::workspaces::EdgeWorkspaceManagerFactory::GetForProfile(profile_);\n  if (!workspace_manager) {\n    return;\n  }\n  const std::optional<edge::workspaces::WorkspaceId> default_ws_id =\n      workspace_manager->GetDefaultWorkspaceId();\n  const std::vector<edge::workspaces::WorkspaceSession> workspaces =\n      workspace_manager->GetWorkspaces(true /*include_active*/);\n  for (const auto& workspace : workspaces) {\n    options.push_back(\n        {workspace.id().token(), base::UTF16ToUTF8(workspace.name())});\n    if (default_ws_id && workspace.id() == default_ws_id.value()) {\n      select_value = workspace.id().token();\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Populates a list of workspace options and selects the default workspace."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\safe_browsing\\edge_password_protection_service_impl.cc:225-248","function":"EdgePasswordProtectionServiceImpl::ShowInterstitial","codesnippet":"{\n  DCHECK(password_type.account_type() ==\n             ReusedPasswordAccountType::NON_GAIA_ENTERPRISE);\n  // Exit fullscreen if this |web_contents| is showing in fullscreen mode.\n  if (web_contents->IsFullscreen())\n    web_contents->ExitFullscreen(/*will_cause_resize=*/true);\n\n  GURL trigger_url = web_contents->GetLastCommittedURL();\n  content::OpenURLParams params(\n      GURL(chrome::kChromeUIResetPasswordURL), content::Referrer(),\n      WindowOpenDisposition::NEW_FOREGROUND_TAB, ui::PAGE_TRANSITION_LINK,\n      /*is_renderer_initiated=*/false);\n  std::string post_data = base::NumberToString(\n      static_cast<std::underlying_type_t<PasswordType>>(\n        ConvertReusedPasswordAccountTypeToPasswordType(password_type)));\n  params.post_data = network::ResourceRequestBody::CreateFromCopyOfBytes(\n      base::as_byte_span(post_data));\n  web_contents->OpenURL(params, /*navigation_handle_callback=*/{});\n\n  LogWarningAction(\n      WarningUIType::INTERSTITIAL, WarningAction::SHOWN,\n      password_type);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Opens a reset password URL in a new tab and logs a warning action."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\dbus\\ash_dbus_helper.cc:132-225","function":"InitializeDBus","codesnippet":"{\n  using chromeos::InitializeDBusClient;\n\n  OverrideStubPathsIfNeeded();\n\n  SystemSaltGetter::Initialize();\n\n  // Initialize DBusThreadManager for the browser.\n  DBusThreadManager::Initialize();\n\n  // Initialize Chrome dbus clients.\n  dbus::Bus* bus = DBusThreadManager::Get()->GetSystemBus();\n\n  shill_clients::Initialize(bus);\n\n  // NOTE: base::Feature is not initialized yet, so any non MultiProcessMash\n  // dbus client initialization for Ash should be done in Shell::Init.\n  InitializeDBusClient<AnomalyDetectorClient>(bus);\n  InitializeDBusClient<ArcAppfuseProviderClient>(bus);\n  InitializeDBusClient<ArcCameraClient>(bus);\n  InitializeDBusClient<ArcKeymasterClient>(bus);\n  InitializeDBusClient<ArcKeyMintClient>(bus);\n  InitializeDBusClient<ArcMidisClient>(bus);\n  InitializeDBusClient<ArcObbMounterClient>(bus);\n  InitializeDBusClient<ArcVmDataMigratorClient>(bus);\n  InitializeDBusClient<AttestationClient>(bus);\n  InitializeDBusClient<BiodClient>(bus);  // For device::Fingerprint.\n  InitializeDBusClient<CdmFactoryDaemonClient>(bus);\n  InitializeDBusClient<CecServiceClient>(bus);\n  InitializeDBusClient<ChapsClient>(bus);\n  InitializeDBusClient<ChunneldClient>(bus);\n  InitializeDBusClient<CiceroneClient>(bus);\n  // ConciergeClient depends on CiceroneClient.\n  InitializeDBusClient<ConciergeClient>(bus);\n  InitializeDBusClient<CrasAudioClient>(bus);\n  InitializeDBusClient<CrosDisksClient>(bus);\n  InitializeDBusClient<CryptohomeMiscClient>(bus);\n  InitializeDBusClient<CryptohomePkcs11Client>(bus);\n  InitializeDBusClient<CupsProxyClient>(bus);\n  InitializeDBusClient<DebugDaemonClient>(bus);\n  InitializeDBusClient<DlcserviceClient>(bus);\n  InitializeDBusClient<chromeos::DlpClient>(bus);\n  InitializeDBusClient<EasyUnlockClient>(bus);\n  InitializeDBusClient<FederatedClient>(bus);\n  InitializeDBusClient<GnubbyClient>(bus);\n  hermes_clients::Initialize(bus);\n  InitializeDBusClient<ImageBurnerClient>(bus);\n  InitializeDBusClient<ImageLoaderClient>(bus);\n  InitializeDBusClient<InstallAttributesClient>(bus);\n  InitializeDBusClient<chromeos::IpPeripheralServiceClient>(bus);\n  InitializeDBusClient<KerberosClient>(bus);\n  InitializeDBusClient<LorgnetteManagerClient>(bus);\n  InitializeDBusClient<chromeos::MachineLearningClient>(bus);\n  InitializeDBusClient<MediaAnalyticsClient>(bus);\n  InitializeDBusClient<OobeConfigurationClient>(bus);\n  InitializeDBusClient<OsInstallClient>(bus);\n  InitializeDBusClient<PatchPanelClient>(bus);\n  InitializeDBusClient<PciguardClient>(bus);\n  InitializeDBusClient<PrintscanmgrClient>(bus);\n  InitializeDBusClient<PrivateComputingClient>(bus);\n  InitializeDBusClient<chromeos::PermissionBrokerClient>(bus);\n  InitializeDBusClient<chromeos::PowerManagerClient>(bus);\n  InitializeDBusClient<ResourcedClient>(bus);\n  InitializeDBusClient<RuntimeProbeClient>(bus);\n  InitializeDBusClient<SeneschalClient>(bus);\n  InitializeDBusClient<SessionManagerClient>(bus);\n  InitializeDBusClient<SmbProviderClient>(bus);\n  InitializeDBusClient<SpacedClient>(bus);\n  InitializeDBusClient<SwapManagementClient>(bus);\n  InitializeDBusClient<SystemClockClient>(bus);\n  InitializeDBusClient<SystemProxyClient>(bus);\n  InitializeDBusClient<chromeos::TpmManagerClient>(bus);\n  InitializeDBusClient<TypecdClient>(bus);\n  InitializeDBusClient<chromeos::U2FClient>(bus);\n  InitializeDBusClient<UpdateEngineClient>(bus);\n  InitializeDBusClient<UserDataAuthClient>(bus);\n  InitializeDBusClient<UpstartClient>(bus);\n  InitializeDBusClient<VirtualFileProviderClient>(bus);\n  InitializeDBusClient<VmPluginDispatcherClient>(bus);\n  InitializeDBusClient<chromeos::RegmonClient>(bus);\n\n  attestation::AttestationFeatures::Initialize();\n  // Initialize the device settings service so that we'll take actions per\n  // signals sent from the session manager. This needs to happen before\n  // g_browser_process initializes BrowserPolicyConnector.\n  DeviceSettingsService::Initialize();\n  InstallAttributes::Initialize();\n\n  // Depends on `DlcserviceClient`.\n  language_packs::LanguagePackManager::Initialise();\n\n  if (g_dbus_helper_observer) {\n    g_dbus_helper_observer->PostInitializeDBus();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes various DBus clients and related services for Chrome OS."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\optimization_guide\\core\\prediction_model_override.cc:136-176","function":"ParseEntry","codesnippet":"{\n  std::vector<std::string> override_parts =\n      base::SplitString(model_override, kModelOverrideSeparator,\n                        base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n  if (override_parts.size() != 2 && override_parts.size() != 3) {\n    // Input is malformed. Should be either\n    // <target>:<path>:<base64_metadata> or <target>:<path>\n    LOG(ERROR) << \"Invalid string format provided to the Model Override\";\n    return std::nullopt;\n  }\n\n  proto::OptimizationTarget target;\n  if (!proto::OptimizationTarget_Parse(override_parts[0], &target)) {\n    // Optimization target is invalid.\n    LOG(ERROR) << \"Invalid optimization target provided to the Model Override\";\n    return std::nullopt;\n  }\n\n  auto path = StringToFilePath(override_parts[1]);\n  if (!path || !path->IsAbsolute()) {\n    LOG(ERROR) << \"Provided model file path must be absolute \"\n                << path.value_or(base::FilePath()).value();\n    return std::nullopt;\n  }\n\n  if (override_parts.size() == 2) {\n    return PredictionModelOverrides::Entry(target, *path, std::nullopt);\n  }\n\n  std::string binary_pb;\n  if (!base::Base64Decode(override_parts[2], &binary_pb)) {\n    LOG(ERROR) << \"Invalid base64 encoding of the Model Override\";\n    return std::nullopt;\n  }\n  proto::Any metadata;\n  if (!metadata.ParseFromString(binary_pb)) {\n    LOG(ERROR) << \"Invalid model metadata provided to the Model Override\";\n    return std::nullopt;\n  }\n  return PredictionModelOverrides::Entry(target, *path, std::move(metadata));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses a model override string and returns a structured entry if valid."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_hub\\hub_app_notifications_controller.cc:112-161","function":"EdgeHubAppNotificationsController::HandleNotification","codesnippet":"{\n  std::optional<NotificationMetadata> metadata =\n      store_->GetNotificationMetadata(notification_id);\n  if (!metadata.has_value()) {\n    return;\n  }\n\n  // If the app wanting to show a notification already has an open side\n  // pane, we don't show any new notification. But we might still want to\n  // clear existing ones.\n  const bool is_pane_open =\n      HubManager::IsHubContentVisible(browser_, hub_content_id_) ||\n      HubManager::IsHubContentVisibleForCommand(browser_, hub_content_id_);\n  const bool time_stamp_not_set = metadata->shown_timestamp.is_null();\n  const bool is_any_pane_showing = HubManager::IsAnyHubPaneShowing(browser_);\n\n  bool payload_handled = false;\n  if (payload) {\n    switch (payload->payload_type()) {\n      case PayloadType::kMessage: {\n        HandleNotificationWithMessage(\n            is_pane_open, time_stamp_not_set, is_any_pane_showing,\n            GetNotificationAnchor(payload), notification_id, metadata.value(),\n            payload->force_show(),\n            payload->is_auto_open_fallback_notification());\n        payload_handled = true;\n        break;\n      }\n      case PayloadType::kBadge: {\n        HandleNotificationWithBadge(is_pane_open, payload);\n        payload_handled = true;\n        break;\n      }\n      case PayloadType::kCleanUp: {\n        HandleEmptyNotification(GetHubAppButton());\n        payload_handled = true;\n        break;\n      }\n      default: {\n        // unhandled payload type\n        NOTREACHED();\n      }\n    }\n  }\n\n  if (!payload_handled) {\n    HandleEmptyNotification(GetHubAppButton());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles notification display and cleanup based on metadata and payload type."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\signin\\bound_session_credentials\\session_binding_helper.cc:41-67","function":"CreateAssertionToken","codesnippet":"{\n  using enum SessionBindingHelper::Error;\n  if (!signature.has_value()) {\n    return base::unexpected(kSignAssertionFailure);\n  }\n\n  crypto::SignatureVerifier verifier;\n  if (!verifier.VerifyInit(algorithm, *signature, public_key)) {\n    return base::unexpected(kVerifySignatureFailure);\n  }\n  verifier.VerifyUpdate(base::as_byte_span(header_and_payload));\n  if (!verifier.VerifyFinal()) {\n    return base::unexpected(kVerifySignatureFailure);\n  }\n\n  std::optional<std::string> assertion_token =\n      signin::AppendSignatureToHeaderAndPayload(header_and_payload, algorithm,\n                                                *signature);\n  if (!assertion_token) {\n    return base::unexpected(kAppendSignatureFailure);\n  }\n\n  return *assertion_token;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Verifies a digital signature and appends it to a token."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\help\\help_utils_chromeos.cc:19-50","function":"IsUpdateOverCellularAllowed","codesnippet":"{\n  // If this is a Cellular First device or the user actively checks for update,\n  // the default is to allow updates over cellular.\n  bool default_update_over_cellular_allowed =\n      interactive ? true : ash::switches::IsCellularFirstDevice();\n\n  // Device Policy overrides the defaults.\n  ash::CrosSettings* settings = ash::CrosSettings::Get();\n  if (!settings) {\n    return default_update_over_cellular_allowed;\n  }\n\n  const base::Value* types_value =\n      settings->GetPref(ash::kAllowedConnectionTypesForUpdate);\n  if (!types_value) {\n    return default_update_over_cellular_allowed;\n  }\n  CHECK(types_value->is_list());\n  const auto& list = types_value->GetList();\n  for (size_t i = 0; i < list.size(); ++i) {\n    if (!list[i].is_int()) {\n      LOG(WARNING) << \"Can't parse connection type #\" << i;\n      continue;\n    }\n\n    if (list[i].GetInt() == 4) {\n      return true;\n    }\n  }\n  // Device policy does not allow updates over cellular, as cellular is not\n  // included in allowed connection types for updates.\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if updates are allowed over cellular connections based on device policy and user interaction."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\apps\\platform_apps\\platform_app_navigation_redirector.cc:31-81","function":"LaunchAppWithUrl","codesnippet":"{\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(navigation_handle->IsInMainFrame());\n  CHECK(!should_run_async);\n\n  // Redirect top-level navigations only. This excludes iframes and webviews\n  // in particular.\n  if (navigation_handle->GetWebContents()->IsInnerWebContentsForGuest()) {\n    DVLOG(1) << \"Cancel redirection: source is a guest inner WebContents\";\n    std::move(result_callback).Run(false);\n    return;\n  }\n\n  if (navigation_handle->IsInPrerenderedMainFrame()) {\n    // If it's from prerendering, don't launch the app but abort the navigation.\n    std::move(result_callback).Run(true);\n    return;\n  }\n\n  // If no-state prefetching, don't launch the app but abort the navigation.\n  prerender::NoStatePrefetchContents* no_state_prefetch_contents =\n      prerender::ChromeNoStatePrefetchContentsDelegate::FromWebContents(\n          navigation_handle->GetWebContents());\n  if (no_state_prefetch_contents) {\n    no_state_prefetch_contents->Destroy(\n        prerender::FINAL_STATUS_NAVIGATION_INTERCEPTED);\n    std::move(result_callback).Run(true);\n    return;\n  }\n\n  // These are guaranteed by MaybeCreateThrottleFor below.\n  DCHECK(UrlHandlers::CanPlatformAppHandleUrl(app.get(),\n                                              navigation_handle->GetURL()));\n  DCHECK(!navigation_handle->IsPost());\n\n  Profile* profile = Profile::FromBrowserContext(\n      navigation_handle->GetWebContents()->GetBrowserContext());\n\n  DVLOG(1) << \"Launching app handler with URL: \" << navigation_handle->GetURL()\n           << \" -> \" << app->name() << \"(\" << app->id() << \"):\" << handler_id;\n  apps::LaunchPlatformAppWithUrl(profile, app.get(), handler_id,\n                                 navigation_handle->GetURL(),\n                                 navigation_handle->GetReferrer().url);\n\n  std::move(result_callback).Run(true);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles URL redirection and launches a platform app if applicable."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\services\\sharing\\nearby\\nearby_connections_conversions.cc:31-73","function":"StatusToMojom","codesnippet":"{\n  switch (status) {\n    case Status::Value::kSuccess:\n      return mojom::Status::kSuccess;\n    case Status::Value::kError:\n      return mojom::Status::kError;\n    case Status::Value::kOutOfOrderApiCall:\n      return mojom::Status::kOutOfOrderApiCall;\n    case Status::Value::kAlreadyHaveActiveStrategy:\n      return mojom::Status::kAlreadyHaveActiveStrategy;\n    case Status::Value::kAlreadyAdvertising:\n      return mojom::Status::kAlreadyAdvertising;\n    case Status::Value::kAlreadyDiscovering:\n      return mojom::Status::kAlreadyDiscovering;\n    case Status::Value::kEndpointIoError:\n      return mojom::Status::kEndpointIOError;\n    case Status::Value::kEndpointUnknown:\n      return mojom::Status::kEndpointUnknown;\n    case Status::Value::kConnectionRejected:\n      return mojom::Status::kConnectionRejected;\n    case Status::Value::kAlreadyConnectedToEndpoint:\n      return mojom::Status::kAlreadyConnectedToEndpoint;\n    case Status::Value::kNotConnectedToEndpoint:\n      return mojom::Status::kNotConnectedToEndpoint;\n    case Status::Value::kBluetoothError:\n      return mojom::Status::kBluetoothError;\n    case Status::Value::kBleError:\n      return mojom::Status::kBleError;\n    case Status::Value::kWifiLanError:\n      return mojom::Status::kWifiLanError;\n    case Status::Value::kPayloadUnknown:\n      return mojom::Status::kPayloadUnknown;\n    case Status::Value::kAlreadyListening:\n      return mojom::Status::kAlreadyListening;\n    case Status::Value::kReset:\n      return mojom::Status::kReset;\n    case Status::Value::kTimeout:\n      return mojom::Status::kTimeout;\n    case Status::Value::kUnknown:\n      return mojom::Status::kUnknown;\n    case Status::Value::kNextValue:\n      return mojom::Status::kNextValue;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Converts internal status values to corresponding mojom status values."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\collaboration\\internal\\messaging\\storage\\collaboration_message_util.cc:9-28","function":"GetMessageCategory","codesnippet":"{\n  switch (message.event_type()) {\n    case collaboration_pb::TAB_ADDED:\n    case collaboration_pb::TAB_REMOVED:\n    case collaboration_pb::TAB_UPDATED:\n      return MessageCategory::kTab;\n    case collaboration_pb::TAB_GROUP_ADDED:\n    case collaboration_pb::TAB_GROUP_REMOVED:\n    case collaboration_pb::TAB_GROUP_NAME_UPDATED:\n    case collaboration_pb::TAB_GROUP_COLOR_UPDATED:\n      return MessageCategory::kTabGroup;\n    case collaboration_pb::COLLABORATION_ADDED:\n    case collaboration_pb::COLLABORATION_REMOVED:\n    case collaboration_pb::COLLABORATION_MEMBER_ADDED:\n    case collaboration_pb::COLLABORATION_MEMBER_REMOVED:\n      return MessageCategory::kCollaboration;\n    case collaboration_pb::VERSION_OUT_OF_DATE:\n    default:\n      return MessageCategory::kUnknown;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Categorizes messages based on their event type."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\search_engines\\search_engine_tab_helper.cc:274-335","function":"SearchEngineTabHelper::PageHasOpenSearchDescriptionDocument","codesnippet":"{\n  // Checks to see if we should generate a keyword based on the OSDD, and if\n  // necessary uses TemplateURLFetcher to download the OSDD and create a\n  // keyword.\n\n  // Make sure that the page is the current page and other basic checks.\n  // When |page_url| has file: scheme, this method doesn't work because of\n  // http://b/issue?id=863583. For that reason, this doesn't check and allow\n  // urls referring to osdd urls with same schemes.\n  if (!osdd_url.is_valid() || !osdd_url.SchemeIsHTTPOrHTTPS()) {\n    return;\n  }\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents()->GetBrowserContext());\n  if (page_url != web_contents()->GetLastCommittedURL() ||\n      !TemplateURLFetcherFactory::GetForProfile(profile) ||\n      profile->IsOffTheRecord()) {\n    return;\n  }\n\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  // Don't add intranet single word website, e.g. http://who, as search engine.\n  if (osdd_url.HostNoBrackets().find('.') == std::string::npos) {\n    return;\n  }\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n\n  // If the current page is a form submit, find the last page that was not a\n  // form submit and use its url to generate the keyword from.\n  NavigationController& controller = web_contents()->GetController();\n  NavigationEntry* entry = controller.GetLastCommittedEntry();\n  for (int index = controller.GetLastCommittedEntryIndex();\n       (index > 0) && IsFormSubmit(entry);\n       entry = controller.GetEntryAtIndex(index)) {\n    --index;\n  }\n  if (!entry || IsFormSubmit(entry)) {\n    return;\n  }\n\n  // Autogenerate a keyword for the autodetected case; in the other cases we'll\n  // generate a keyword later after fetching the OSDD.\n  std::u16string keyword = GenerateKeywordFromNavigationEntry(entry);\n  if (keyword.empty()) {\n    return;\n  }\n\n  auto* frame = web_contents()->GetPrimaryMainFrame();\n  mojo::Remote<network::mojom::URLLoaderFactory> url_loader_factory;\n  frame->CreateNetworkServiceDefaultFactory(\n      url_loader_factory.BindNewPipeAndPassReceiver());\n\n  // Download the OpenSearch description document. If this is successful, a\n  // new keyword will be created when done.\n  TemplateURLFetcherFactory::GetForProfile(profile)->ScheduleDownload(\n      keyword, osdd_url, entry->GetFavicon().url,\n      frame->GetLastCommittedOrigin(), url_loader_factory.get(),\n      frame->GetRoutingID(),\n      content::GlobalRequestID::MakeBrowserInitiated().request_id);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a search engine keyword from an OpenSearch description document if certain conditions are met."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_mobile_lightning\\core\\lightning_download_processor.cc:535-556","function":"LightningDownloadProcessor::OnParseHistoryCompleted","codesnippet":"{\n  history_import_result_ = success;\n  if (success) {\n    LightningDiagnosticsManager::GetInstance()\n        ->RecordDataProcessDiagnosticsState(\n            LightningImportDataType::HISTORY,\n            LightningDataProcessDiagnosticsState::DATA_IMPORT_START);\n    history_import_result_ = ImportHistoryData();\n    if (history_import_result_) {\n      LightningDiagnosticsManager::GetInstance()\n          ->RecordDataProcessDiagnosticsState(\n              LightningImportDataType::HISTORY,\n              LightningDataProcessDiagnosticsState::DATA_IMPORT_COMPLETE);\n    } else {\n      LightningDiagnosticsManager::GetInstance()\n          ->RecordDataProcessDiagnosticsError(\n              LightningImportDataType::HISTORY,\n              LightningDataProcessDiagnosticsError::ERROR_IMPORT_FAILED);\n    }\n  }\n  pending_import_data_type_count_ -= 1;\n  checkCompleted();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Imports history data and records diagnostic states and errors."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\renderer_context_menu\\voice_typing_panel_menu_observer.cc:33-55","function":"VoiceTypingPanelMenuObserver::InitMenu","codesnippet":"{\n  is_voice_typing_supported_ = ui::IsVoiceTypingPanelSupported();\n  is_editable_ = params.is_editable;\n  if (is_editable_ && params.misspelled_word.empty() &&\n      is_voice_typing_supported_) {\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    if (features::edge::IsRing1CleanupMenuIconsEnabled()) {\n      proxy_->AddMenuItem(\n          IDC_CONTENT_CONTEXT_VOICE_TYPING,\n          l10n_util::GetStringUTF16(IDS_CONTENT_CONTEXT_VOICE_TYPING));\n    } else {\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      proxy_->AddMenuItemWithIcon(\n          IDC_CONTENT_CONTEXT_VOICE_TYPING,\n          l10n_util::GetStringUTF16(IDS_CONTENT_CONTEXT_VOICE_TYPING),\n          ui::ImageModel::FromVectorIcon(\n              vector_icons::kMicIcon,\n              /*color_id=*/-1, ui::SimpleMenuModel::kDefaultIconSize));\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    }\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adds a voice typing menu item if supported and editable conditions are met."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\profiles\\signin_intercept_first_run_experience_dialog.cc:278-304","function":"SigninInterceptFirstRunExperienceDialog::DoNextStep","codesnippet":"{\n  DCHECK_EQ(expected_current_step, current_step_);\n  // Going to a previous step is not allowed.\n  DCHECK_GT(step, current_step_);\n  current_step_ = step;\n\n  switch (step) {\n    case Step::kStart:\n      NOTREACHED();\n    case Step::kTurnOnSync:\n      DoTurnOnSync();\n      return;\n    case Step::kSyncConfirmation:\n      DoSyncConfirmation();\n      return;\n    case Step::kWaitForSyncedTheme:\n      DoWaitForSyncedTheme();\n      return;\n    case Step::kProfileCustomization:\n      DoProfileCustomization();\n      return;\n    case Step::kProfileSwitchIPHAndCloseModal:\n      DoProfileSwitchIPHAndCloseModal();\n      return;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Advances to the next setup step and executes corresponding actions."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_games\\gamer_mode\\content\\browser\\web_ui\\gamer_mode_setting_ui_untrusted_data_source.cc:61-81","function":"GamerModeSettingUIUntrustedDataSource::GetContentSecurityPolicy","codesnippet":"{\n  switch (directive) {\n    case network::mojom::CSPDirectiveName::RequireTrustedTypesFor:\n      return \"require-trusted-types-for 'script';\";\n    case network::mojom::CSPDirectiveName::TrustedTypes:\n      return \"trusted-types fast-html default \"\n             \"gamer-mode-settings-untrusted-static;\";\n    case network::mojom::CSPDirectiveName::ScriptSrc:\n      return \"script-src 'self' \" + GetScriptSourceCSPForModalScriptURL() + \";\";\n    case network::mojom::CSPDirectiveName::StyleSrc:\n      return \"style-src 'self' 'unsafe-inline';\";\n    case network::mojom::CSPDirectiveName::ConnectSrc:\n      return \"connect-src ;\";\n    case network::mojom::CSPDirectiveName::ImgSrc:\n      return \"img-src \" + GetImageSourceCSPForModal() + \";\";\n    case network::mojom::CSPDirectiveName::FrameAncestors:\n      return \"frame-ancestors \" + std::string(kEdgeGamerModeSettingURL) + \";\";\n    default:\n      return URLDataSource::GetContentSecurityPolicy(directive);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Returns a specific Content Security Policy directive string based on the given directive type."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\extensions\\android\\edge_extension_install_dialog_view.cc:38-65","function":"ShowExtensionInstallDialogImpl","codesnippet":"{\n  scoped_refptr<CloseDialogCallbackWrapper> wrapper =\n      new CloseDialogCallbackWrapper(std::move(done_callback));\n\n  std::vector<std::u16string> permissions;\n  int permission_count = prompt->GetPermissionCount();\n  for (int i = 0; i < permission_count; ++i) {\n    permissions.push_back(prompt->GetPermission(i));\n  }\n\n  bool is_permissions_prompt =\n      prompt->type() == ExtensionInstallPrompt::PromptType::PERMISSIONS_PROMPT;\n\n  bool has_user_script_permission = false;\n  if (prompt->extension()->permissions_data()) {\n    has_user_script_permission =\n        prompt->extension()->permissions_data()->HasAPIPermission(\n            extensions::mojom::APIPermissionID::kUserScripts);\n  }\n\n  edge_android::EdgeExtensionDialogManager::GetInstance()\n      ->ShowExtensionInstallPrompt(\n          prompt->extension()->id(), prompt->extension()->name(), permissions,\n          is_permissions_prompt, has_user_script_permission,\n          base::BindOnce(&CloseDialogCallbackWrapper::Run, wrapper, false));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays an extension installation prompt with permissions and user script information."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_mobile_interactive_web\\android\\video_summary_bridge.cc:82-112","function":"VideoSummaryBridge::ExtractionCallback","codesnippet":"{\n  JNIEnv* env = base::android::AttachCurrentThread();\n  if (!java_ref_) {\n    return;\n  }\n\n  bool hasTranscript =\n      page_content.find(u\"video_transcript\") != std::string::npos;\n\n  edge_mobile_logger::WriteLog(\n      edge_mobile_logger::LogLevel::INFO,\n      base::StringPrintf(\"[Copilot] Video summary %s transcript, Text \"\n                         \"combinedText.length: %d, Error code: %d\",\n                         hasTranscript ? \"includes\" : \"has no\",\n                         page_content.length(), error_code),\n      edge_mobile_logger::LoggerType::MAIN_PATH);\n\n  base::UmaHistogramCustomTimes(\n      edge_mobile_video_extractor::metrics::\n          kVideoSummaryFetchVideoContextDurationHistogram,\n      base::TimeTicks::Now() - video_transcript_start_time,\n      base::Milliseconds(1), base::Minutes(1), 60);\n\n  Java_VideoSummaryBridge_notifyPageContent(\n      env, java_ref_,\n      base::android::ConvertUTF16ToJavaString(env, page_content),\n      has_timestamp);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs video summary details and notifies Java bridge with page content."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\isolated_web_apps\\commands\\check_isolated_web_app_bundle_installability_command.cc:47-78","function":"CheckIsolatedWebAppBundleInstallabilityCommand::StartWithLock","codesnippet":"{\n  lock_ = std::move(lock);\n\n  const WebApp* app = lock_->registrar().GetAppById(bundle_metadata_.app_id());\n\n  if (!app) {\n    ReportResult(IsolatedInstallabilityCheckResult::kInstallable, std::nullopt);\n    return;\n  }\n\n  const std::optional<IsolationData>& isolation_data = app->isolation_data();\n  // If there is an app with the same app ID, it must be an IWA.\n  CHECK(isolation_data.has_value());\n\n  base::Version installed_version = isolation_data->version();\n  bool is_dev_mode_install = IsIwaDevModeEnabled(profile_);\n\n  if (is_dev_mode_install && bundle_metadata_.version() < installed_version) {\n    ReportResult(IsolatedInstallabilityCheckResult::kOutdated,\n                 installed_version);\n    return;\n  }\n\n  if (!is_dev_mode_install && bundle_metadata_.version() <= installed_version) {\n    ReportResult(IsolatedInstallabilityCheckResult::kOutdated,\n                 installed_version);\n    return;\n  }\n\n  ReportResult(IsolatedInstallabilityCheckResult::kUpdatable,\n               installed_version);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks if a web app is installable, outdated, or updatable based on its version and isolation data."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\ssl_client_certificate_selector.cc:166-199","function":"ShowSSLClientCertificateSelector","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (!GetShowSSLClientCertificateSelectorTestingHook().is_null()) {\n    return GetShowSSLClientCertificateSelectorTestingHook().Run(\n        contents, cert_request_info, std::move(client_certs),\n        std::move(delegate));\n  }\n\n  // Don't bother prompting the user if there are no certs to choose from.\n  // Just continue with no certificate.\n  if (client_certs.empty()) {\n    delegate->ContinueWithCertificate(nullptr, nullptr);\n    return base::OnceClosure();\n  }\n\n  // Not all WebContentses can show modal dialogs.\n  //\n  // TODO(davidben): Move this hook to the WebContentsDelegate and only try to\n  // show a dialog in Browser's implementation. https://crbug.com/456255\n  if (!SSLClientCertificateSelector::CanShow(contents)) {\n    return base::OnceClosure();\n  }\n\n  SSLClientCertificateSelector* selector = new SSLClientCertificateSelector(\n      contents, cert_request_info, std::move(client_certs),\n      std::move(delegate));\n  selector->Init();\n  selector->Show();\n  return selector->GetCancellationCallback();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays an SSL client certificate selection dialog if possible."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_hub_apps\\hub_app_context_driver.cc:336-400","function":"HubAppContextDriver::CreateAwarenessNotification","codesnippet":"{\n  if (!features::AreShorelineAwarenessPromptsEnabled(/*trigger_usage=*/true)) {\n    return;\n  }\n\n  // Only create notifications once per page navigation.\n  if (has_created_notifications_for_page_) {\n    return;\n  }\n\n  auto* hub_notification_store =\n      hub_utils::GetNotificationStoreForProfile(profile());\n  if (!hub_notification_store) {\n    return;\n  }\n\n  // [Wei] remove this as well?\n  auto* hub_apps_management =\n      HubAppsManagementFactory::GetForProfile(profile());\n  if (!hub_apps_management) {\n    return;\n  }\n\n  // Create the notification for each app.\n  for (const auto& app_id : app_ids) {\n    // Update Histogram.\n    Browser* browser = chrome::FindBrowserWithTab(web_contents());\n    DCHECK(browser);\n    hub_utils::RecordAwarenessHistogram(browser, app_id);\n\n    const auto* app =\n        edge::hub_apps::SidebarLowLevelApi::GetMetadataFromAllById(*profile(),\n                                                                   app_id);\n    if (!app) {\n      continue;\n    }\n\n    const ManifestAppAwarenessPrompts::PromptContext& notification =\n        app->notifications().awareness_prompts().bubble_notifications();\n    auto payload = std::make_unique<MessageNotificationPayload>(\n        notification.text(), notification.location());\n    NotificationMetadata metadata = NotificationMetadata::CreateNew(\n        app->id(), web_contents(), web_contents()->GetLastCommittedURL(),\n        payload.get(), NotificationType::kBubbleAwarenessPrompt);\n\n    // Send the notification to the `hub_notification_store`.\n    VLOG(1) << __func__ << \" for \" << app->name();\n    NotificationId id = hub_notification_store->CreateNotification(\n        metadata, std::move(payload));\n\n    if (id == kInvalidNotificationId) {\n      continue;\n    }\n\n    // Keep track of each notification we created.\n    notification_ids_.push_back(id);\n    DCHECK(!hub_notification_store->HasRegisteredObserver(this, id));\n    // Register as an observer for changes in this notification.\n    hub_notification_store->RegisterNotificationChangeObserver(this, id);\n  }\n\n  // Set `has_created_notifications_for_page_` to `true` so we don't create any\n  // more notification until the user has navigated to a new page.\n  has_created_notifications_for_page_ = true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and registers notifications for app awareness prompts if enabled."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\commerce\\core\\product_specifications\\product_specifications_sync_bridge.cc:277-311","function":"ProductSpecificationsSyncBridge::OnReadAllDataAndMetadata","codesnippet":"{\n  if (error) {\n    change_processor()->ReportError(*error);\n    return;\n  }\n\n  // If Metadata cache contains supported fields it is because the browser\n  // has been upgraded. metadata_batch and record_list are no longer usable.\n  if (base::FeatureList::IsEnabled(\n          kProductSpecificationsClearMetadataOnNewlySupportedFields) &&\n      SyncMetadataCacheContainsSupportedFields(\n          metadata_batch->GetAllMetadata())) {\n    store_->DeleteAllDataAndMetadata(base::DoNothing());\n    metadata_batch = std::make_unique<syncer::MetadataBatch>();\n    record_list = std::make_unique<syncer::DataTypeStore::RecordList>();\n  }\n\n  for (const syncer::DataTypeStore::Record& record : *record_list) {\n    sync_pb::ProductComparisonSpecifics product_comparison_specifics;\n    if (!product_comparison_specifics.ParseFromString(record.value)) {\n      continue;\n    }\n    entries_.emplace(product_comparison_specifics.uuid(),\n                     product_comparison_specifics);\n  }\n\n  change_processor()->ModelReadyToSync(std::move(metadata_batch));\n\n  DCHECK(init_callback_);\n  if (init_callback_) {\n    std::move(init_callback_).Run();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes synchronization by processing records and handling metadata updates."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\win\\edge_wdag\\host\\security_utils.cc:15-62","function":"HinderFileTampering","codesnippet":"{\n  // This function attempts to ACL the target file such to prevent further\n  // edits. However, given that the current user is the owner of the file,\n  // they can always change the permissions on the file. So this is really\n  // just a speed bump.\n\n  std::wstring user_sid;\n  if (!base::win::GetUserSidString(&user_sid))\n    return false;\n\n  // For reference, see:\n  // https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format\n  std::wstring rights =\n      // DACL, protected.\n      L\"D:P\"\n      // Allow the current user read and delete.\n      L\"(A;;FRSD;;;\" + user_sid + L\")\"\n      // Allow admins & system all access.\n      L\"(A;;GA;;;BA)(A;;GA;;;SY)\";\n  PSECURITY_DESCRIPTOR sd = nullptr;\n  if (::ConvertStringSecurityDescriptorToSecurityDescriptor(\n      rights.c_str(),\n      SDDL_REVISION_1,\n      &sd,\n      nullptr /* length */) == 0)\n    return false;\n\n  std::unique_ptr<void, decltype(::LocalFree)*> sd_holder(sd, ::LocalFree);\n  PACL dacl = nullptr;\n  BOOL present = FALSE;\n  BOOL defaulted = FALSE;\n  if (!::GetSecurityDescriptorDacl(sd, &present, &dacl, &defaulted))\n    return false;\n\n  if (!present || defaulted)\n    return false;\n\n  if (ERROR_SUCCESS != ::SetNamedSecurityInfo(\n      const_cast<wchar_t*>(file_path.value().c_str()),\n      SE_FILE_OBJECT,\n      PROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,\n      nullptr, // owner\n      nullptr, // group\n      dacl,\n      nullptr)) // sacl\n    return false;\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Restricts file permissions to limit edits by non-owners."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\captive_portal\\content\\captive_portal_tab_helper.cc:81-115","function":"CaptivePortalTabHelper::DidFinishNavigation","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  // Exclude non-primary frame and subframe navigations.\n  if (!navigation_handle->IsInPrimaryMainFrame())\n    return;\n\n  // Exclude same-document navigations and aborted navigations that were not\n  // being tracked.\n  if (navigation_handle_ != navigation_handle &&\n      (!navigation_handle->HasCommitted() ||\n       navigation_handle->IsSameDocument())) {\n    return;\n  }\n\n  bool need_to_simulate_start = navigation_handle_ != navigation_handle;\n  bool need_to_simulate_previous_abort =\n      need_to_simulate_start && !!navigation_handle_;\n  navigation_handle_ = nullptr;\n\n  if (need_to_simulate_previous_abort)\n    tab_reloader_->OnAbort();\n\n  if (need_to_simulate_start) {\n    tab_reloader_->OnLoadStart(\n        navigation_handle->GetURL().SchemeIsCryptographic());\n  }\n\n  if (navigation_handle->HasCommitted()) {\n    tab_reloader_->OnLoadCommitted(navigation_handle->GetNetErrorCode(),\n                                   navigation_handle->GetResolveErrorInfo());\n  } else {\n    tab_reloader_->OnAbort();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles navigation events for primary main frame by simulating load start, commit, or abort actions."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\commerce\\product_specifications_button.cc:44-114","function":"ProductSpecificationsButton::ProductSpecificationsButton","codesnippet":"{\n  mouse_watcher_ = std::make_unique<views::MouseWatcher>(\n      std::make_unique<views::MouseWatcherViewHost>(locked_expansion_view,\n                                                    gfx::Insets()),\n      this);\n  if (entry_point_controller_) {\n    entry_point_controller_observations_.Observe(entry_point_controller_);\n  }\n  auto* const layout_manager =\n      SetLayoutManager(std::make_unique<views::BoxLayout>());\n  layout_manager->set_main_axis_alignment(\n      views::BoxLayout::MainAxisAlignment::kEnd);\n\n  SetProperty(views::kElementIdentifierKey,\n              kProductSpecificationsButtonElementId);\n\n  SetTooltipText(l10n_util::GetStringUTF16(IDS_COMPARE_ENTRY_POINT_DEFAULT));\n  // TODO(b/325661685): Set accessibility name of the button.\n  SetLabelStyle(views::style::STYLE_BODY_3_EMPHASIS);\n  label()->SetElideBehavior(gfx::ElideBehavior::NO_ELIDE);\n\n  const gfx::Insets label_margin =\n      gfx::Insets().set_left(kProductSpecificationsButtonLabelMargin);\n  label()->SetProperty(views::kMarginsKey, label_margin);\n\n  SetForegroundFrameActiveColorId(kColorTabSearchButtonCRForegroundFrameActive);\n  SetForegroundFrameInactiveColorId(\n      kColorTabSearchButtonCRForegroundFrameInactive);\n  SetBackgroundFrameActiveColorId(kColorNewTabButtonCRBackgroundFrameActive);\n  SetBackgroundFrameInactiveColorId(\n      kColorNewTabButtonCRBackgroundFrameInactive);\n  SetCloseButton(base::BindRepeating(&ProductSpecificationsButton::OnDismissed,\n                                     base::Unretained(this)));\n\n  const int space_between_buttons = 2;\n  gfx::Insets margin = gfx::Insets();\n  if (before_tab_strip) {\n    margin.set_left(space_between_buttons);\n  } else {\n    margin.set_right(space_between_buttons);\n  }\n  SetProperty(views::kMarginsKey, margin);\n  SetOpacity(0);\n\n  expansion_animation_.SetTweenType(gfx::Tween::Type::ACCEL_20_DECEL_100);\n  opacity_animation_.SetTweenType(gfx::Tween::Type::LINEAR);\n\n  set_paint_transparent_for_custom_image_theme(false);\n\n  layout_manager->SetFlexForView(close_button_, 1);\n\n  SetLayoutManager(std::make_unique<views::FlexLayout>());\n\n  UpdateColors();\n\n  // Button is not visible by default to avoid grabbing focus.\n  SetVisible(false);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and configures a button with layout, style, and animation properties."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_sdsm\\policy\\edge_sdsm_policy_handler.cc:24-83","function":"SDSMPolicyHandler::ApplyPolicySettings","codesnippet":"{\n  const base::Value* value = policies.GetValueUnsafe(policy_name());\n\n  if (value && value->is_int()) {\n    switch (value->GetInt()) {\n      case 0:\n        RecordSdsmEnabelmentReason(SDSMPref::DisabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, false);\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kMaxValue);\n        break;\n      case 1:\n        RecordSdsmEnabelmentReason(SDSMPref::EnabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, true);\n        // choose the Super Duper Secure Mode option if the feature is enabled.\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kBalanced);\n        break;\n      case 2:\n        RecordSdsmEnabelmentReason(SDSMPref::EnabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, true);\n        // choose the Super Duper Secure Mode option if the feature is enabled.\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kStrict);\n        break;\n      case 3:\n        RecordSdsmEnabelmentReason(SDSMPref::EnabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, true);\n        // choose the Super Duper Secure Mode option if the feature is enabled.\n        // choose Balanced Mode as we no longer support BasicMode\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kBalanced);\n        break;\n    }\n  }\n\n  const base::Value* jit_value =\n      policies.GetValueUnsafe(policy::key::kDefaultJavaScriptJitSetting);\n  if (jit_value && jit_value->is_int()) {\n    switch (jit_value->GetInt()) {\n      case 1:\n        // CONTENT_SETTING_ALLOW\n        RecordSdsmEnabelmentReason(SDSMPref::DisabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, false);\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kMaxValue);\n        break;\n      case 2:\n        // CONTENT_SETTING_BLOCK\n        RecordSdsmEnabelmentReason(SDSMPref::EnabledByPolicy);\n        prefs->SetBoolean(prefs::kEdgeSuperDuperSecureModeEnabled, true);\n        // choose the Super Duper Secure Mode option if the feature is enabled.\n        prefs->SetInteger(prefs::kEdgeSuperDuperSecureModeState,\n                          (int)SdsmState::kStrict);\n        break;\n      default:\n        break;\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Configures the Super Duper Secure Mode settings based on policy values."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\notifications\\low_disk_notification.cc:55-90","function":"LowDiskNotification::LowDiskSpace","codesnippet":"{\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  bool show_low_disk_space_notification = true;\n  if (!CrosSettings::Get()->GetBoolean(kDeviceShowLowDiskSpaceNotification,\n                                       &show_low_disk_space_notification)) {\n    DVLOG(1) << \"DeviceShowLowDiskSpaceNotification not set, \"\n                \"defaulting to showing the notification.\";\n  }\n\n  // We suppress the low-space notifications when there are multiple users on an\n  // enterprise managed device based on policy configuration.\n  if (!show_low_disk_space_notification &&\n      user_manager::UserManager::Get()->GetPersistedUsers().size() > 1) {\n    LOG(WARNING) << \"Device is low on disk space, but the notification was \"\n                 << \"suppressed on a managed device.\";\n    return;\n  }\n\n  if (demo_mode::IsDeviceInDemoMode()) {\n    LOG(WARNING) << \"Device is low on disk space, but the notification was \"\n                 << \"suppressed on a demo mode device.\";\n    return;\n  }\n\n  Severity severity = GetSeverity(status.disk_free_bytes());\n  base::Time now = base::Time::Now();\n  if (severity != last_notification_severity_ ||\n      (severity == HIGH &&\n       now - last_notification_time_ > notification_interval_)) {\n    SystemNotificationHelper::GetInstance()->Display(\n        *CreateNotification(severity));\n    last_notification_time_ = now;\n    last_notification_severity_ = severity;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays a low disk space notification based on device settings and conditions."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\password_manager\\core\\browser\\password_store\\get_logins_with_affiliations_request_handler.cc:51-80","function":"ProcessExactAndPSLForms","codesnippet":"{\n  if (std::holds_alternative<PasswordStoreBackendError>(logins_or_error)) {\n    return logins_or_error;\n  }\n\n  for (auto& form : std::get<LoginsResult>(logins_or_error)) {\n    switch (GetMatchResult(form, digest)) {\n      case MatchResult::NO_MATCH:\n        NOTREACHED();\n      case MatchResult::EXACT_MATCH:\n      case MatchResult::FEDERATED_MATCH:\n        form.match_type = PasswordForm::MatchType::kExact;\n        break;\n      case MatchResult::PSL_MATCH:\n        if (IsExtendedPSLMatch(form, digest, psl_extensions)) {\n          form.match_type = PasswordForm::MatchType::kPSL;\n        }\n        break;\n      case MatchResult::FEDERATED_PSL_MATCH:\n        if (IsExtendedPSLMatch(form, digest, psl_extensions)) {\n          form.match_type = PasswordForm::MatchType::kPSL;\n        }\n        break;\n    }\n  }\n\n  return logins_or_error;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Classifies password form match types based on login results and digest."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\component_updater\\installer_policies\\on_device_head_suggest_component_installer.cc:47-71","function":"GetNormalizedLocale","codesnippet":"{\n  std::string locale, locale_constraint;\n  // Both incognito and non-incognito will use a same model so it's okay to\n  // fetch the param from either feature.\n  if (OmniboxFieldTrial::IsOnDeviceHeadSuggestEnabledForIncognito()) {\n    locale_constraint =\n        OmniboxFieldTrial::OnDeviceHeadModelLocaleConstraint(true);\n  } else if (OmniboxFieldTrial::IsOnDeviceHeadSuggestEnabledForNonIncognito()) {\n    locale_constraint =\n        OmniboxFieldTrial::OnDeviceHeadModelLocaleConstraint(false);\n  }\n\n  locale = raw_locale;\n  std::erase_if(locale, [](const auto c) { return base::Contains(\"-_\", c); });\n\n  std::ranges::transform(locale, locale.begin(),\n                         [](char c) { return base::ToUpperASCII(c); });\n\n  if (!locale_constraint.empty()) {\n    locale += locale_constraint;\n  }\n\n  VLOG(1) << \"On Device Head Component will fetch model for locale: \" << locale;\n\n  return locale;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a locale string for fetching a device head model."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\fileapi\\recent_disk_source.cc:294-322","function":"RecentDiskSource::MatchesFileType","codesnippet":"{\n  if (file_type == RecentSource::FileType::kAll) {\n    return true;\n  }\n\n  // File type for |path| is guessed by data generated from file_types.json5.\n  // It guesses mime types based on file extensions, but it has a limited set\n  // of file extensions.\n  // TODO(fukino): It is better to have better coverage of file extensions to be\n  // consistent with file-type detection on Android system. crbug.com/1034874.\n  const auto ext = base::ToLowerASCII(path.Extension());\n  if (!file_types_data::kExtensionToMIME.contains(ext)) {\n    return false;\n  }\n  std::string mime_type = file_types_data::kExtensionToMIME.at(ext);\n\n  switch (file_type) {\n    case RecentSource::FileType::kAudio:\n      return net::MatchesMimeType(kAudioMimeType, mime_type);\n    case RecentSource::FileType::kImage:\n      return net::MatchesMimeType(kImageMimeType, mime_type);\n    case RecentSource::FileType::kVideo:\n      return net::MatchesMimeType(kVideoMimeType, mime_type);\n    case RecentSource::FileType::kDocument:\n      return file_types_data::kDocumentMIMETypes.contains(mime_type);\n    default:\n      return false;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if a file's MIME type matches a specified file type category."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\tabs\\new_tab_button.cc:66-94","function":"NewTabButton::NewTabButton","codesnippet":"{\n  SetAnimateOnStateChange(true);\n\n  // If there is an image for the NewTabButton it is set by the theme. Theme\n  // images should not be flipped for RTL.\n  SetFlipCanvasOnPaintForRTLUI(false);\n\n  foreground_frame_active_color_id_ = kColorNewTabButtonForegroundFrameActive;\n  foreground_frame_inactive_color_id_ =\n      kColorNewTabButtonForegroundFrameInactive;\n  background_frame_active_color_id_ = kColorNewTabButtonBackgroundFrameActive;\n  background_frame_inactive_color_id_ =\n      kColorNewTabButtonBackgroundFrameInactive;\n\n  ink_drop_container_ =\n      AddChildView(std::make_unique<views::InkDropContainerView>());\n\n  views::InkDrop::Get(this)->SetMode(views::InkDropHost::InkDropMode::ON);\n  views::InkDrop::Get(this)->SetHighlightOpacity(0.16f);\n  views::InkDrop::Get(this)->SetVisibleOpacity(0.14f);\n\n  SetInstallFocusRingOnFocus(true);\n  views::HighlightPathGenerator::Install(\n      this, std::make_unique<NewTabButton::HighlightPathGenerator>());\n\n  SetFocusBehavior(FocusBehavior::ACCESSIBLE_ONLY);\n\n  SetProperty(views::kElementIdentifierKey, kNewTabButtonElementId);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and configures the appearance and behavior of a new tab button."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_mam_client\\core\\edge_mam_client_manager_impl.cc:188-226","function":"EdgeMamClientManagerImpl::OnUserEnrolled","codesnippet":"{\n  auto ui = users_.find(user_id);\n  CHECK(ui != users_.end());\n  CHECK(std::get_if<User>(&ui->second) == nullptr);\n\n  auto waiters = std::move(std::get<Waiters>(ui->second));\n\n  if (!sdk_user.is_valid()) {\n    users_.erase(ui);\n    for (auto& waiter : waiters) {\n      std::move(waiter).Run(mojo::PendingRemote<::mam::mojom::User>());\n    }\n    return;\n  }\n\n  FireOnUserEnrolledTelemetry(new_enrollment);\n\n  auto user = std::make_unique<EdgeMamClient>(\n      std::move(user_info), std::move(delegate), std::move(sdk_user),\n      base::BindOnce(&EdgeMamClientManagerImpl::OnUserRemoved,\n                     weak_ptr_factory_.GetWeakPtr(), user_id));\n\n  ui->second = std::move(user);\n\n  for (auto& waiter : waiters) {\n    mojo::PendingRemote<::mam::mojom::User> remote;\n    std::get<User>(ui->second)\n        ->BindRemote(remote.InitWithNewPipeAndPassReceiver());\n    std::move(waiter).Run(std::move(remote));\n  }\n\n  for (auto& observer : observers_) {\n    NotifyUserEnrollment(observer, *std::get<User>(ui->second));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles user enrollment by updating user data and notifying waiters and observers."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\metrics\\per_user_state_manager_chromeos.cc:225-255","function":"PerUserStateManagerChromeOS::IsUserAllowedToChangeConsent","codesnippet":"{\n  // Devices with managed policy should not have control to toggle metrics\n  // consent.\n  if (IsReportingPolicyManaged())\n    return false;\n\n  auto user_type = user->GetType();\n\n  // Unmanaged guest users are allowed to update their consent during OOBE.\n  // Unmanaged guests can be created without a device owner, which is why this\n  // logic is explicitly before the device ownership logic below.\n  if (user_type == user_manager::UserType::kGuest) {\n    return true;\n  }\n\n  // If the device isn't owned yet, we consider this user as the owner.\n  // During OOBE by the first user, the device remains unowned.\n  // Guest sessions can be started before there is a device owner, which\n  // is handled above.\n  if (!IsDeviceOwned()) {\n    return false;\n  }\n\n  // Check if the current user is the owner user.\n  if (user->GetAccountId() == user_manager_->GetOwnerAccountId()) {\n    return false;\n  }\n\n  // User types that are not the owner can update their consent during OOBE.\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if a user can update their metrics consent during the out-of-box experience (OOBE).","ghc_query":"determine user update metrics consent OOBE out-of-box experience"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_auth\\edge_authentication_manager.cc:384-453","function":"EdgeAuthenticationManager::StartAcquireAccessTokenWithUserInteraction","codesnippet":"{\n  CHECK(EdgeThreadType::CurrentlyOn(EdgeThreadType::UI));\n\n  const base::Time start_time = base::Time::Now();\n\n  if (!token_params.IsValid()) {\n    // This is currently for Android only, should also be able to apply to other\n    // platfrom.\n#if BUILDFLAG(IS_ANDROID)\n    // If the scope info is invalid (it may comes from upstream code\n    // or wrong parameter passed from Edge code), return invalid scope error.\n    if (!token_params.IsScopeValid()) {\n      EdgeAuthErrorInfo error_info(EdgeAuthErrorType::kTokenRequestFailed,\n                                   EdgeAuthSecondaryErrorType::kInvalidScope);\n      EdgeTokenAcquireResult result;\n      result.error_info = error_info;\n      FireAcquireAccessTokenCompleted(false, token_params, start_time, {},\n                                      result, {});\n      return error_info;\n    }\n#endif  // BUILDFLAG(IS_ANDROID)\n\n    // Handle unsupported sovereignty errors separately and bail out early.\n    EdgeAuthErrorInfo sovereignty_error_info;\n    if (!ShouldContinueTokenFetchWrtSovereignty(token_params,\n                                                &sovereignty_error_info) &&\n        sovereignty_error_info.IsUnsupportedSovereignty()) {\n      EdgeTokenAcquireResult result;\n      result.error_info = sovereignty_error_info;\n      FireAcquireAccessTokenCompleted(false, token_params, start_time, {},\n                                      result, {});\n      HandleSovereigntyUpdateDuringTokenFetch(token_params, result);\n      return sovereignty_error_info;\n    }\n    // Do not log telemetry for other invalid token params so that we don't\n    // pollute the telemetry results.\n    return EdgeAuthErrorInfo(EdgeAuthErrorType::kInvalidArguments);\n  }\n\n  auto func = [](base::WeakPtr<EdgeAuthenticationManager> this_weak_ptr,\n                 const EdgeTokenAcquireParameters& token_params,\n                 base::Time start_time, EdgeTokenAcquireCallback&& callback,\n                 EdgeTokenAcquireResult result) {\n    auto* manager = this_weak_ptr.get();\n    if (!manager)\n      return;  // Object destroyed, no need to proceed.\n    manager->FireAcquireAccessTokenCompleted(false, token_params, start_time,\n                                             {}, result, {});\n    manager->HandleSovereigntyUpdateDuringTokenFetch(token_params, result);\n    std::move(callback).Run(std::move(result));\n  };\n\n  auto updated_params =\n      edge_auth::AttachEnrollmentIdToRequestParamIfNeeded(token_params);\n\n  const auto error_info = StartAcquireAccessTokenWithUserInteractionImpl(\n      std::move(sign_in_window_helper), updated_params,\n      base::BindOnce(func, weak_factory_.GetWeakPtr(), updated_params,\n                     start_time, std::move(acquire_callback)));\n\n  if (!error_info.IsSuccess()) {\n    FireAcquireAccessTokenCompleted(\n        false, updated_params, start_time, {},\n        EdgeTokenAcquireResult(EdgeTokenInfo(), error_info), {});\n  }\n  return error_info;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles access token acquisition, validating parameters and managing errors.","ghc_query":"handle access token acquisition validate parameter manage error oauth"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\services\\edge_entity_extraction\\onnx\\postprocessor_for_autofill.cc:493-540","function":"PostprocessorForAutofill::PostprocessingPasswordPredictions","codesnippet":"{\n  DCHECK(password_unique_ids.size() > 0);\n  DCHECK(predictions_utf8.find(attributes::kAutofillPasswordField) !=\n         predictions_utf8.end());\n\n  std::string current_unique_id;\n  // 1. if prediction result have only 1 password,\n  //    then we overide current password to new password field\n  if (password_unique_ids.size() < size_t(3)) {\n    // Override first password field to new password field\n    current_unique_id = password_unique_ids.at(0);\n    AddPredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                  attributes::kAutofillNewPasswordField);\n    RemovePredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                     attributes::kAutofillPasswordField);\n\n    // 2. if prediction result have 2 passwords, then we overide first\n    //    password to new password field; secont one to confirm password\n    if (password_unique_ids.size() == size_t(2)) {\n      // Override second password to confirm password field\n      current_unique_id = password_unique_ids.at(1);\n      AddPredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                    attributes::kAutofillConfirmPasswordField);\n      RemovePredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                       attributes::kAutofillPasswordField);\n    }\n  }\n  // 3. if prediction result have more than 3 passwords, then we overide first\n  //    password to password field; second to new password;\n  //    third one to confirm password\n  else if (password_unique_ids.size() >= (size_t)3) {\n    // Override second password field to new password\n    current_unique_id = password_unique_ids.at(1);\n    AddPredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                  attributes::kAutofillNewPasswordField);\n    RemovePredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                     attributes::kAutofillPasswordField);\n\n    // Override third password field to confirm password\n    current_unique_id = password_unique_ids.at(2);\n    AddPredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                  attributes::kAutofillConfirmPasswordField);\n    RemovePredictionFieldsbyUniqueId(predictions_utf8, current_unique_id,\n                                     attributes::kAutofillPasswordField);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Reassigns password prediction fields based on the number of detected passwords.","ghc_query":"reassign password prediction field detect number autofill"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\password_manager\\core\\browser\\edge_breach_detection\\breached_table.cc:266-355","function":"BreachedTable::AddRows","codesnippet":"{\n  for (const auto& breached_table_entry : entries) {\n    if (breached_table_entry.url.is_empty() ||\n        breached_table_entry.username.empty()) {\n      LogError(BreachedTableError::kInvalidRowData);\n      return false;\n    }\n\n    DCHECK(db_);\n    // First, check if the entry exists and fetch the current values.\n    sql::Statement select_stmt(db_->GetCachedStatement(\n        SQL_FROM_HERE,\n        \"SELECT * FROM breached WHERE url = ? AND username = ?\"));\n    select_stmt.BindString(0, breached_table_entry.url.spec());\n    select_stmt.BindString16(1, breached_table_entry.username);\n\n    bool exists = select_stmt.Step();\n\n    // Now, prepare the statement for insert or update.\n    sql::Statement s(db_->GetCachedStatement(\n        SQL_FROM_HERE,\n        \"INSERT OR REPLACE INTO breached \"\n        \"(url, username, status, alert_state, \"\n        \"last_checked_time, sanitized_username, \"\n        \"alert_seen, last_seen_time, hashed_password, \"\n        \"breach_ic_alert_shown, breach_ic_last_shown_time) \"\n        \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\"));\n    s.BindString(COLUMN_URL, breached_table_entry.url.spec());\n    s.BindString16(COLUMN_USERNAME, breached_table_entry.username);\n    s.BindInt(COLUMN_STATUS, static_cast<int>(breached_table_entry.status));\n    s.BindInt(COLUMN_ALERT_STATE,\n              static_cast<int>(breached_table_entry.alert_state));\n    s.BindInt64(COLUMN_LAST_CHECKED_TIME, breached_table_entry.last_checked_time\n                                              .ToDeltaSinceWindowsEpoch()\n                                              .InMicroseconds());\n    s.BindString16(COLUMN_SANITIZED_USERNAME,\n                   breached_table_entry.sanitized_username);\n    s.BindInt(COLUMN_ALERT_SEEN,\n              static_cast<int>(breached_table_entry.alert_seen));\n    s.BindInt64(COLUMN_LAST_SEEN_TIME,\n                breached_table_entry.last_seen_time.ToDeltaSinceWindowsEpoch()\n                    .InMicroseconds());\n\n    // For hashed_password: use new value if not empty, else keep old if exists.\n    if (!breached_table_entry.hashed_password.empty()) {\n      s.BindString(COLUMN_HASHED_PASSWORD,\n                   breached_table_entry.hashed_password);\n    } else if (exists) {\n      s.BindString(COLUMN_HASHED_PASSWORD,\n                   select_stmt.ColumnString(COLUMN_HASHED_PASSWORD));\n    } else {\n      s.BindString(COLUMN_HASHED_PASSWORD, \"\");\n    }\n\n    // For breach_ic_alert_shown: use new value if it's true, else keep old if\n    // exists.\n    if (breached_table_entry.breach_ic_alert_shown == true) {\n      s.BindBool(COLUMN_IC_ALERT_SHOWN,\n                 breached_table_entry.breach_ic_alert_shown);\n    } else if (exists) {\n      s.BindBool(COLUMN_IC_ALERT_SHOWN,\n                 select_stmt.ColumnBool(COLUMN_IC_ALERT_SHOWN));\n    } else {\n      s.BindBool(COLUMN_IC_ALERT_SHOWN, false);\n    }\n\n    // For breach_ic_last_shown_time: use new value if > 0, else keep old if\n    // exists.\n    int64_t new_last_shown_time = breached_table_entry.breach_ic_last_shown_time\n                                      .ToDeltaSinceWindowsEpoch()\n                                      .InMicroseconds();\n    if (new_last_shown_time > 0) {\n      s.BindInt64(COLUMN_IC_LAST_SHOWN_TIME, new_last_shown_time);\n    } else if (exists) {\n      s.BindInt64(COLUMN_IC_LAST_SHOWN_TIME,\n                  select_stmt.ColumnInt64(COLUMN_IC_LAST_SHOWN_TIME));\n    } else {\n      s.BindInt64(COLUMN_IC_LAST_SHOWN_TIME, 0);\n    }\n\n    if (!s.Run()) {\n      TRACE_EVENT2(\"password_manager\", \"BreachedTable::AddRow\", \"error_code\",\n                   db_->GetErrorCode(), \"error_message\",\n                   db_->GetErrorMessage());\n      LogError(BreachedTableError::kAddRowFailed);\n      return false;\n    }\n  }\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Inserts or updates entries in the breached database table based on provided data.","ghc_query":"insert update entry breach database table data password leak credential"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_browser_essentials_atomic\\controller\\page_controller.cc:104-133","function":"PageController::CreateCardProviders","codesnippet":"{\n  provider_type_to_cards_map_[CardProviderType::kEfficiencyModeCardProvider] =\n      std::make_unique<EfficiencyModeCardProvider>(controller_service_);\n  provider_type_to_cards_map_\n      [CardProviderType::kPerformanceDetectorRecommendedActionCardProvider] =\n          std::make_unique<PerformanceDetectorRecommendedActionCardProvider>(\n              controller_service_);\n#if BUILDFLAG(ENABLE_SMARTSCREEN)\n  provider_type_to_cards_map_[CardProviderType::kSmartScreenCardProvider] =\n      std::make_unique<SmartScreenCardProvider>(controller_service_);\n#endif  // BUILDFLAG(ENABLE_SMARTSCREEN)\n\n  if (edge::browser_essentials::BrowserEssentialsFeature::\n          IsBrowserEssentialsAtomicMockCardEnabled()) {\n    provider_type_to_cards_map_[CardProviderType::kMockComponentsCardProvider] =\n        std::make_unique<MockComponentsCardProvider>(controller_service_);\n  }\n  // Future cards should be added here to the provider_type_to_cards_map_\n  provider_type_to_cards_map_[CardProviderType::kResourceUsageCardProvider] =\n      std::make_unique<ResourceUsageCardProvider>(controller_service_);\n  provider_type_to_cards_map_\n      [CardProviderType::kDetailedResourceUsageCardProvider] =\n          std::make_unique<ResourceUsageCardProvider>(controller_service_,\n                                                      true);\n  // Same EM cards is reused for detailed performance page as well. This\n  // will be updated in the future.\n  provider_type_to_cards_map_\n      [CardProviderType::kDetailedEfficiencyModeCardProvider] =\n          std::make_unique<EfficiencyModeCardProvider>(controller_service_);\n  // Future cards should be added here to the provider_type_to_cards_map_\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes a map with card providers based on card provider types.","ghc_query":"initialize map card provider type module"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\action_handlers\\download_update_handler.cc:353-383","function":"DownloadUpdateHandler::SetPromotionState","codesnippet":"{\n  // Worth noting: PROMOTE_DISABLED indicates that promotion is possible,\n  // there's just something else going on right now (e.g. checking for update).\n  bool hidden = state == VersionUpdater::PROMOTE_HIDDEN;\n  bool disabled = state == VersionUpdater::PROMOTE_HIDDEN ||\n                  state == VersionUpdater::PROMOTE_DISABLED ||\n                  state == VersionUpdater::PROMOTED;\n  bool actionable = state == VersionUpdater::PROMOTE_DISABLED ||\n                    state == VersionUpdater::PROMOTE_ENABLED;\n\n  std::u16string text;\n  if (actionable) {\n    text = l10n_util::GetStringUTF16(IDS_ABOUT_CHROME_AUTOUPDATE_ALL);\n  } else if (state == VersionUpdater::PROMOTED) {\n    text = l10n_util::GetStringUTF16(IDS_ABOUT_CHROME_AUTOUPDATE_ALL_IS_ON);\n  }\n\n  base::Value::Dict promo_state;\n  promo_state.Set(\"hidden\", hidden);\n  promo_state.Set(\"disabled\", disabled);\n  promo_state.Set(\"actionable\", actionable);\n  if (!text.empty()) {\n    promo_state.Set(\"text\", text);\n  }\n\n  if (callback) {\n    const base::Value value(std::move(promo_state));\n    callback.Run(std::move(value));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines promotion state and executes a callback with the result.","ghc_query":"determine promotion state execute callback result"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\segmentation_platform\\internal\\selection\\request_dispatcher.cc:153-182","function":"RequestDispatcher::GetModelResult","codesnippet":"{\n  if (storage_service_->config_holder()->IsLegacySegmentationKey(\n          segmentation_key)) {\n    LOG(ERROR)\n        << \"Segmentation key: \" << segmentation_key\n        << \" is using a legacy config with the new API which is not \"\n           \"supported. Legacy segments should migrate to the new config.\";\n    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n        FROM_HERE,\n        base::BindOnce(std::move(callback), /*is_cached_result=*/false,\n                       RawResult(PredictionStatus::kFailed)));\n    return;\n  }\n\n  Config* config =\n      storage_service_->config_holder()->GetConfigForSegmentationKey(\n          segmentation_key);\n  CHECK(config);\n\n  if (options.on_demand_execution) {\n    ExecuteOnDemand(segmentation_key, config, options, input_context,\n                    std::move(callback));\n    return;\n  }\n  HandleCachedExecution(segmentation_key, config, options, input_context,\n                        std::move(callback));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles segmentation key execution based on configuration and execution options.","ghc_query":"handle segmentation key execution configuration options"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\office_viewer\\office_document_infobar.cc:130-155","function":"OfficeInfoBarDelegateHelper::CreateDefaultInfobar","codesnippet":"{\n  InfobarConfig config = {\n      infobars::InfoBarDelegate::InfoBarIdentifier::\n          DEFAULT_OFFICE_INFOBAR_DELEGATE,\n      ConfirmInfoBarDelegate::InfoBarButton::BUTTON_OK,\n      l10n_util::GetStringUTF16(IDS_SETTINGS_SITE_OFFICE_DOWNLOAD_FILE),\n      l10n_util::GetStringUTF16(\n#if BUILDFLAG(ENABLE_EMBEDDED_BROWSER_WEBVIEW)\n        edge_webview2::IsEdgeWebViewProcess()\n            ? IDS_OFFICE_VIEWER_INFOBAR_TEXT_EDGE_WEBVIEW2\n            :\n#endif\n            IDS_OFFICE_VIEWER_INFOBAR_TEXT),\n      std::u16string(),\n      GURL(),\n      &kProductColorIcon,\n      base::DoNothing(),\n      base::DoNothing()};\n  config.on_dismiss =\n      base::BindRepeating(&OfficeInfoBarDelegateHelper::OnDismiss);\n  config.on_accept =\n      base::BindRepeating(&OfficeInfoBarDelegateHelper::OnDownloadFile, url);\n  CreateInfobar(config, web_contents);\n  RecordInfobarUserAction(OfficeViewerInfobarUserAction::kDefaultInfobarShown);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays an infobar for downloading office files and handles user actions.","ghc_query":"display infobar download office file handle user action"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\extensions\\icon_with_badge_image_source.cc:284-319","function":"IconWithBadgeImageSource::PaintBlockedActionDecoration","codesnippet":"{\n  // TODO(elainechien): This looks like it's trying to match the GM2 elevation\n  // +2 spec.  Move to ShadowValue::MakeShadowValues() and systematize.\n\n  // To match the CSS notion of blur (spread outside the bounding box) to the\n  // Skia notion of blur (spread outside and inside the bounding box), we have\n  // to double the CSS-based blur values.\n  constexpr int kBlurCorrection = 2;\n\n  const ui::ColorProvider* color_provider = get_color_provider_callback_.Run();\n  const gfx::ShadowValue key_shadow(\n      gfx::Vector2d(0, 1), kBlurCorrection * 2 /*blur*/,\n      color_provider->GetColor(kColorExtensionIconDecorationKeyShadow));\n\n  const gfx::ShadowValue ambient_shadow(\n      gfx::Vector2d(0, 2), kBlurCorrection * 6 /*blur*/,\n      color_provider->GetColor(kColorExtensionIconDecorationAmbientShadow));\n\n  const float blocked_action_badge_radius = GetBlockedActionBadgeRadius();\n\n  // Sanity checking.\n  const gfx::Rect icon_rect = GetIconAreaRect();\n  DCHECK_LE(1.5 * blocked_action_badge_radius, icon_rect.width());\n  DCHECK_EQ(icon_rect.width(), icon_rect.height());\n\n  cc::PaintFlags paint_flags;\n  paint_flags.setStyle(cc::PaintFlags::kFill_Style);\n  paint_flags.setAntiAlias(true);\n  paint_flags.setColor(\n      color_provider->GetColor(kColorExtensionIconDecorationBackground));\n  paint_flags.setLooper(\n      gfx::CreateShadowDrawLooper({key_shadow, ambient_shadow}));\n\n  canvas->DrawCircle(gfx::PointF(icon_rect.CenterPoint()),\n                     blocked_action_badge_radius, paint_flags);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Draws a circle with shadow effects on a canvas using specified color and radius.","ghc_query":"draw circle shadow effect canvas color radius"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\notifications\\non_persistent_notification_handler.cc:96-132","function":"NonPersistentNotificationHandler::DidDispatchClickEvent","codesnippet":"{\n#if !BUILDFLAG(IS_ANDROID)\n  // Non-persistent notifications are able to outlive the document that created\n  // them. In such cases the JavaScript event handler might not be available\n  // when the notification is interacted with. Launch a new tab for the\n  // notification's |origin| instead, and close the activated notification. Not\n  // applicable to Android as non-persistent notifications are not available.\n  if (!success) {\n#if BUILDFLAG(ENABLE_EMBEDDED_BROWSER_WEBVIEW)\n    // Do not launch a new tab for WebView2 as we do not have a webview to raise\n    // NewWindowRequested event.\n    if (!edge_webview2::IsEdgeWebViewProcess()) {\n      NavigateParams params(profile, origin, ui::PAGE_TRANSITION_LINK);\n\n      params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;\n      params.window_action = NavigateParams::SHOW_WINDOW;\n      Navigate(&params);\n    }\n#else\n    NavigateParams params(profile, origin, ui::PAGE_TRANSITION_LINK);\n\n    params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;\n    params.window_action = NavigateParams::SHOW_WINDOW;\n    Navigate(&params);\n#endif  // BUILDFLAG(ENABLE_EMBEDDED_BROWSER_WEBVIEW)\n    // Close the |notification_id| as the user has explicitly acknowledged it.\n    PlatformNotificationServiceFactory::GetForProfile(profile)\n        ->CloseNotification(notification_id);\n  }\n#endif  // !BUILDFLAG(IS_ANDROID)\n\n  std::move(completed_closure).Run();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles non-persistent notification interactions by opening a new tab for the notification's origin and closing the notification, except on Android.","ghc_query":"handle non-persistent notification interaction open tab origin close except android"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\safe_browsing\\content\\browser\\client_side_phishing_model.cc:670-714","function":"ClientSidePhishingModel::OnGetOverridenModelData","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  const std::string& model_data = model_and_tflite.first;\n  base::File tflite_model = std::move(model_and_tflite.second);\n  if (model_data.empty()) {\n    VLOG(2) << \"Overriden model data is empty\";\n    return;\n  }\n\n  switch (model_type) {\n    case CSDModelType::kFlatbuffer: {\n      flatbuffers::Verifier verifier(\n          reinterpret_cast<const uint8_t*>(model_data.data()),\n          model_data.length());\n      if (!flat::VerifyClientSideModelBuffer(verifier)) {\n        VLOG(2)\n            << \"Overriden model data is not a valid ClientSideModel flatbuffer\";\n        return;\n      }\n      mapped_region_ =\n          base::ReadOnlySharedMemoryRegion::Create(model_data.length());\n      if (!mapped_region_.IsValid()) {\n        VLOG(2) << \"Could not create shared memory region for flatbuffer\";\n        return;\n      }\n      mapped_region_.mapping.GetMemoryAsSpan<char>().copy_prefix_from(\n          model_data);\n      model_type_ = model_type;\n      break;\n    }\n    case CSDModelType::kNone:\n      NOTREACHED();\n  }\n\n  if (tflite_model.IsValid()) {\n    visual_tflite_model_ = std::move(tflite_model);\n  }\n\n  VLOG(0) << \"Model overridden successfully\";\n\n  content::GetUIThreadTaskRunner({})->PostTask(\n      FROM_HERE, base::BindOnce(&ClientSidePhishingModel::NotifyCallbacksOnUI,\n                                weak_ptr_factory_.GetWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates and overrides a model with flatbuffer data and updates the model type and shared memory region.","ghc_query":"validate override model flatbuffer data update type shared memory region"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\update_client\\background_downloader_win.cc:764-798","function":"BackgroundDownloader::CreateOrOpenJob","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(com_sequence_checker_);\n  CheckIsMta();\n\n  std::vector<Microsoft::WRL::ComPtr<IBackgroundCopyJob>> jobs;\n  HRESULT hr = FindBitsJobIf(\n      [&url](Microsoft::WRL::ComPtr<IBackgroundCopyJob> job) {\n        return JobFileUrlEqualPredicate(job, url);\n      },\n      bits_manager_, &jobs);\n  if (SUCCEEDED(hr) && !jobs.empty()) {\n    *job = jobs.front();\n    return S_FALSE;\n  }\n\n  Microsoft::WRL::ComPtr<IBackgroundCopyJob> local_job;\n\n  GUID guid = {0};\n  hr = bits_manager_->CreateJob(kJobName, BG_JOB_TYPE_DOWNLOAD, &guid,\n                                &local_job);\n  if (FAILED(hr)) {\n    CleanupJob(local_job);\n    return hr;\n  }\n\n  hr = InitializeNewJob(local_job, url);\n  if (FAILED(hr)) {\n    CleanupJob(local_job);\n    return hr;\n  }\n\n  *job = local_job;\n  return S_OK;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates or retrieves a background copy job based on a specified URL.","ghc_query":"create retrieve background copy job url download"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\predictors\\autocomplete_action_predictor.cc:497-521","function":"AutocompleteActionPredictor::DeleteOldEntries","codesnippet":"{\n  CHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n  DCHECK(!profile_->IsOffTheRecord());\n  DCHECK(!initialized_);\n  DCHECK(table_.get());\n\n  std::vector<AutocompleteActionPredictorTable::Row::Id> ids_to_delete;\n  DeleteOldIdsFromCaches(url_db, &ids_to_delete);\n\n  if (db_cache_.size() > kMaximumCacheSize) {\n    DeleteLowestConfidenceRowsFromCaches(db_cache_.size() - kMaximumCacheSize,\n                                         &ids_to_delete);\n  }\n\n  if (!ids_to_delete.empty()) {\n    table_->GetTaskRunner()->PostTask(\n        FROM_HERE, base::BindOnce(&AutocompleteActionPredictorTable::DeleteRows,\n                                  table_, std::move(ids_to_delete)));\n  }\n\n  FinishInitialization();\n  if (incognito_predictor_) {\n    incognito_predictor_->CopyFromMainProfile();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes the autocomplete predictor and manages cache size by deleting old or low-confidence entries.","ghc_query":"initialize autocomplete predictor manage cache size delete old low-confidence entries"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\signin\\batch_upload_handler.cc:141-206","function":"BatchUploadHandler::SaveToAccount","codesnippet":"{\n  CHECK_EQ(ids_to_move.size(), local_data_description_list_.size());\n  CHECK_EQ(ids_to_move.size(), internal_data_item_id_mapping_list_.size());\n\n  // Convert `ids_to_move` ids from `int32_t` to\n  // `LocalDataItemModel::DataId` using\n  // `internal_data_item_id_mapping_list_`.\n  std::map<syncer::DataType, std::vector<syncer::LocalDataItemModel::DataId>>\n      ret_ids_to_move;\n  for (size_t i = 0; i < ids_to_move.size(); ++i) {\n    const std::map<InternalId, syncer::LocalDataItemModel::DataId>&\n        internal_data_item_id_mapping = internal_data_item_id_mapping_list_[i];\n    CHECK_LE(ids_to_move[i].size(), internal_data_item_id_mapping.size());\n\n    std::vector<syncer::LocalDataItemModel::DataId> section_ids;\n    std::ranges::transform(\n        ids_to_move[i], std::back_inserter(section_ids),\n        [&internal_data_item_id_mapping](int32_t id) {\n          BatchUploadHandler::InternalId internal_item_id =\n              BatchUploadHandler::InternalId(id);\n          CHECK(internal_data_item_id_mapping.contains(internal_item_id));\n          return internal_data_item_id_mapping.at(internal_item_id);\n        });\n    ret_ids_to_move.insert_or_assign(local_data_description_list_[i].type,\n                                     section_ids);\n  }\n\n#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)\n  // Only show reauth if passwords are selected to be saved. Passwords is the\n  // only data type that needs authentication.\n  auto it = ret_ids_to_move.find(syncer::PASSWORDS);\n  bool should_show_reauth = it != ret_ids_to_move.end() && !it->second.empty();\n#endif\n\n  base::OnceCallback<void(bool)> on_save_to_account_ready =\n      base::BindOnce(&BatchUploadHandler::OnSaveToAccountRequestReady,\n                     base::Unretained(this), std::move(ret_ids_to_move));\n\n#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)\n  if (should_show_reauth) {\n    // Disable all inputs in the view during reauth.\n    allow_web_view_input_callback_.Run(false);\n\n    device_reauth::DeviceAuthParams params(\n        base::Seconds(0),\n        device_reauth::DeviceAuthSource::kSettingsBatchUpload);\n\n    device_authenticator_ = ChromeDeviceAuthenticatorFactory::GetForProfile(\n        browser_->profile(),\n        browser_->tab_strip_model()\n            ->GetActiveWebContents()\n            ->GetTopLevelNativeWindow(),\n        params);\n\n    // Show authentication before proceeding with the save to account.\n    device_authenticator_->AuthenticateWithMessage(\n        l10n_util::GetStringUTF16(\n            IDS_PASSWORDS_PAGE_COPY_AUTHENTICATION_PROMPT_BIOMETRIC_SUFFIX),\n        std::move(on_save_to_account_ready));\n    return;\n  }\n#endif\n\n  // Proceed directly without reauth and allowing data to be saved.\n  std::move(on_save_to_account_ready).Run(true);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Converts and processes data IDs for saving, with optional authentication for password data on certain platforms.","ghc_query":"convert process data id save authentication password platform"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_media_controls\\taskbar\\utils.cc:108-133","function":"SetImageList","codesnippet":"{\n  auto taskbar_list = GetTaskbarList();\n  if (!taskbar_list) {\n    return;\n  }\n  std::vector<const gfx::VectorIcon*> icons = {\n      &vector_icons::kEdgePreviousTrackTaskbarIcon,\n      &vector_icons::kEdgePauseTaskbarIcon,\n      &vector_icons::kEdgePlayTaskbarIcon,\n      &vector_icons::kEdgeNextTrackTaskbarIcon,\n      &vector_icons::kEdgeSeekBackwardIcon,\n      &vector_icons::kEdgeSeekForwardIcon,\n      &vector_icons::kCloseIcon,\n      &vector_icons::kEdgeEnterPictureInPictureIcon,\n      &vector_icons::kEdgeExitPictureInPictureIcon};\n\n  int size = GetSystemMetrics(SM_CXICON);\n  HIMAGELIST himl = GetHImageListFromVectorIcons(\n      icons, size, dark_mode_enabled ? SK_ColorWHITE : SK_ColorBLACK);\n  if (!favicon_bitmap.empty()) {\n    base::win::ScopedGDIObject<HICON> icon =\n        GetHICONFromBitmap(favicon_bitmap, gfx::Size(size, size));\n    ImageList_AddIcon(himl, icon.get());\n  }\n  taskbar_list->ThumbBarSetImageList(hwnd, himl);\n  ImageList_Destroy(himl);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets taskbar icons for media control and picture-in-picture features.","ghc_query":"set taskbar icon media control picture-in-picture pip"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\first_run\\first_run_windows_insiders.cc:237-327","function":"ShouldShowWhatsNewPage","codesnippet":"{\n  PrefService* pref = nullptr;\n  if (g_browser_process && (g_browser_process->local_state() != nullptr)) {\n    pref = g_browser_process->local_state();\n  } else {\n    VLOG(1) << \"Browser Process Preference is null\";\n    return false;\n  }\n\n  const bool show_fre = ShouldShowFREToUser(profile);\n  std::string browser_previous_version_str =\n      pref->GetString(prefs::kBrowserBuildVersion);\n  const std::string current_version_str =\n      std::string(version_info::GetVersionNumber());\n\n  // The Whats New or Welcome page will be part of\n  // GetOnboardingTabs when FRE is shown.\n  if (show_fre && browser_previous_version_str.empty()) {\n    pref->SetString(prefs::kBrowserBuildVersion, current_version_str);\n    pref->SetString(prefs::kLastSeenWhatsNewPageVersion, current_version_str);\n    pref->SetString(prefs::kBrowserVersionOfLastSeenWhatsNew,\n                    current_version_str);\n    return false;\n  }\n\n  if (show_fre || no_first_run)\n    return false;\n\n  const base::Version current_version(current_version_str);\n  bool is_browser_upgraded =\n      IsBrowserUpgraded(current_version, browser_previous_version_str);\n\n  if (from_try_edge_again) {\n    pref->SetString(prefs::kBrowserVersionOfLastSeenWhatsNew,\n                    current_version_str);\n    if (is_browser_upgraded)\n      pref->SetString(prefs::kBrowserBuildVersion, current_version_str);\n    return true;\n  }\n\n  if (base::FeatureList::IsEnabled(features::edge::kEdgeOnRampShowWhatsNew,\n                                   /*trigger_usage_on_check=*/true)) {\n    const std::string whnew_last_seen_browser_version_str =\n        pref->GetString(prefs::kBrowserVersionOfLastSeenWhatsNew);\n    bool is_whnew_shown_for_current_ver = false;\n    if (!whnew_last_seen_browser_version_str.empty()) {\n      const base::Version whnew_last_seen_browser_version(\n          whnew_last_seen_browser_version_str);\n      is_whnew_shown_for_current_ver =\n          whnew_last_seen_browser_version.IsValid() &&\n          (whnew_last_seen_browser_version.CompareTo(current_version) == 0);\n    }\n\n    if (!is_whnew_shown_for_current_ver) {\n      if (is_browser_upgraded)\n        pref->SetString(prefs::kBrowserBuildVersion, current_version_str);\n      const std::string last_seen_whats_new_browser_version_str =\n          pref->GetString(prefs::kLastSeenWhatsNewPageVersion);\n\n      const std::string version_param_str =\n          base::GetFieldTrialParamValueByFeature(\n              features::edge::kEdgeOnRampShowWhatsNew,\n              features::edge::kBrowserVersionParamName);\n\n      // Always show whats new on browser upgrade if configured version param\n      // from ECS is empty.\n      bool show_on_browser_upgrade =\n          version_param_str.empty() && is_browser_upgraded;\n      if (show_on_browser_upgrade ||\n          IsWhatsNewPageUpdatedFromServer(\n              version_param_str, current_version,\n              last_seen_whats_new_browser_version_str,\n              whnew_last_seen_browser_version_str)) {\n        if (!version_param_str.empty())\n          pref->SetString(prefs::kLastSeenWhatsNewPageVersion,\n                          version_param_str);\n        LogWhatsNewLaunchMetric(WhatsNewLaunchState::kOpened);\n        pref->SetString(prefs::kBrowserVersionOfLastSeenWhatsNew,\n                        current_version_str);\n        return true;\n      } else {\n        LogWhatsNewLaunchMetric(\n            WhatsNewLaunchState::kNotOpenedAsLatestWhatsNewNotAvailable);\n      }\n    }\n  } else if (is_browser_upgraded) {\n    LogWhatsNewLaunchMetric(WhatsNewLaunchState::kNotOpenedOnBrowserUpgrade);\n  }\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines whether to show the \"What's New\" page based on browser version and user settings.","ghc_query":"determine show what's new page browser version user settings"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\privacy_budget\\identifiability_study_state.cc:548-573","function":"IdentifiabilityStudyState::InitFromPrefs","codesnippet":"{\n  if (!settings_.enabled()) [[unlikely]] {\n    // Nothing to do if the study is not active. However it is possible that\n    // this client has switched from active to inactive, in which case we should\n    // nuke any persisted data.\n    ResetPersistedState();\n    return;\n  }\n\n  // Changing the generation nukes persisted state.\n  auto persisted_generation =\n      pref_service_->GetInteger(prefs::kPrivacyBudgetGeneration);\n  if (persisted_generation != generation_) {\n    ResetPersistedState();\n    return;\n  }\n\n  if (settings_.IsUsingAssignedBlockSampling()) {\n    InitStateForAssignedBlockSampling();\n  }\n\n  if (settings_.IsUsingRandomSampling()) {\n    InitStateForRandomSurfaceSampling();\n  }\n\n  CheckInvariants();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes or resets state based on privacy budget settings and sampling methods.","ghc_query":"initialize reset privacy budget settings sampling method state"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\win\\installer_downloader\\installer_downloader_model_impl.cc:103-146","function":"InstallerDownloaderModelImpl::StartDownload","codesnippet":"{\n  CHECK(url.is_valid());\n\n  static constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotation =\n      net::DefineNetworkTrafficAnnotation(\"windows_installer_downloader\",\n                                          R\"(semantics {\n          sender: \"Windows Installer Downloader\"\n          description:\n            \"Download Chrome installer to the user OneDrive folder on \"\n            \"their consent.\"\n          trigger: \"Once, when the user accept the download request.\"\n          data: \"None.\"\n          destination: GOOGLE_OWNED_SERVICE\n          internal {\n            contacts {\n            owners: \"//chrome/browser/win/installer_downloader/OWNERS\"\n          }\n        }\n        last_reviewed: \"2025-05-01\n      }\n      policy {\n        cookies_allowed: NO\n        setting:\n          \"Users can controller this feature by closing the Installer\"\n          \"Downloader Infobar.\"\n    })\");\n\n  auto params = std::make_unique<download::DownloadUrlParameters>(\n      url, kTrafficAnnotation);\n  params->set_file_path(destination);\n  params->set_transient(true);\n  params->set_download_source(download::DownloadSource::INTERNAL_API);\n\n  // The InstallerDownloaderController that hold this model is a browser global\n  // feature. Therefore, it is safe to use base::Unretained here.\n  params->set_callback(\n      base::BindOnce(&InstallerDownloaderModelImpl::OnInstallerDownloadCreated,\n                     base::Unretained(this), std::move(completion_callback)));\n\n  download_manager.DownloadUrl(std::move(params));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Downloads the Chrome installer to the user's OneDrive folder upon consent.","ghc_query":"download chrome installer user onedrive folder consent"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_screenshot\\core\\browser\\screenshot_utils_win.cc:192-233","function":"ScreenshotUtilsWin::GetInnerFrames","codesnippet":"{\n  std::vector<ScreenshotWindow::InnerFrame> frames;\n  std::map<HWND, int> hwnd_2_index;\n\n  for (size_t i = 0; i < pages.size(); i++) {\n    auto* page = pages[i];\n    if (page->NativeWindow()) {\n      HWND hwnd = views::HWNDForNativeWindow(page->NativeWindow());\n      hwnd_2_index[hwnd] = i;\n    }\n  }\n\n  for (auto& src : list) {\n    RECT rect;\n    HWND id = reinterpret_cast<HWND>(src.id);\n    auto result = DwmGetWindowAttribute(id, DWMWA_EXTENDED_FRAME_BOUNDS, &rect,\n                                        sizeof(rect));\n    if (result != S_OK) {\n      continue;\n    }\n    auto item = hwnd_2_index.find(id);\n    if (item != hwnd_2_index.end()) {\n      auto* page = pages[item->second];\n      auto frame = page->ContentFrame(WebContentSrc::Normal);\n      if (!frame.IsEmpty()) {\n        frame.page_id = kNormalWebContentPrefix + item->second;\n        frames.push_back(std::move(frame));\n      }\n      frame = page->ContentFrame(WebContentSrc::Split);\n      if (!frame.IsEmpty()) {\n        frame.page_id = kSplitWebContentPrefix + item->second;\n        frames.push_back(std::move(frame));\n      }\n    }\n    ScreenshotWindow::InnerFrame frame;\n    frame.scaled = false;\n    frame.SetByBounds(rect.left, rect.top, rect.right, rect.bottom);\n    frames.push_back(std::move(frame));\n  }\n  return frames;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a list of frames from window attributes and page content.","ghc_query":"generate frame list window attribute page content iframe"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_auth\\edge_dma_sso_prefs.cc:37-87","function":"SetDataForAccount","codesnippet":"{\n  if (!local_state_pref_service) {\n    return;\n  }\n\n  CHECK(keys.size() == values.size());\n\n  std::string oid = edge_account_ids.GetOid().value_or(std::string{});\n  std::string cid = edge_account_ids.GetCid().value_or(std::string{});\n  ScopedListPrefUpdate update(local_state_pref_service, pref_path_of_list);\n  base::Value::List& list = update.Get();\n  bool exist = false;\n\n  // Try to update existing account data.\n  for (auto& item : list) {\n    if (item.is_dict()) {\n      base::Value::Dict& dict = item.GetDict();\n      const std::string* account_id_value = dict.FindString(kAccountID);\n      const std::string* oid_value = dict.FindString(kOID);\n      const std::string* cid_value = dict.FindString(kCID);\n\n      if (IsSameAccountId(edge_account_ids.account_id, oid, cid,\n                          account_id_value, oid_value, cid_value)) {\n        exist = true;\n        for (size_t i = 0; i < keys.size(); ++i) {\n          dict.Set(keys[i], values[i].Clone());\n        }\n        dict.Set(kAccountID, edge_account_ids.account_id);\n        dict.Set(kOID, oid);\n        dict.Set(kCID, cid);\n        break;\n      }\n    }\n  }\n\n  // If account data does not exist, add new one.\n  if (!exist) {\n    base::Value::Dict dict;\n    dict.Set(kAccountID, edge_account_ids.account_id);\n    for (size_t i = 0; i < keys.size(); ++i) {\n      dict.Set(keys[i], values[i].Clone());\n    }\n    dict.Set(kOID, oid);\n    dict.Set(kCID, cid);\n    list.Append(std::move(dict));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates or adds account data in a preference list.","ghc_query":"update add account data preference list profile"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\utility\\importer\\edge_chrome_takeout_importer_autofill_parser.cc:58-96","function":"AutofillProfileJSONDataArray::AutofillProfileJSONData::\n    RegisterJSONConverter","codesnippet":"{\n  converter->RegisterStringField(\"address_home_country\",\n                                 &AutofillProfileJSONData::country_code);\n  converter->RegisterStringField(\"address_home_street_address\",\n                                 &AutofillProfileJSONData::street_address);\n  converter->RegisterStringField(\"address_home_zip\",\n                                 &AutofillProfileJSONData::zipcode);\n  converter->RegisterStringField(\"address_home_language_code\",\n                                 &AutofillProfileJSONData::language_code);\n  converter->RegisterStringField(\"company_name\",\n                                 &AutofillProfileJSONData::company_name);\n  converter->RegisterStringField(\"guid\", &AutofillProfileJSONData::guid);\n  converter->RegisterStringField(\"address_home_city\",\n                                 &AutofillProfileJSONData::city);\n  converter->RegisterStringField(\"origin\", &AutofillProfileJSONData::origin);\n  converter->RegisterIntField(\"use_count\", &AutofillProfileJSONData::use_count);\n  converter->RegisterStringField(\"address_home_state\",\n                                 &AutofillProfileJSONData::state);\n  converter->RegisterStringField(\"address_home_dependent_locality\",\n                                 &AutofillProfileJSONData::dependent_locality);\n  converter->RegisterStringField(\"address_home_sorting_code\",\n                                 &AutofillProfileJSONData::sorting_code);\n\n  converter->RegisterRepeatedString(\"name_full\",\n                                    &AutofillProfileJSONData::full_name);\n  converter->RegisterRepeatedString(\"name_middle\",\n                                    &AutofillProfileJSONData::middle_name);\n  converter->RegisterRepeatedString(\"name_last\",\n                                    &AutofillProfileJSONData::last_name);\n  converter->RegisterRepeatedString(\"name_first\",\n                                    &AutofillProfileJSONData::first_name);\n  converter->RegisterRepeatedString(\"email_address\",\n                                    &AutofillProfileJSONData::email);\n  converter->RegisterRepeatedString(\"phone_home_whole_number\",\n                                    &AutofillProfileJSONData::phone);\n  converter->RegisterCustomValueField<base::Time>(\n      \"use_date\", &AutofillProfileJSONData::use_date, &GetTimeFromValue);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Registers various fields and repeated strings for autofill profile data conversion.","ghc_query":"register field string autofill profile data conversion"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\mac\\microsoft_edge\\health_monitor\\install_source_mapping.cc:11-213","function":"GetInstallSource","codesnippet":"{\n  switch (install_source) {\n    case 1:\n      return InstallSource::kOrganic;\n    case 2:\n      return InstallSource::kSource2;\n    case 3:\n      return InstallSource::kSource3;\n    case 4:\n      return InstallSource::kSource4;\n    case 5:\n      return InstallSource::kSource5;\n    case 6:\n      return InstallSource::kSource6;\n    case 7:\n      return InstallSource::kSource7;\n    case 8:\n      return InstallSource::kSource8;\n    case 9:\n      return InstallSource::kSource9;\n    case 10:\n      return InstallSource::kSource10;\n    case 11:\n      return InstallSource::kSource11;\n    case 12:\n      return InstallSource::kSource12;\n    case 13:\n      return InstallSource::kSource13;\n    case 14:\n      return InstallSource::kSource14;\n    case 15:\n      return InstallSource::kSource15;\n    case 16:\n      return InstallSource::kSource16;\n    case 17:\n      return InstallSource::kSource17;\n    case 18:\n      return InstallSource::kSource18;\n    case 19:\n      return InstallSource::kSource19;\n    case 20:\n      return InstallSource::kSource20;\n    case 21:\n      return InstallSource::kSource21;\n    case 22:\n      return InstallSource::kSource22;\n    case 23:\n      return InstallSource::kSource23;\n    case 24:\n      return InstallSource::kSource24;\n    case 25:\n      return InstallSource::kSource25;\n    case 26:\n      return InstallSource::kSource26;\n    case 27:\n      return InstallSource::kSource27;\n    case 28:\n      return InstallSource::kSource28;\n    case 29:\n      return InstallSource::kSource29;\n    case 30:\n      return InstallSource::kSource30;\n    case 31:\n      return InstallSource::kSource31;\n    case 32:\n      return InstallSource::kSource32;\n    case 33:\n      return InstallSource::kSource33;\n    case 34:\n      return InstallSource::kSource34;\n    case 35:\n      return InstallSource::kSource35;\n    case 36:\n      return InstallSource::kSource36;\n    case 37:\n      return InstallSource::kSource37;\n    case 38:\n      return InstallSource::kSource38;\n    case 39:\n      return InstallSource::kSource39;\n    case 40:\n      return InstallSource::kSource40;\n    case 41:\n      return InstallSource::kSource41;\n    case 42:\n      return InstallSource::kSource42;\n    case 43:\n      return InstallSource::kSource43;\n    case 44:\n      return InstallSource::kSource44;\n    case 45:\n      return InstallSource::kSource45;\n    case 46:\n      return InstallSource::kSource46;\n    case 47:\n      return InstallSource::kSource47;\n    case 48:\n      return InstallSource::kSource48;\n    case 49:\n      return InstallSource::kSource49;\n    case 50:\n      return InstallSource::kSource50;\n    case 51:\n      return InstallSource::kSource51;\n    case 52:\n      return InstallSource::kSource52;\n    case 53:\n      return InstallSource::kSource53;\n    case 54:\n      return InstallSource::kSource54;\n    case 55:\n      return InstallSource::kSource55;\n    case 56:\n      return InstallSource::kSource56;\n    case 57:\n      return InstallSource::kSource57;\n    case 58:\n      return InstallSource::kSource58;\n    case 59:\n      return InstallSource::kSource59;\n    case 60:\n      return InstallSource::kSource60;\n    case 61:\n      return InstallSource::kSource61;\n    case 62:\n      return InstallSource::kSource62;\n    case 63:\n      return InstallSource::kSource63;\n    case 64:\n      return InstallSource::kSource64;\n    case 65:\n      return InstallSource::kSource65;\n    case 66:\n      return InstallSource::kSource66;\n    case 67:\n      return InstallSource::kSource67;\n    case 68:\n      return InstallSource::kSource68;\n    case 69:\n      return InstallSource::kSource69;\n    case 70:\n      return InstallSource::kSource70;\n    case 71:\n      return InstallSource::kSource71;\n    case 72:\n      return InstallSource::kSource72;\n    case 73:\n      return InstallSource::kSource73;\n    case 74:\n      return InstallSource::kSource74;\n    case 75:\n      return InstallSource::kSource75;\n    case 76:\n      return InstallSource::kSource76;\n    case 77:\n      return InstallSource::kSource77;\n    case 78:\n      return InstallSource::kSource78;\n    case 79:\n      return InstallSource::kSource79;\n    case 80:\n      return InstallSource::kSource80;\n    case 81:\n      return InstallSource::kSource81;\n    case 82:\n      return InstallSource::kSource82;\n    case 83:\n      return InstallSource::kSource83;\n    case 84:\n      return InstallSource::kSource84;\n    case 85:\n      return InstallSource::kSource85;\n    case 86:\n      return InstallSource::kSource86;\n    case 87:\n      return InstallSource::kSource87;\n    case 88:\n      return InstallSource::kSource88;\n    case 89:\n      return InstallSource::kSource89;\n    case 90:\n      return InstallSource::kSource90;\n    case 91:\n      return InstallSource::kSource91;\n    case 92:\n      return InstallSource::kSource92;\n    case 93:\n      return InstallSource::kSource93;\n    case 94:\n      return InstallSource::kSource94;\n    case 95:\n      return InstallSource::kSource95;\n    case 96:\n      return InstallSource::kSource96;\n    case 97:\n      return InstallSource::kSource97;\n    case 98:\n      return InstallSource::kSource98;\n    case 99:\n      return InstallSource::kSource99;\n    default:\n      return InstallSource::kUnknown;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps an integer to a corresponding install source or returns unknown if unmatched.","ghc_query":"map integer install source enum unknown conversion matcher"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_wallet\\core\\browser\\express_checkout\\trigger\\filters\\topsite_filters\\topsite_visible_check_filter.cc:152-196","function":"TopSiteVisibleCheckFilter::OnElementsQueryDone","codesnippet":"{\n  if (!context) {\n    return;\n  }\n\n  std::vector<autofill::EdgeQueriedElementData> trigger_elements;\n  std::vector<autofill::EdgeQueriedElementData> coupon_elements;\n  std::vector<autofill::EdgeQueriedElementData> merchant_saved_info_elements;\n  std::vector<autofill::EdgeQueriedElementData> dynamic_filter_elements;\n  for (const auto& element : elements) {\n    if (trigger_selectors.find(element.selector) != trigger_selectors.end()) {\n      trigger_elements.emplace_back(element);\n    } else if (coupon_element_selectors.find(element.selector) !=\n               coupon_element_selectors.end()) {\n      coupon_elements.emplace_back(element);\n    } else if (std::find(merchant_saved_info_selectors.begin(),\n                         merchant_saved_info_selectors.end(),\n                         element.selector) !=\n               merchant_saved_info_selectors.end()) {\n      merchant_saved_info_elements.emplace_back(element);\n    } else if (std::find(dynamic_filter_selectors.begin(),\n                         dynamic_filter_selectors.end(),\n                         element.selector) != dynamic_filter_selectors.end()) {\n      dynamic_filter_elements.emplace_back(element);\n    }\n  }\n\n  context->coupon_elements = coupon_elements;\n  context->merchant_saved_info_elements = merchant_saved_info_elements;\n  context->coupon_selectors = coupon_selectors;\n  context->dynamic_filter_elements = dynamic_filter_elements;\n  context->country_dropdown_list = GetCountryDropdownList(context);\n  CheckFormVisibleStatus(context, trigger_elements);\n\n  if (context->event_queue_interface) {\n    context->event_queue_interface->AddTriggerEvent(\n        edge_wallet::TriggerEvent::kFormParse, true);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Categorizes elements based on selectors and updates the context with categorized data.","ghc_query":"categorize element selector update context data document html css"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\tabs\\saved_tab_groups\\saved_tab_group_model_listener.cc:184-247","function":"SavedTabGroupModelListener::TabGroupedStateChanged","codesnippet":"{\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  if (tab_groups::IsEdgeSavedTabGroupEnabled(profile_) && new_local_group_id) {\n    // If the change came from a workspace window, disconnect the group and\n    // never track it.\n    const Browser* const browser = SavedTabGroupUtils::GetBrowserWithTabGroupId(\n        new_local_group_id.value());\n    if (browser && browser->workspace_session().has_value() &&\n        local_tab_group_listeners_.contains(new_local_group_id.value())) {\n      DisconnectLocalTabGroup(new_local_group_id.value(),\n                              ClosingSource::kUnknown);\n      base::UmaHistogramEnumeration(\n          SavedTabGroupKeyedService::kUsageInWorkspaceHistogram,\n          SavedTabGroupKeyedService::UsageInWorkspace::kGroupContentsChange);\n      return;\n    }\n  }\n#endif\n  // Remove `contents` from its current saved group, if it's in one.\n  for (auto& [local_group_id, listener] : local_tab_group_listeners_) {\n    if (local_group_id != new_local_group_id) {\n      if (listener.MaybeRemoveWebContentsFromLocal(tab->GetContents()) ==\n          LocalTabGroupListener::Liveness::kGroupDeleted) {\n        // If this emptied the group, the saved group was removed, so we must\n        // stop listening to `local_group_id`.\n        DisconnectLocalTabGroup(local_group_id, ClosingSource::kUnknown);\n        // Not only did we find our old group, we also concurrently modified the\n        // data structure we're iterating over. Abort, abort.\n        break;\n      }\n    }\n  }\n\n  // Add it to its new group.\n  if (new_local_group_id.has_value() &&\n      base::Contains(local_tab_group_listeners_, new_local_group_id.value())) {\n    LocalTabGroupListener& listener =\n        local_tab_group_listeners_.at(new_local_group_id.value());\n    const Browser* const browser = SavedTabGroupUtils::GetBrowserWithTabGroupId(\n        new_local_group_id.value());\n    CHECK(browser);\n    listener.AddTabFromLocal(tab, browser->tab_strip_model(), index);\n  }\n\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  if (tab_groups::IsEdgeSavedTabGroupEnabled(profile_)) {\n    if (!new_local_group_id) {\n      // Session-base compatible logic, we need to clear\n      // SessionTab.tab_sync_guid and webcontents.tab_sync_guid when ungroup\n      tab->GetContents()->EdgeSetTabSyncGuid(base::Uuid());\n      sessions::SessionTab* session_tab =\n          SavedTabGroupUtils::FindSessionTabFromWebContents(profile_, tab->GetContents());\n      if (session_tab && session_tab->tab_sync_guid.has_value()) {\n        session_tab->tab_sync_guid = std::nullopt;\n      }\n    }\n  }\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Manages tab group membership changes, including adding, removing, and disconnecting tabs from groups.","ghc_query":"manage tab group membership change add remove disconnect"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\ash\\settings\\pages\\power\\device_power_handler.cc:368-389","function":"PowerHandler::SendPowerSources","codesnippet":"{\n  const std::optional<power_manager::PowerSupplyProperties>& proto =\n      PowerManagerClient::Get()->GetLastStatus();\n  DCHECK(proto);\n  base::Value::List sources_list;\n  for (int i = 0; i < proto->available_external_power_source_size(); i++) {\n    const auto& source = proto->available_external_power_source(i);\n    sources_list.Append(\n        base::Value::Dict()\n            .Set(\"id\", source.id())\n            .Set(\"is_dedicated_charger\", source.active_by_default())\n            .Set(\"description\",\n                 l10n_util::GetStringUTF16(PowerSourceToDisplayId(source))));\n  }\n\n  FireWebUIListener(\n      \"power-sources-changed\", sources_list,\n      base::Value(proto->external_power_source_id()),\n      base::Value(proto->external_power() ==\n                  power_manager::PowerSupplyProperties_ExternalPower_USB),\n      base::Value(proto->external_power() ==\n                  power_manager::PowerSupplyProperties_ExternalPower_AC));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Notifies the UI of changes in available power sources and their details.","ghc_query":"notify UI power source change battery status observer"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\crash\\core\\app\\crashpad_android.cc:320-349","function":"GetHandlerTrampoline","codesnippet":"{\n  // The linker doesn't support loading executables passed on its command\n  // line until Q.\n  if (base::android::BuildInfo::GetInstance()->sdk_int() <\n      base::android::SDK_VERSION_Q) {\n    return false;\n  }\n\n  Dl_info info;\n  if (dladdr(reinterpret_cast<void*>(&GetHandlerTrampoline), &info) == 0 ||\n      dlsym(dlopen(info.dli_fname, RTLD_NOLOAD | RTLD_LAZY),\n            \"CrashpadHandlerMain\") == nullptr) {\n    return false;\n  }\n\n  std::string local_handler_library(info.dli_fname);\n\n  size_t libdir_end = local_handler_library.rfind('/');\n  if (libdir_end == std::string::npos) {\n    return false;\n  }\n\n  std::string local_handler_trampoline(local_handler_library, 0,\n                                       libdir_end + 1);\n  local_handler_trampoline += \"libcrashpad_handler_trampoline.so\";\n\n  handler_trampoline->swap(local_handler_trampoline);\n  handler_library->swap(local_handler_library);\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if the handler library and trampoline can be loaded and updates their paths.","ghc_query":"determine handler library trampoline load update path"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings\\edge_settings_interest_group_data_handler.cc:96-125","function":"EdgeInterestGroupDataHandler::HandleRemoveAllInterestGroups","codesnippet":"{\n  // Completely delete all interest group data, including k-anonymity data that\n  // is not cleared by DeleteInterestGroupData. There is no action mapped to the\n  // interest group observer for this action, so must be done manually for\n  // webui2 to rerender.\n  if (is_webui2_mode_) {\n    int num_partitions = profile_->GetLoadedStoragePartitionCount();\n    auto done_counter = std::make_shared<int>(0);\n\n    profile_->ForEachLoadedStoragePartition(\n        [this, num_partitions,\n         done_counter](content::StoragePartition* storage_partition) {\n          content::InterestGroupManager* manager =\n              static_cast<content::InterestGroupManager*>(\n                  storage_partition->GetInterestGroupManager());\n          manager->EdgeRemoveAllInterestGroups(base::BindOnce([]() {}));\n          if (++(*done_counter) == num_partitions) {\n            this->GetInterestGroupData();\n          }\n        });\n  } else {\n    profile_->ForEachLoadedStoragePartition(\n        [&](content::StoragePartition* storage_partition) {\n          content::InterestGroupManager* manager =\n              static_cast<content::InterestGroupManager*>(\n                  storage_partition->GetInterestGroupManager());\n          manager->EdgeRemoveAllInterestGroups(base::BindOnce([]() {}));\n        });\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Completely deletes all interest group data across storage partitions.","ghc_query":"delete interest group data storage partition browser privacy clear"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\sync_file_system\\drive_backend\\sync_task_manager.cc:212-261","function":"SyncTaskManager::NotifyTaskDoneBody","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(token);\n\n  DVLOG(3) << \"NotifyTaskDone: \" << \"finished with status=\" << status\n           << \" (\" << SyncStatusCodeToString(status) << \")\"\n           << \" \" << token->location().ToString();\n\n  if (token->task_blocker()) {\n    dependency_manager_.Erase(token->task_blocker());\n    token->clear_task_blocker();\n  }\n\n  if (client_) {\n    if (token->has_task_log()) {\n      token->FinalizeTaskLog(SyncStatusCodeToString(status));\n      client_->RecordTaskLog(token->PassTaskLog());\n    }\n  }\n\n  std::unique_ptr<SyncTask> task;\n  SyncStatusCallback callback = token->take_callback();\n  if (token->token_id() == SyncTaskToken::kForegroundTaskTokenID) {\n    token_ = std::move(token);\n    task = std::move(running_foreground_task_);\n  } else {\n    task = std::move(running_background_tasks_[token->token_id()]);\n    running_background_tasks_.erase(token->token_id());\n  }\n\n  // Acquire the token to prevent a new task to jump into the queue.\n  token = std::move(token_);\n\n  bool task_used_network = false;\n  if (task)\n    task_used_network = task->used_network();\n\n  if (client_)\n    client_->NotifyLastOperationStatus(status, task_used_network);\n\n  if (!callback.is_null())\n    std::move(callback).Run(status);\n\n  // Post MaybeStartNextForegroundTask rather than calling it directly to avoid\n  // making the call-chaing longer.\n  task_runner_->PostTask(\n      FROM_HERE,\n      base::BindOnce(&SyncTaskManager::MaybeStartNextForegroundTask,\n                     weak_ptr_factory_.GetWeakPtr(), std::move(token)));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles the completion of a sync task, logging its status and managing task dependencies.","ghc_query":"handle complete sync task log status dependency manager"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\tabs\\tab_renderer_data.cc:321-344","function":"TabRendererData::operator==","codesnippet":"{\n  return favicon == other.favicon && thumbnail == other.thumbnail &&\n         network_state == other.network_state && title == other.title &&\n         visible_url == other.visible_url &&\n         last_committed_url == other.last_committed_url &&\n         should_display_url == other.should_display_url &&\n         crashed_status == other.crashed_status &&\n         incognito == other.incognito && show_icon == other.show_icon &&\n         pinned == other.pinned && blocked == other.blocked &&\n         alert_state == other.alert_state &&\n         should_hide_throbber == other.should_hide_throbber &&\n         is_tab_discarded == other.is_tab_discarded &&\n         should_show_discard_status == other.should_show_discard_status &&\n         faded == other.faded && show_split_window == other.show_split_window &&\n         focus_on_split_window == other.focus_on_split_window &&\n         workspace_collaborators_presence ==\n             other.workspace_collaborators_presence &&\n         workspaces_navigation_state == other.workspaces_navigation_state &&\n         discarded_memory_savings_in_bytes ==\n             other.discarded_memory_savings_in_bytes &&\n         tab_resource_usage == other.tab_resource_usage &&\n         split_tab_renderer_data == other.split_tab_renderer_data &&\n         is_monochrome_favicon == other.is_monochrome_favicon &&\n         tab_interface.get() == other.tab_interface.get();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks if two tab objects have identical properties.","ghc_query":"check compare tab object identical properties browser equal same"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\speech\\extension_api\\tts_engine_extension_api_chromeos.cc:175-207","function":"TtsExtensionEngineChromeOS::RefreshAudioStreamOptionsForExtension","codesnippet":"{\n  if (current_playback_engine_ == engine_id)\n    return false;\n\n  extensions::ExtensionRegistry* registry =\n      extensions::ExtensionRegistry::Get(profile);\n  DCHECK(registry);\n  const extensions::Extension* extension =\n      registry->enabled_extensions().GetByID(engine_id);\n  if (!extension)\n    return false;\n\n  current_playback_engine_ = engine_id;\n  auto* info = extensions::TtsVoices::GetTtsEngineInfo(extension);\n  if (!info || !info->sample_rate || !info->buffer_size) {\n    bool had_params = !!audio_parameters_;\n    audio_parameters_.reset();\n    return had_params;\n  }\n\n  if (!audio_parameters_)\n    audio_parameters_ = chromeos::tts::mojom::AudioParameters::New();\n\n  if (audio_parameters_->sample_rate == *info->sample_rate &&\n      audio_parameters_->buffer_size == *info->buffer_size) {\n    return false;\n  }\n\n  audio_parameters_->sample_rate = *info->sample_rate;\n  audio_parameters_->buffer_size = *info->buffer_size;\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates audio parameters for a new playback engine if necessary.","ghc_query":"update audio parameter playback engine renderer media sound"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\filename_generation\\filename_generation.cc:103-149","function":"GenerateFilename","codesnippet":"{\n  base::FilePath name_with_proper_ext = base::FilePath::FromUTF16Unsafe(title);\n\n  // If the page's title matches its URL, use the URL. Try to use the last path\n  // component or if there is none, the domain as the file name.\n  // Normally we want to base the filename on the page title, or if it doesn't\n  // exist, on the URL. It's not easy to tell if the page has no title, because\n  // if the page has no title, WebContents::GetTitle() will return the page's\n  // URL (adjusted for display purposes). Therefore, we convert the \"title\"\n  // back to a URL, and if it matches the original page URL, we know the page\n  // had no title (or had a title equal to its URL, which is fine to treat\n  // similarly).\n  if (title == url_formatter::FormatUrl(\n                   url,\n                   url_formatter::kFormatUrlOmitDefaults |\n                       url_formatter::kFormatUrlOmitTrivialSubdomains |\n                       url_formatter::kFormatUrlOmitHTTPS,\n                   base::UnescapeRule::SPACES, nullptr, nullptr, nullptr)) {\n    std::string url_path;\n    if (!url.SchemeIs(url::kDataScheme)) {\n      name_with_proper_ext = net::GenerateFileName(\n          url, std::string(), std::string(), std::string(), contents_mime_type,\n          std::string());\n\n      // If host is used as file name, try to decode punycode.\n      if (name_with_proper_ext.AsUTF8Unsafe() == url.host()) {\n        name_with_proper_ext = base::FilePath::FromUTF16Unsafe(\n            url_formatter::IDNToUnicode(url.host()));\n      }\n    } else {\n      name_with_proper_ext = base::FilePath::FromUTF8Unsafe(\"dataurl\");\n    }\n  }\n\n  // Ask user for getting final saving name.\n  name_with_proper_ext =\n      EnsureMimeExtension(name_with_proper_ext, contents_mime_type);\n  // Adjust extension for complete types.\n  if (can_save_as_complete)\n    name_with_proper_ext = EnsureHtmlExtension(name_with_proper_ext);\n\n  base::FilePath::StringType file_name = name_with_proper_ext.value();\n  base::i18n::ReplaceIllegalCharactersInPath(&file_name, '_');\n  return base::FilePath(file_name);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a valid file name for saving a webpage based on its title or URL.","ghc_query":"generate valid file name webpage save download title url"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\password_manager\\iris\\password_iris_handler.cc:180-213","function":"PasswordIrisHandler::SendIrisClickEvent","codesnippet":"{\n  // Don't fire click beacon if impression beacon is not fired.\n  if (!iris_data_fetcher_ || !is_impression_fired_)\n    return;\n\n  auto beacon_click_url = iris_data_fetcher_->GetBeaconRequestForPlacement(\n      placement_id_, IrisAction::Click);\n  if (beacon_click_url.has_value()) {\n    net::NetworkTrafficAnnotationTag traffic_annotation =\n        net::DefineNetworkTrafficAnnotation(\"password_iris_click_event_sender\",\n                                            R\"(\n        semantics {\n          sender: \"Password Save/Update module\"\n          description:\n            \"Sends Iris click callback to IRIS for placement\"\n          trigger:\n            \"Hitting on CTA on Password Save/Update bubble.\"\n          data:\n            \"Click beacon url fetched from IRIS.\"\n          destination: MICROSOFT_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: NO\n          setting:\n            \"This feature can be disabled by settings\"\n          policy_exception_justification: \"Not implemented.\"\n        })\");\n    // This deletes itself after the click request to iris is complete\n    IrisTelemetryTrigger* iris_click_beacon_trigger =\n        new IrisTelemetryTrigger(placement_id_, beacon_click_url.value());\n    // The ownership is transferred to the callback in IrisTelemetryTrigger.\n    iris_click_beacon_trigger->SendIrisTelemeteryForPlacement(\n        traffic_annotation, click_histogram_name_);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sends a click event beacon to an external service if an impression beacon was previously fired.","ghc_query":"send click event beacon impression external service analytics tracking"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_session_context\\edge_iris\\edge_iris_registrar.cc:22-92","function":"IrisRegistrar::RegisterAttributes","codesnippet":"{\n#if BUILDFLAG(IS_WIN)\n  RegisterAttribute(IrisAttributeEnum::EnterpriseOrConsumer, \"ISU\",\n                    /*is_consent_needed*/ true);\n  RegisterAttribute(IrisAttributeEnum::AcquisitionPath, \"AREF\",\n                    /*is_consent_needed*/ true);\n  RegisterAttribute(IrisAttributeEnum::TailoredExperience, \"poptin\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsSyncEnabled, \"SYNCSTATUS\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsUserSignedIn, \"ISSIGNEDIN\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(iris::IrisAttributeEnum::UITheme, \"UITHEME\",\n                    /*is_consent_needed*/ false);\n#endif\n#if defined(MICROSOFT_EDGE_BUILD) && BUILDFLAG(IS_WIN)\n  RegisterAttribute(IrisAttributeEnum::PrimaryBrowser, \"APRIMB\",\n                    /*is_consent_needed*/ true);\n#endif\n  RegisterAttribute(IrisAttributeEnum::DefaultBrowser, \"ADEFAB\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::OperatingSystem, \"OPSYS\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::Locale, \"locale\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::Country, \"country\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IEReactivationLaunchType,\n                    \"IEREACTIVATIONTRIGGER\",\n                    /*is_consent_needed*/ false);\n\n  if (base::FeatureList::IsEnabled(features::edge::kEdgeSessionContextV2)) {\n    RegisterAttribute(IrisAttributeEnum::ClientId, \"edgeid\",\n                      /*is_consent_needed*/ false);\n    RegisterAttribute(IrisAttributeEnum::Channel, \"ACHANNEL\",\n                      /*is_consent_needed*/ false);\n    RegisterAttribute(IrisAttributeEnum::BrowserVersion, \"ABUILD\",\n                      /*is_consent_needed*/ false);\n    RegisterAttribute(IrisAttributeEnum::DeviceOSVersion, \"devosver\",\n                      /*is_consent_needed*/ false);\n    RegisterAttribute(IrisAttributeEnum::Caller, \"clr\",\n                      /*is_consent_needed*/ false);\n  }\n\n  RegisterAttribute(IrisAttributeEnum::OptOut, \"topt\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::AFlights, \"aflights\",\n                    /*is_consent_needed*/ false);\n\n  RegisterAttribute(IrisAttributeEnum::IsAdultUser, \"ADTUSER\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsPersonalizationEnabled, \"PC\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsEduUser, \"AEDUD\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsCiEnabled, \"CISTATUS\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::OemName, \"OEM\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsCustomThemeApplied, \"CTHEME\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsAadUser, \"AADU\",\n                    /*is_consent_needed*/ false);\n  RegisterAttribute(IrisAttributeEnum::IsProtocolLaunch, \"APRTLCH\",\n                    /*is_consent_needed*/ false);\n#if !BUILDFLAG(IS_ANDROID)\n  RegisterAttribute(IrisAttributeEnum::IsEdgePersonalisationEnabled, \"EPCON\",\n                    /*is_consent_needed*/ false);\n#endif  // !BUILDFLAG(IS_ANDROID)\n  RegisterAttribute(IrisAttributeEnum::IsEUUser, \"EUUSER\",\n                    /*is_consent_needed*/ false);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Registers various user and system attributes with consent requirements.","ghc_query":"register user system attribute consent requirement privacy permission"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\background\\background_contents.cc:32-69","function":"BackgroundContents::BackgroundContents","codesnippet":"{\n  profile_ = Profile::FromBrowserContext(\n      site_instance->GetBrowserContext());\n\n  WebContents::CreateParams create_params(profile_, std::move(site_instance));\n  create_params.is_never_composited = true;\n  create_params.opener_render_process_id =\n      opener ? opener->GetProcess()->GetDeprecatedID() : MSG_ROUTING_NONE;\n  create_params.opener_render_frame_id =\n      opener ? opener->GetRoutingID() : MSG_ROUTING_NONE;\n\n  if (session_storage_namespace) {\n    content::SessionStorageNamespaceMap session_storage_namespace_map;\n    session_storage_namespace_map.insert(\n        std::make_pair(partition_config, session_storage_namespace));\n    web_contents_ = WebContents::CreateWithSessionStorage(\n        create_params, session_storage_namespace_map);\n  } else {\n    web_contents_ = WebContents::Create(create_params);\n  }\n  web_contents_->SetOwnerLocationForDebug(FROM_HERE);\n  extensions::SetViewType(web_contents_.get(),\n                          extensions::mojom::ViewType::kBackgroundContents);\n  web_contents_->SetDelegate(this);\n  content::WebContentsObserver::Observe(web_contents_.get());\n\n  // Add the TaskManager-specific tag for the BackgroundContents.\n  task_manager::WebContentsTags::CreateForBackgroundContents(\n      web_contents_.get(), this);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and configures a web contents instance for background processing.","ghc_query":"create configure web contents background processing instance"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\file_system_provider\\fake_provided_file_system.cc:632-664","function":"FakeProvidedFileSystem::Notify","codesnippet":"{\n  // Very simple implementation that unconditionally calls notification\n  // callbacks and notifies observers of the change.\n\n  const WatcherKey key(entry_path, recursive);\n  const auto& watcher_it = watchers_.find(key);\n  if (watcher_it == watchers_.end()) {\n    std::move(callback).Run(base::File::FILE_ERROR_NOT_FOUND);\n    return;\n  }\n\n  const ProvidedFileSystemObserver::Changes& changes_ref = *changes.get();\n\n  // Call all notification callbacks (if any).\n  for (const auto& subscriber_it : watcher_it->second.subscribers) {\n    const storage::WatcherManager::NotificationCallback& notification_callback =\n        subscriber_it.second.notification_callback;\n    if (!notification_callback.is_null()) {\n      notification_callback.Run(change_type);\n    }\n  }\n\n  // Notify all observers.\n  for (auto& observer : observers_) {\n    observer.OnWatcherChanged(file_system_info_, watcher_it->second,\n                              change_type, changes_ref, base::DoNothing());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Notifies subscribers and observers of file system changes.","ghc_query":"file system change notification observer subscriber"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\power_metrics\\system_power_monitor.cc:42-71","function":"GenerateValidMetrics","codesnippet":"{\n  if (sample.package_nanojoules > 0) {\n    valid_metrics.push_back(kPackagePowerTraceCounterName);\n  }\n  if (sample.cpu_nanojoules > 0) {\n    valid_metrics.push_back(kCpuPowerTraceCounterName);\n  }\n  if (sample.gpu_nanojoules > 0) {\n    valid_metrics.push_back(kIntegratedGpuPowerTraceCounterName);\n  }\n  if (sample.dram_nanojoules > 0) {\n    valid_metrics.push_back(kDramPowerTraceCounterName);\n  }\n  if (sample.psys_nanojoules > 0) {\n    valid_metrics.push_back(kPsysPowerTraceCounterName);\n  }\n  if (sample.vdd_nanojoules > 0) {\n    valid_metrics.push_back(kVddcrVddTraceCounterName);\n  }\n  if (sample.soc_nanojoules > 0) {\n    valid_metrics.push_back(kVddcrSocTraceCounterName);\n  }\n  if (sample.socket_nanojoules > 0) {\n    valid_metrics.push_back(kCurrentSocketTraceCounterName);\n  }\n  if (sample.apu_nanojoules > 0) {\n    valid_metrics.push_back(kApuPowerTraceCounterName);\n  }\n  return !valid_metrics.empty();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Identifies and records non-zero power metrics."},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\telemetry_client\\uma_telemetry_client.cc:296-319","function":"UmaTelemetryClient::SplitUMALog","codesnippet":"{\n  const size_t max_size_bytes =\n      TelemetryClientConfigManager::GetRotationSchedulerSizeLimit(\n          features::edge::kRotationSchedulerUmaLogSize, kMaxPayloadSizeLimit);\n  const size_t max_repeated_field_size_bytes =\n      TelemetryClientConfigManager::GetRotationSchedulerSizeLimit(\n          features::edge::kRotationSchedulerUmaTransmissionLimit,\n          kMaxUmaLogTransmissionLimit);\n  auto* telservice = TelemetryService::GetInstance();\n  auto* split_service = telservice->GetLogSplitterRawValue(\n      MetricsLogSplitter::Type::UMA, max_size_bytes,\n      max_repeated_field_size_bytes);\n  SplitLogsRawType partial_logs = nullptr;\n\n  if (split_service != nullptr) {\n    base::TimeTicks start_time = base::TimeTicks::Now();\n    partial_logs = split_service->GetSplitLogsRawValue(event_info);\n    LogSplitLogBySizeTime(base::TimeTicks::Now() - start_time,\n                          event_info.group);\n    telservice->FreeLogSplitter(split_service);\n  } else {\n    event_info.result = SendLogResult::ERROR_LOG_SPLITTER_UNAVAILABLE;\n  }\n  return partial_logs;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Splits telemetry logs into smaller parts based on size limits.","ghc_query":"split telemetry logs smaller parts size limits"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\safe_browsing\\tailored_security\\unconsented_message_android.cc:77-116","function":"TailoredSecurityUnconsentedMessageAndroid::\n    TailoredSecurityUnconsentedMessageAndroid","codesnippet":"{\n  message_ = std::make_unique<messages::MessageWrapper>(\n      messages::MessageIdentifier::TAILORED_SECURITY_ENABLED,\n      base::BindOnce(\n          &TailoredSecurityUnconsentedMessageAndroid::HandleMessageAccepted,\n          base::Unretained(this)),\n      base::BindOnce(\n          &TailoredSecurityUnconsentedMessageAndroid::HandleMessageDismissed,\n          base::Unretained(this)));\n\n  int message_title =\n      is_in_flow_ ? IDS_TAILORED_SECURITY_UNCONSENTED_MESSAGE_TITLE\n                  : IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_MESSAGE_TITLE;\n  int primary_button =\n      is_in_flow_ ? IDS_TAILORED_SECURITY_UNCONSENTED_MESSAGE_ACCEPT\n                  : IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_MESSAGE_ACCEPT;\n  message_->SetTitle(l10n_util::GetStringUTF16(message_title));\n  message_->SetPrimaryButtonText(l10n_util::GetStringUTF16(primary_button));\n  if (!is_in_flow_) {\n    message_->SetDescription(l10n_util::GetStringUTF16(\n        IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_MESSAGE_DESCRIPTION));\n  }\n\n  message_->SetIconResourceId(\n      ResourceMapper::MapToJavaDrawableId(IDR_ANDROID_MESSAGE_SHIELD_BLUE));\n  // Need to disable tint here because it removes a shade of blue from the\n  // shield which distorts the image.\n  message_->DisableIconTint();\n\n  LogMessageOutcome(TailoredSecurityOutcome::kShown, is_in_flow_);\n  messages::MessageDispatcherBridge::Get()->EnqueueMessage(\n      message_.get(), web_contents_, messages::MessageScopeType::NAVIGATION,\n      messages::MessagePriority::kNormal);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays a tailored security message with appropriate title, button text, and icon based on user flow status.","ghc_query":"display tailored security message title button text icon user flow status"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\test\\base\\save_desktop_snapshot.cc:103-146","function":"SaveDesktopSnapshot","codesnippet":"{\n  // Take the snapshot and encode it.\n  SkBitmap screen = CaptureScreen();\n  if (screen.drawsNothing()) {\n    return base::FilePath();\n  }\n\n  std::optional<std::vector<uint8_t>> encoded =\n      gfx::PNGCodec::EncodeBGRASkBitmap(CaptureScreen(),\n                                        /*discard_transparency=*/false);\n  if (!encoded) {\n    LOG(ERROR) << \"Failed to PNG encode screen snapshot.\";\n    return base::FilePath();\n  }\n\n  // Create the output file.\n  base::FilePath output_path =\n      output_dir.AppendASCII(base::UnlocalizedTimeFormatWithPattern(\n          base::Time::Now(), \"'ss_'yyyyMMddHHmmss_SSS'.png'\"));\n  uint32_t flags = base::File::FLAG_CREATE | base::File::FLAG_WRITE;\n#if BUILDFLAG(IS_WIN)\n  flags |=\n      base::File::FLAG_WIN_SHARE_DELETE | base::File::FLAG_CAN_DELETE_ON_CLOSE;\n#endif\n  base::File file(output_path, flags);\n\n  if (!file.IsValid()) {\n    if (file.error_details() == base::File::FILE_ERROR_EXISTS) {\n      LOG(INFO) << \"Skipping screen snapshot since it is already present: \"\n                << output_path.BaseName();\n    } else {\n      LOG(ERROR) << \"Failed to create snapshot output file \\\"\" << output_path\n                 << \"\\\" with error \" << file.error_details();\n    }\n    return base::FilePath();\n  }\n\n  // Write it to disk.\n  if (!file.WriteAtCurrentPosAndCheck(encoded.value())) {\n    LOG(ERROR) << \"Failed to write entire snapshot to file\";\n    return base::FilePath();\n  }\n\n  return output_path;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Captures a screen snapshot, encodes it as a PNG, and saves it to a file.","ghc_query":"capture screen snapshot encode png save file"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_photo\\edge_photo_util.cc:98-124","function":"LoadImageData","codesnippet":"{\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::WILL_BLOCK);\n\n  std::vector<uint8_t> data;\n  base::File file =\n      base::File(path, base::File::FLAG_OPEN | base::File::FLAG_READ);\n\n  if (!file.IsValid()) {\n    return data;\n  }\n\n  int64_t file_size = file.GetLength();\n  // Confirm that the file's size is within our threshold.\n  if (file_size <= 0 || file_size > kMaxImageSize) {\n    LOG(ERROR) << \"Unexpected file size: \" << path.MaybeAsASCII() << \", \"\n               << file_size;\n    return data;\n  }\n\n  data.resize(file_size);\n  if (!file.ReadAndCheck(0, data)) {\n    LOG(ERROR) << \"Failed to read file: \" << path.MaybeAsASCII();\n    data.clear();\n  }\n\n  return data;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Reads a file's content into a byte vector if it is within a specified size limit.","ghc_query":"read file content byte vector specified size limit"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_side_pane\\contents\\side_pane_tab_contextual_content.cc:139-184","function":"SidePaneTabContextualContentBase::OnHostURLUpdated","codesnippet":"{\n  if (!ShouldUpdateContextualContent()) {\n    return;\n  }\n\n  // This check is needed since webui can be torn down at will if we open\n  // search perspectives.\n  if (!webui) {\n    if (!webui_observer_) {\n      // The WebUI is not found (and we haven't already started reloading it).\n      // The WebUI may have been unloaded by pane navigations? Reload it. Once\n      // finished, then update the WebUI with the new host url.\n      //\n      // Note that |url| is not being passed to the callback, because the host\n      // url may change while the WebUI is loading. The callback function\n      // will lookup the current host url.\n      webui_observer_ = std::make_unique<MainFrameNavigationChangedObserver>(\n          GetSidePaneContents(),\n          base::BindRepeating(\n              &SidePaneTabContextualContentBase::OnWebUILoadedUpdateHostURL,\n              weak_ptr_factory_.GetWeakPtr()));\n\n      // Reload the WebUI\n      if (Browser* browser = GetBrowser()) {\n        if (HubContentProvider* provider =\n                HubManager::GetProviderForContent(browser, GetHubContentID())) {\n          content::NavigationController::LoadURLParams params(\n              provider->GetURL());\n          params.should_clear_history_list = true;\n          Navigate(params);\n        }\n      }\n    }\n    return;\n  }\n\n  T webui_instance = static_cast<T>(webui->GetController());\n  DCHECK(webui_instance);\n  if (webui_instance) {\n    webui_instance->OnHostURLUpdated(\n        url, GetHubUrlParams(), should_send_autoopen_form_code_,\n        edge_underside::helper::GetPageLanguage(host_content_));\n\n    should_send_autoopen_form_code_ = false;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates the WebUI with the current host URL if necessary.","ghc_query":"update webui current host url necessary"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\engagement\\history_aware_site_engagement_service.cc:43-118","function":"HistoryAwareSiteEngagementService::UpdateEngagementScores","codesnippet":"{\n  // The most in-the-past option in the Clear Browsing Dialog aside from \"all\n  // time\" is 4 weeks ago. Set the last updated date to 4 weeks ago for origins\n  // where we can't find a valid last visit date.\n  base::Time now = clock().Now();\n  base::Time four_weeks_ago = now - base::Days(28);\n\n  HostContentSettingsMap* settings_map =\n      HostContentSettingsMapFactory::GetForProfile(browser_context());\n\n  for (const auto& origin_to_count : remaining_origins) {\n    GURL origin = origin_to_count.first;\n    // It appears that the history service occasionally sends bad URLs to us.\n    // See crbug.com/612881.\n    if (!origin.is_valid())\n      continue;\n\n    int remaining = origin_to_count.second.first;\n    base::Time last_visit = origin_to_count.second.second;\n    int deleted = deleted_origins.count(origin);\n\n    // Do not update engagement scores if the deletion was an expiry, but the\n    // URL still has entries in history.\n    if ((expired && remaining != 0) || deleted == 0)\n      continue;\n\n    // Remove origins that have no urls left.\n    if (remaining == 0) {\n      settings_map->SetWebsiteSettingDefaultScope(\n          origin, GURL(), ContentSettingsType::SITE_ENGAGEMENT, base::Value());\n      continue;\n    }\n\n    // Remove engagement proportional to the urls expired from the origin's\n    // entire history.\n    double proportion_remaining =\n        static_cast<double>(remaining) / (remaining + deleted);\n    if (last_visit.is_null() || last_visit > now)\n      last_visit = four_weeks_ago;\n\n    // At this point, we are going to proportionally decay the origin's\n    // engagement, and reset its last visit date to the last visit to a URL\n    // under the origin in history. If this new last visit date is long enough\n    // in the past, the next time the origin's engagement is accessed the\n    // automatic decay will kick in - i.e. a double decay will have occurred.\n    // To prevent this, compute the decay that would have taken place since the\n    // new last visit and add it to the engagement at this point. When the\n    // engagement is next accessed, it will decay back to the proportionally\n    // reduced value rather than being decayed once here, and then once again\n    // when it is next accessed.\n    // TODO(crbug.com/41308686): Move the proportional decay logic into\n    // SiteEngagementScore, so it can decay raw_score_ directly, without the\n    // double-decay issue.\n    SiteEngagementScore engagement_score = CreateEngagementScore(origin);\n\n    double new_score = proportion_remaining * engagement_score.GetTotalScore();\n    int hours_since_engagement = (now - last_visit).InHours();\n    int periods =\n        hours_since_engagement / SiteEngagementScore::GetDecayPeriodInHours();\n    new_score += periods * SiteEngagementScore::GetDecayPoints();\n    new_score *= pow(1.0 / SiteEngagementScore::GetDecayProportion(), periods);\n\n    double score = std::min(SiteEngagementScore::kMaxPoints, new_score);\n    engagement_score.Reset(score, last_visit);\n    if (!engagement_score.last_shortcut_launch_time().is_null() &&\n        engagement_score.last_shortcut_launch_time() > last_visit) {\n      engagement_score.set_last_shortcut_launch_time(last_visit);\n    }\n\n    engagement_score.Commit();\n  }\n\n  SetLastEngagementTime(now);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates site engagement scores based on expired history entries and adjusts last visit dates.","ghc_query":"update site engagement score expired history entries adjust last visit date"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\media\\webrtc\\desktop_media_list_ash.cc:91-141","function":"DesktopMediaListAsh::EnumerateSources","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  aura::Window::Windows root_windows = ash::Shell::GetAllRootWindows();\n\n  for (size_t i = 0; i < root_windows.size(); ++i) {\n    if (type_ == DesktopMediaList::Type::kScreen) {\n      SourceDescription screen_source(\n          content::DesktopMediaID::RegisterNativeWindow(\n              content::DesktopMediaID::TYPE_SCREEN, root_windows[i]),\n          root_windows[i]->GetTitle());\n\n      if (root_windows[i] == ash::Shell::GetPrimaryRootWindow())\n        sources->insert(sources->begin(), screen_source);\n      else\n        sources->push_back(screen_source);\n\n      if (screen_source.name.empty()) {\n        if (root_windows.size() > 1) {\n          // 'Screen' in 'Screen 1, Screen 2, etc ' might be inflected in some\n          // languages depending on the number although rather unlikely. To be\n          // safe, use the plural format.\n          // TODO(jshin): Revert to GetStringFUTF16Int (with native digits)\n          // if none of UI languages inflects 'Screen' in this context.\n          screen_source.name = l10n_util::GetPluralStringFUTF16(\n              IDS_DESKTOP_MEDIA_PICKER_MULTIPLE_SCREEN_NAME,\n              static_cast<int>(i + 1));\n        } else {\n          screen_source.name = l10n_util::GetStringUTF16(\n              IDS_DESKTOP_MEDIA_PICKER_SINGLE_SCREEN_NAME);\n        }\n      }\n\n      if (update_thumbnails)\n        CaptureThumbnail(screen_source.id, root_windows[i]);\n    } else {\n      for (int desk_id : ash::desks_util::GetDesksContainersIds()) {\n        EnumerateWindowsForRoot(sources, update_thumbnails, root_windows[i],\n                                desk_id);\n      }\n\n      EnumerateWindowsForRoot(sources, update_thumbnails, root_windows[i],\n                              ash::kShellWindowId_AlwaysOnTopContainer);\n      EnumerateWindowsForRoot(sources, update_thumbnails, root_windows[i],\n                              ash::kShellWindowId_PipContainer);\n      EnumerateWindowsForRoot(sources, update_thumbnails, root_windows[i],\n                              ash::kShellWindowId_FloatContainer);\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Enumerates and organizes screen or window sources for desktop media capture.","ghc_query":"enumerate organize screen window sources desktop media capture"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\viz\\service\\transitions\\transferable_resource_tracker.cc:59-85","function":"TransferableResourceTracker::ImportResource","codesnippet":"{\n  auto resource = TransferableResource::Make(\n      output_copy.shared_image,\n      TransferableResource::ResourceSource::kViewTransition,\n      output_copy.sync_token);\n\n  TransferableResourceHolder::ResourceReleaseCallback release_callback;\n  if (output_copy.release_callback) {\n    release_callback = base::BindOnce(\n        [](ReleaseCallback callback, const TransferableResource& resource,\n           const gpu::SyncToken& sync_token) {\n          std::move(callback).Run(sync_token, /*is_lost=*/false);\n        },\n        std::move(output_copy.release_callback));\n  }\n\n  resource.id = id_tracker_->AllocId(/*initial_ref_count=*/1);\n  DCHECK(!base::Contains(managed_resources_, resource.id));\n  managed_resources_.emplace(\n      resource.id,\n      TransferableResourceHolder(resource, std::move(release_callback)));\n\n  PositionedResource result;\n  result.resource = resource;\n  return result;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a positioned transferable resource with a release callback.","ghc_query":"create positioned transferable resource release callback"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync\\base\\unique_position.cc:590-618","function":"UniquePosition::Uncompress","codesnippet":"{\n  if (str.size() > kMaxUncompressedSize) {\n    return std::string();\n  }\n\n  std::string output;\n  size_t i = 0;\n  // Iterate through the compressed string one block at a time.\n  for (i = 0; i + 8 <= str.length(); i += 8) {\n    if (IsRepeatedCharPrefix(str, i)) {\n      // Found a repeated character block.  Expand it.\n      const char rep_digit = str[i];\n      uint32_t length = ReadEncodedRunLength(str, i + 4);\n      if (output.size() + length > kMaxUncompressedSize) {\n        // Early return to avoid allocating too much memory.\n        return std::string();\n      }\n      output.append(length, rep_digit);\n    } else {\n      // Found a regular block.  Copy it.\n      output.append(str, i, 8);\n    }\n  }\n  // Copy the remaining bytes that were too small to form a block.\n  output.append(str, i, std::string::npos);\n  if (output.size() > kMaxUncompressedSize) {\n    return std::string();\n  }\n  return output;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Decompresses a string with repeated character blocks.","ghc_query":"decompress string repeated character blocks"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\autofill\\core\\browser\\integrators\\optimization_guide\\autofill_optimization_guide.cc:145-185","function":"GetBenefitCategoryForOptimizationType","codesnippet":"{\n  switch (optimization_type) {\n    case optimization_guide::proto::\n        AMERICAN_EXPRESS_CREDIT_CARD_FLIGHT_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kFlights;\n    case optimization_guide::proto::\n        AMERICAN_EXPRESS_CREDIT_CARD_SUBSCRIPTION_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kSubscription;\n    case optimization_guide::proto::BMO_CREDIT_CARD_AIR_MILES_PARTNER_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kAirMilesPartner;\n    case optimization_guide::proto::BMO_CREDIT_CARD_ALCOHOL_STORE_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kAlcoholStores;\n    case optimization_guide::proto::BMO_CREDIT_CARD_DRUGSTORE_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kDrugstores;\n    case optimization_guide::proto::BMO_CREDIT_CARD_OFFICE_SUPPLY_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kOfficeSupplies;\n    case optimization_guide::proto::BMO_CREDIT_CARD_RECURRING_BILL_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kRecurringBills;\n    case optimization_guide::proto::BMO_CREDIT_CARD_TRANSIT_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kTransit;\n    case optimization_guide::proto::BMO_CREDIT_CARD_TRAVEL_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kTravel;\n    case optimization_guide::proto::BMO_CREDIT_CARD_WHOLESALE_CLUB_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kWholesaleClubs;\n    case optimization_guide::proto::BMO_CREDIT_CARD_DINING_BENEFITS:\n    case optimization_guide::proto::CAPITAL_ONE_CREDIT_CARD_DINING_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kDining;\n    case optimization_guide::proto::BMO_CREDIT_CARD_GROCERY_BENEFITS:\n    case optimization_guide::proto::CAPITAL_ONE_CREDIT_CARD_GROCERY_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kGroceryStores;\n    case optimization_guide::proto::BMO_CREDIT_CARD_ENTERTAINMENT_BENEFITS:\n    case optimization_guide::proto::\n        CAPITAL_ONE_CREDIT_CARD_ENTERTAINMENT_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kEntertainment;\n    case optimization_guide::proto::CAPITAL_ONE_CREDIT_CARD_STREAMING_BENEFITS:\n      return CreditCardCategoryBenefit::BenefitCategory::kStreaming;\n    default:\n      NOTREACHED();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps credit card optimization types to their corresponding benefit categories.","ghc_query":"map credit card optimization type benefit category"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_san_personalization\\san_personalization_prompt.cc:546-570","function":"SanPersonalizationPrompt::RetryProcess","codesnippet":"{\n  if (base::FeatureList::IsEnabled(\n          features::edge::kSanPersonalizationWithWpoRetry)) {\n    EntryPoint new_entry_point = EntryPoint::kNone;\n    switch (entry_point) {\n      case EntryPoint::kBrowserLaunch:\n      case EntryPoint::kProtocolBrowserLaunch:\n        new_entry_point = EntryPoint::kRetryFromBrowserLaunch;\n        break;\n      case EntryPoint::kNewTabLaunch:\n        new_entry_point = EntryPoint::kRetryFromNewTabLaunch;\n        break;\n      default:\n        new_entry_point = entry_point;\n        break;\n    }\n    content::GetUIThreadTaskRunner({base::TaskPriority::BEST_EFFORT})\n        ->PostDelayedTask(\n            FROM_HERE,\n            base::BindOnce(base::IgnoreResult(\n                               &SanPersonalizationPrompt::MaybeStartProcess),\n                           weak_ptr_factory_.GetWeakPtr(), new_entry_point),\n            delay);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Schedules a delayed personalization process retry based on the entry point.","ghc_query":"schedule delayed personalization retry process entry point"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\content_settings\\generated_cookie_prefs.cc:137-169","function":"GeneratedCookiePrimarySettingPref::SetPref","codesnippet":"{\n  if (!value->is_int()) {\n    return extensions::settings_private::SetPrefResult::PREF_TYPE_MISMATCH;\n  }\n\n  auto current_content_setting =\n      host_content_settings_map_->GetDefaultContentSetting(\n          ContentSettingsType::COOKIES, nullptr);\n\n  auto allow_setting =\n      current_content_setting != ContentSetting::CONTENT_SETTING_BLOCK\n          ? current_content_setting\n          : ContentSetting::CONTENT_SETTING_ALLOW;\n\n  auto selection = static_cast<CookiePrimarySetting>(value->GetInt());\n  switch (selection) {\n    case (CookiePrimarySetting::ALLOW_ALL):\n      return SetAllCookieSettings(profile_, CookieControlsMode::kOff,\n                                  allow_setting);\n    case (CookiePrimarySetting::BLOCK_THIRD_PARTY_INCOGNITO):\n      return SetAllCookieSettings(profile_, CookieControlsMode::kIncognitoOnly,\n                                  allow_setting);\n    case (CookiePrimarySetting::BLOCK_THIRD_PARTY):\n      return SetAllCookieSettings(\n          profile_, CookieControlsMode::kBlockThirdParty, allow_setting);\n    case (CookiePrimarySetting::BLOCK_ALL):\n      return SetAllCookieSettings(profile_,\n                                  CookieControlsMode::kBlockThirdParty,\n                                  ContentSetting::CONTENT_SETTING_BLOCK);\n    default:\n      return extensions::settings_private::SetPrefResult::PREF_TYPE_MISMATCH;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets cookie settings based on the provided integer value.","ghc_query":"set cookie settings value configure"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\autofill_ai\\core\\browser\\autofill_ai_import_utils.cc:57-94","function":"GetValueAndFormatString","codesnippet":"{\n  std::optional<FieldType> field_type =\n      field.GetAutofillAiServerTypePredictions();\n  if (!field_type) {\n    return {};\n  }\n\n  if (!IsDateFieldType(*field_type) || !field.IsSelectElement()) {\n    std::u16string value = field.value_for_import();\n    base::TrimWhitespace(value, base::TRIM_ALL, &value);\n    return {\n        .value = std::move(value),\n        .format_string = field.format_string() ? *field.format_string() : u\"\"};\n  }\n\n  auto get_value = [&](DatePartRange range) {\n    // TODO(crbug.com/415805985): Consider adding a heuristic to decide what\n    // value to extract for date select options (value vs label vs index).\n    const std::u16string& value = field.value();\n    uint32_t index = 0;\n    while (index < range.options.size() &&\n           value != range.options[index].value) {\n      ++index;\n    }\n    if (index < range.options.size()) {\n      return base::NumberToString16(range.first_value + index);\n    }\n    return std::u16string();\n  };\n  std::u16string value;\n  if (!(value = get_value(GetYearRange(field.options()))).empty()) {\n    return {.value = std::move(value), .format_string = u\"YYYY\"};\n  } else if (!(value = get_value(GetMonthRange(field.options()))).empty()) {\n    return {.value = std::move(value), .format_string = u\"M\"};\n  } else if (!(value = get_value(GetDayRange(field.options()))).empty()) {\n    return {.value = std::move(value), .format_string = u\"D\"};\n  }\n  return {};\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Extracts and formats a field's value based on its type and options."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_performance_control_center\\process_metrics_history_helper.cc:328-478","function":"GetAggregatedTabCPUUsageInfo","codesnippet":"{\n  DCHECK(handle_and_metrics);\n\n  // Collect the process handles and map them to tabs.\n  std::vector<TabCPUUsageInfo> tab_info;\n  std::vector<base::ProcessHandle> ad_frame_process_handles;\n\n  // This is a map from process handle to a set of counters for each tab which\n  // contains a frame hosted by that process.\n  ProcessHandleToTabInfoIndexMap process_handle_to_tab_info_index;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n  ProcessHandleToTabInfoIndexMap pepper_process_handle_to_tab_info_index;\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n\n#if !BUILDFLAG(IS_ANDROID)\n  for (Browser* browser : *BrowserList::GetInstance()) {\n    auto* const active_contents =\n        browser->tab_strip_model()->GetActiveWebContents();\n    for (int i = 0; i < browser->tab_strip_model()->count(); i++) {\n      auto* const contents = browser->tab_strip_model()->GetWebContentsAt(i);\n      size_t tab_info_index = tab_info.size();\n\n      tab_info.push_back(\n          {contents == active_contents /*active_*/,\n           contents->GetVisibility() ==\n               content::Visibility::VISIBLE /*visible_*/,\n           edge::sleeping_tabs::SleepingTabsManager::IsContentFrozen(\n               contents) /*frozen_*/,\n           false /*has_ad_frames_*/,\n           contents\n               ->HasActiveEffectivelyFullscreenVideo() /*fullscreen_video_*/,\n           browser->window()->IsActive() /*browser_window_active_*/,\n           browser->window()->IsVisible() /*browser_window_visible_*/,\n           0 /*usage_*/, 0 /*ads_usage_*/, 0 /*fullscreen_video_usage_*/,\n           0 /*pdf_plugin_usage_*/});\n      std::vector<content::RenderFrameHost*> frames;\n      contents->ForEachRenderFrameHost(\n          [&frames](content::RenderFrameHost* rfh) { frames.push_back(rfh); });\n      for (auto* const frame : frames) {\n        auto* const rph = frame->GetProcess();\n        if (!rph)\n          continue;\n        const base::ProcessHandle handle = rph->GetProcess().Handle();\n        if (handle == base::kNullProcessHandle)\n          continue;\n\n        // Keep track of how many frames this process is hosting overall and for\n        // each tab.\n        auto it = process_handle_to_tab_info_index.find(handle);\n        if (it == process_handle_to_tab_info_index.end()) {\n          auto& pfti = process_handle_to_tab_info_index[handle];\n          pfti.total_hosted_frame_count_ = 1;\n          pfti.tab_info_index_to_hosted_frame_count_[tab_info_index] = 1;\n        } else {\n          it->second.total_hosted_frame_count_ += 1;\n\n          auto it2 = it->second.tab_info_index_to_hosted_frame_count_.find(\n              tab_info_index);\n          if (it2 == it->second.tab_info_index_to_hosted_frame_count_.end()) {\n            it->second.tab_info_index_to_hosted_frame_count_.emplace(\n                std::make_pair(tab_info_index, 1));\n          } else {\n            it2->second += 1;\n          }\n        }\n\n#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n        if (base::FeatureList::IsEnabled(\n                pdf::features::edge::kPdfLogTabCPUPdfMetric)) {\n          // If it's a PDF (extension) frame, account for the PPAPI process.\n          if (IsPdfExtensionOrigin(frame->GetLastCommittedOrigin())) {\n            AddPDFPluginUsageForFrame(frame, rph, tab_info_index,\n                                      pepper_process_handle_to_tab_info_index);\n          }\n        }\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n\n        if (frame->IsAdFrame() &&\n            (std::find(ad_frame_process_handles.cbegin(),\n                       ad_frame_process_handles.cend(),\n                       handle) == ad_frame_process_handles.cend())) {\n          ad_frame_process_handles.push_back(handle);\n        }\n      }\n    }\n  }\n#endif\n\n  // Walk the process usage info we have and accumulate it into tab usage.\n  for (size_t i = 0; i < handle_and_metrics->size(); i++) {\n    const auto& entry = handle_and_metrics->operator[](i);\n    const base::ProcessHandle handle = entry.handle_;\n\n    // Use the counters we computed above tracking how many frames this process\n    // hosts for which tabs in order to compute this process usage which we\n    // should attribute to each tab.\n    const auto it = process_handle_to_tab_info_index.find(handle);\n    if (it != process_handle_to_tab_info_index.end()) {\n      auto it2 = it->second.tab_info_index_to_hosted_frame_count_.begin();\n      while (it2 != it->second.tab_info_index_to_hosted_frame_count_.end()) {\n        // Split the process usage fairly based on the number of frames this\n        // process is hosting for this tab. fair_usage = total_usage *\n        // this_tab_hosted_frame_count / process_total_hosted_frame_count\n        double fair_usage = entry.usage_;\n        if (it2->second < it->second.total_hosted_frame_count_) {\n          fair_usage =\n              entry.usage_ * it2->second / it->second.total_hosted_frame_count_;\n        }\n        const auto tab_info_index = it2->first;\n        tab_info[tab_info_index].usage_ += fair_usage;\n        if (tab_info[tab_info_index].fullscreen_video_) {\n          tab_info[tab_info_index].fullscreen_video_usage_ += fair_usage;\n        }\n        if (std::find(ad_frame_process_handles.cbegin(),\n                      ad_frame_process_handles.cend(),\n                      handle) != ad_frame_process_handles.cend()) {\n          tab_info[tab_info_index].has_ad_frames_ = true;\n          tab_info[tab_info_index].ads_usage_ += fair_usage;\n        }\n        ++it2;\n      }\n#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n    } else if (base::FeatureList::IsEnabled(\n                   pdf::features::edge::kPdfLogTabCPUPdfMetric)) {\n      // Use the counters we computed above tracking how many frames this\n      // process hosts for which tabs in order to compute this process usage\n      // which we should attribute to each tab.\n      const auto pdf_it = pepper_process_handle_to_tab_info_index.find(handle);\n      if (pdf_it != pepper_process_handle_to_tab_info_index.end()) {\n        auto it2 = pdf_it->second.tab_info_index_to_hosted_frame_count_.begin();\n        while (it2 !=\n               pdf_it->second.tab_info_index_to_hosted_frame_count_.end()) {\n          // Split the process usage fairly based on the number of frames this\n          // process is hosting for this tab. fair_usage = total_usage *\n          // this_tab_hosted_frame_count / process_total_hosted_frame_count\n          double fair_usage = entry.usage_;\n          if (it2->second < pdf_it->second.total_hosted_frame_count_) {\n            fair_usage = entry.usage_ * it2->second /\n                         pdf_it->second.total_hosted_frame_count_;\n          }\n          const auto tab_info_index = it2->first;\n          tab_info[tab_info_index].pdf_plugin_usage_ = fair_usage;\n          ++it2;\n        }\n      }\n    }\n#else\n    }\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PPAPI)\n  }","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Calculates and distributes CPU usage metrics across browser tabs based on hosted frames."},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\predictors\\perform_network_context_prefetch.cc:94-201","function":"PrefetchResource","codesnippet":"{\n  const auto site_for_cookies = net::SiteForCookies::FromUrl(page);\n  network::ResourceRequest request;\n  request.method = \"GET\";\n  request.url = url;\n  request.site_for_cookies = site_for_cookies;\n  request.request_initiator = page_origin;\n\n  // TODO(crbug.com/342445996): We need the predictor to predict the referrer\n  // policy so that we can create the referrer fields correctly.\n  static constexpr net::ReferrerPolicy kExpectedReferrerPolicy =\n      net::ReferrerPolicy::REDUCE_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN;\n  request.referrer = CalculateReferrer(page, url);\n  request.referrer_policy = kExpectedReferrerPolicy;\n\n  auto& headers = request.headers;\n  if (!base::FeatureList::IsEnabled(\n          blink::features::kRemovePurposeHeaderForPrefetch)) {\n    headers.SetHeader(blink::kPurposeHeaderName,\n                      blink::kSecPurposePrefetchHeaderValue);\n  }\n  headers.SetHeader(blink::kSecPurposeHeaderName,\n                    blink::kSecPurposePrefetchHeaderValue);\n\n  // Client hints headers.\n  //\n  // TODO(crbug.com/342445996): We either need the predictor to predict client\n  // hints headers, or we need the code in //content/browser/client_hints to be\n  // refactored so be more general so that it is usable here.\n  headers.SetHeader(\"sec-ch-ua\", ua_metadata.SerializeBrandMajorVersionList());\n  headers.SetHeader(\"sec-ch-ua-mobile\",\n                    SerializeHeaderString(ua_metadata.mobile));\n  headers.SetHeader(\"sec-ch-ua-platform\",\n                    SerializeHeaderString(ua_metadata.platform));\n  // We shouldn't be prefetching if data saver is enabled, so we should never\n  // need to set the \"save-data\" header.\n\n  headers.SetHeader(\"User-Agent\", user_agent);\n\n  headers.SetHeader(\"Accept-Language\", accept_language);\n\n  headers.SetHeader(\n      \"Accept\",\n      blink::network_utils::GetAcceptHeaderForDestination(destination));\n\n  // Add the X-Client-Data header for requests to Google properties.\n  variations::AppendVariationsHeaderUnknownSignedIn(\n      url, variations::InIncognito::kNo, &request);\n\n  request.load_flags =\n      net::LOAD_SUPPORT_ASYNC_REVALIDATION | net::LOAD_PREFETCH;\n\n  request.destination = destination;\n  request.resource_type = static_cast<int>(type);\n  request.mode = network::mojom::RequestMode::kNoCors;\n  request.enable_load_timing = true;\n  request.do_not_prompt_for_login = false;\n  request.is_outermost_main_frame = true;\n  request.attribution_reporting_support =\n      network::mojom::AttributionSupport::kWeb;\n  request.shared_dictionary_writer_enabled = true;\n\n  // Suppress credentials for cross-origin image loads. See the comment in\n  // PopulateResourceRequest() in\n  // //third_party/blink/renderer/platform/loader/fetch/url_loader/request_conversion.cc\n  // for more details.\n\n  // TODO(crbug.com/342445996): Identify favicons more reliably.\n  const bool is_favicon = LooksLikeFavicon(url);\n  if (!is_favicon &&\n      destination == network::mojom::RequestDestination::kImage &&\n      IsBannedCrossSiteAuth(url, site_for_cookies)) {\n    request.do_not_prompt_for_login = true;\n    request.load_flags |= net::LOAD_DO_NOT_USE_EMBEDDED_IDENTITY;\n  }\n\n  // The hints are only for requests made from the top frame,\n  // so frame_origin is the same as top_frame_origin.\n  const auto frame_origin = page_origin;\n\n  request.trusted_params = network::ResourceRequest::TrustedParams();\n  request.trusted_params->isolation_info =\n      net::IsolationInfo::Create(net::IsolationInfo::RequestType::kOther,\n                                 page_origin, frame_origin, site_for_cookies);\n\n  // TODO(crbug.com/342445996): Set `trusted_params->client_security_state` if\n  // possible, to stop prefetch being blocked on local networks. This requires a\n  // lot of information we don't currently have available here.\n\n  // TODO(crbug.com/342445996): Support interception by extensions.\n\n  // TODO(crbug.com/342445996): Factor out the URLLoaderThrottle code from\n  // chrome/browser/preloading/prefetch/search_prefetch/search_prefetch_request.cc\n  // and reuse it here.\n\n  network_context->Prefetch(\n      content::GlobalRequestID::MakeBrowserInitiated().request_id,\n      network::mojom::kURLLoadOptionBlockLocalRequest, request,\n      net::MutableNetworkTrafficAnnotationTag(kPrefetchTrafficAnnotation));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initiates a prefetch request with specific headers and configurations for a given URL.","ghc_query":"prefetch request headers configurations URL network prefetching"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\media_router\\common\\providers\\cast\\certificate\\cast_crl.cc:348-405","function":"CastCRLImpl::CheckRevocation","codesnippet":"{\n  if (trusted_chain.empty()) {\n    return false;\n  }\n\n  // Check the validity of the CRL at the specified time.\n  bssl::der::GeneralizedTime verification_time;\n  if (!net::EncodeTimeAsGeneralizedTime(time, &verification_time)) {\n    VLOG(2) << \"CRL verification time malformed.\";\n    return false;\n  }\n  if ((verification_time < not_before_) || (verification_time > not_after_)) {\n    VLOG(2) << \"CRL not time-valid. Perform hard fail.\";\n    return false;\n  }\n\n  // Check revocation. This loop iterates over both certificates AND then the\n  // trust anchor after exhausting the certs.\n  for (size_t i = 0; i < trusted_chain.size(); ++i) {\n    const bssl::der::Input& spki_tlv = trusted_chain[i]->tbs().spki_tlv;\n\n    // Calculate the public key's hash to check for revocation.\n    std::string spki_hash = crypto::SHA256HashString(spki_tlv.AsString());\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    // Revocation data (if any) was saved in the constructor using this fake\n    // hash code.\n    spki_hash = kFakeHashForFuzzing;\n#endif\n    if (revoked_hashes_.find(spki_hash) != revoked_hashes_.end()) {\n      VLOG(2) << \"Public key is revoked.\";\n      return false;\n    }\n\n    // Check if the subordinate certificate was revoked by serial number.\n    if (i > 0) {\n      auto issuer_iter = revoked_serial_numbers_.find(spki_hash);\n      if (issuer_iter != revoked_serial_numbers_.end()) {\n        const auto& subordinate = trusted_chain[i - 1];\n        uint64_t serial_number;\n        // Only Google generated device certificates will be revoked by range.\n        // These will always be less than 64 bits in length.\n        if (!bssl::der::ParseUint64(subordinate->tbs().serial_number,\n                                    &serial_number)) {\n          continue;\n        }\n        for (const auto& revoked_serial : issuer_iter->second) {\n          if (revoked_serial.first_serial <= serial_number &&\n              revoked_serial.last_serial >= serial_number) {\n            VLOG(2) << \"Serial number is revoked\";\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates a certificate chain against revocation lists and time constraints.","ghc_query":"certificate chain validation revocation lists time constraints SSL security"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\sad_tab_view.cc:79-489","function":"ErrorToString","codesnippet":"{\n  std::string error_string;\n  switch (std::abs(error_code)) {\n    case 1:\n      error_string = \"RESULT_CODE_KILLED\";\n      break;\n    case 2:\n      error_string = \"RESULT_CODE_HUNG\";\n      break;\n    case 3:\n      error_string = \"RESULT_CODE_KILLED_BAD_MESSAGE\";\n      break;\n    // Code 4 conflicts between SIGILL and RESULT_CODE_GPU_DEAD_ON_ARRIVAL.\n    // Code 5 conflicts between SIGTRAP and RESULT_CODE_INVALID_CMDLINE_URL.\n    // Code 6 conflicts between SIGABRT and RESULT_CODE_BAD_PROCESS_TYPE.\n    // Omit these to show the default error string.\n    case 7:\n      error_string = \"RESULT_CODE_MISSING_DATA\";\n      break;\n    // Codes 8-12 conflict between various signals and various uninstaller error\n    // codes. Omit them to show the default error strings.\n    case 13:\n      error_string = \"RESULT_CODE_UNSUPPORTED_PARAM\";\n      break;\n    case 14:\n      error_string = \"RESULT_CODE_IMPORTER_HUNG\";\n      break;\n    // Code 15 conflicts between SIGTERM and RESULT_CODE_RESPAWN_FAILED. Omit\n    // it to show the default error string.\n    case 16:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_EXP1\";\n      break;\n    case 17:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_EXP2\";\n      break;\n    case 18:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_EXP3\";\n      break;\n    case 19:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_EXP4\";\n      break;\n    case 20:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_CANCEL\";\n      break;\n    case 21:\n      error_string = \"RESULT_CODE_PROFILE_IN_USE\";\n      break;\n    case 22:\n      error_string = \"RESULT_CODE_PACK_EXTENSION_ERROR\";\n      break;\n    case 23:\n      error_string = \"RESULT_CODE_UNINSTALL_EXTENSION_ERROR\";\n      break;\n    case 24:\n      error_string = \"RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED\";\n      break;\n    case 26:\n      error_string = \"RESULT_CODE_INSTALL_FROM_WEBSTORE_ERROR_2\";\n      break;\n    case 28:\n      error_string = \"RESULT_CODE_EULA_REFUSED\";\n      break;\n    case 29:\n      error_string = \"RESULT_CODE_SXS_MIGRATION_FAILED_NOT_USED\";\n      break;\n    case 30:\n      error_string = \"RESULT_CODE_ACTION_DISALLOWED_BY_POLICY\";\n      break;\n    case 31:\n      error_string = \"RESULT_CODE_INVALID_SANDBOX_STATE\";\n      break;\n    case 32:\n      error_string = \"RESULT_CODE_CLOUD_POLICY_ENROLLMENT_FAILED\";\n      break;\n    case 33:\n      error_string = \"RESULT_CODE_DOWNGRADE_AND_RELAUNCH\";\n      break;\n    case 34:\n      error_string = \"RESULT_CODE_GPU_EXIT_ON_CONTEXT_LOST\";\n      break;\n    case 131:\n      error_string = \"SIGQUIT\";\n      break;\n    case 132:\n      error_string = \"SIGILL\";\n      break;\n    case 133:\n      error_string = \"SIGTRAP\";\n      break;\n    case 134:\n      error_string = \"SIGABRT\";\n      break;\n    case 135:\n      error_string = \"SIGBUS (7)\";\n      break;\n    case 136:\n      error_string = \"SIGFPE\";\n      break;\n    case 137:\n      error_string = \"SIGKILL\";\n      break;\n    case 138:\n      error_string = \"SIGBUS (10)\";\n      break;\n    case 139:\n      error_string = \"SIGSEGV\";\n      break;\n    case 140:\n      error_string = \"SIGSYS\";\n      break;\n    case 258:\n      error_string = \"WAIT_TIMEOUT\";\n      break;\n    case 7006:\n      error_string = \"SBOX_FATAL_INTEGRITY\";\n      break;\n    case 7007:\n      error_string = \"SBOX_FATAL_DROPTOKEN\";\n      break;\n    case 7008:\n      error_string = \"SBOX_FATAL_FLUSHANDLES\";\n      break;\n    case 7009:\n      error_string = \"SBOX_FATAL_CACHEDISABLE\";\n      break;\n    case 7010:\n      error_string = \"SBOX_FATAL_CLOSEHANDLES\";\n      break;\n    case 7011:\n      error_string = \"SBOX_FATAL_MITIGATION\";\n      break;\n    case 7012:\n      error_string = \"SBOX_FATAL_MEMORY_EXCEEDED\";\n      break;\n    case 7013:\n      error_string = \"SBOX_FATAL_WARMUP\";\n      break;\n    case 7014:\n      error_string = \"SBOX_FATAL_BROKER_SHUTDOWN_HUNG\";\n      break;\n    case 36861:\n      error_string = \"Crashpad_NotConnectedToHandler\";\n      break;\n    case 36862:\n      error_string = \"Crashpad_FailedToCaptureProcess\";\n      break;\n    case 36863:\n      error_string = \"Crashpad_HandlerDidNotRespond\";\n      break;\n    case 85436397:\n      error_string = \"Crashpad_SimulatedCrash\";\n      break;\n    case 529697949:\n      error_string = \"CPP_EH_EXCEPTION\";\n      break;\n    case 533692099:\n      error_string = \"STATUS_GUARD_PAGE_VIOLATION\";\n      break;\n    case 536870904:\n      error_string = \"Out of Memory\";\n      break;\n    case 1066598273:\n      error_string = \"FACILITY_VISUALCPP/ERROR_PROC_NOT_FOUND\";\n      break;\n    case 1066598274:\n      error_string = \"FACILITY_VISUALCPP/ERROR_MOD_NOT_FOUND\";\n      break;\n    case 1073740760:\n      error_string = \"STATUS_INVALID_IMAGE_HASH\";\n      break;\n    case 1073740791:\n      error_string = \"STATUS_STACK_BUFFER_OVERRUN\";\n      break;\n    case 1073740940:\n      error_string = \"STATUS_HEAP_CORRUPTION\";\n      break;\n    case 1073741502:\n      error_string = \"STATUS_DLL_INIT_FAILED\";\n      break;\n    case 1073741510:\n      error_string = \"STATUS_CONTROL_C_EXIT\";\n      break;\n    case 1073741515:\n      error_string = \"STATUS_DLL_NOT_FOUND\";\n      break;\n    case 1073741571:\n      error_string = \"STATUS_STACK_OVERFLOW\";\n      break;\n    case 1073741659:\n      error_string = \"STATUS_BAD_IMPERSONATION_LEVEL\";\n      break;\n    case 1073741674:\n      error_string = \"STATUS_PRIVILEGED_INSTRUCTION\";\n      break;\n    case 1073741675:\n      error_string = \"STATUS_INTEGER_OVERFLOW\";\n      break;\n    case 1073741676:\n      error_string = \"STATUS_INTEGER_DIVIDE_BY_ZERO\";\n      break;\n    case 1073741677:\n      error_string = \"STATUS_FLOAT_UNDERFLOW\";\n      break;\n    case 1073741678:\n      error_string = \"STATUS_FLOAT_STACK_CHECK\";\n      break;\n    case 1073741679:\n      error_string = \"STATUS_FLOAT_OVERFLOW\";\n      break;\n    case 1073741680:\n      error_string = \"STATUS_FLOAT_INVALID_OPERATION\";\n      break;\n    case 1073741681:\n      error_string = \"STATUS_FLOAT_INEXACT_RESULT\";\n      break;\n    case 1073741682:\n      error_string = \"STATUS_FLOAT_DIVIDE_BY_ZERO\";\n      break;\n    case 1073741683:\n      error_string = \"STATUS_FLOAT_DENORMAL_OPERAND\";\n      break;\n    case 1073741684:\n      error_string = \"STATUS_ARRAY_BOUNDS_EXCEEDED\";\n      break;\n    case 1073741783:\n      error_string = \"STATUS_INVALID_UNWIND_TARGET\";\n      break;\n    case 1073741786:\n      error_string = \"STATUS_INVALID_DISPOSITION\";\n      break;\n    case 1073741787:\n      error_string = \"STATUS_NONCONTINUABLE_EXCEPTION\";\n      break;\n    case 1073741790:\n      error_string = \"STATUS_ACCESS_DENIED\";\n      break;\n    case 1073741794:\n      error_string = \"STATUS_INVALID_LOCK_SEQUENCE\";\n      break;\n    case 1073741795:\n      error_string = \"STATUS_ILLEGAL_INSTRUCTION\";\n      break;\n    case 1073741800:\n      error_string = \"STATUS_CONFLICTING_ADDRESSES\";\n      break;\n    case 1073741801:\n      error_string = \"STATUS_NO_MEMORY\";\n      break;\n    case 1073741811:\n      error_string = \"STATUS_INVALID_PARAMETER\";\n      break;\n    case 1073741816:\n      error_string = \"STATUS_INVALID_HANDLE\";\n      break;\n    case 1073741818:\n      error_string = \"STATUS_IN_PAGE_ERROR\";\n      break;\n    case 1073741819:\n      error_string = \"STATUS_ACCESS_VIOLATION\";\n      break;\n    case 1073741829:\n      error_string = \"STATUS_SEGMENT_NOTIFICATION\";\n      break;\n    case 1073741845:\n      error_string = \"STATUS_FATAL_APP_EXIT\";\n      break;\n    case 1072103400:\n      error_string = \"STATUS_CURRENT_TRANSACTION_NOT_VALID\";\n      break;\n    case 1072365548:\n      error_string = \"STATUS_SXS_CORRUPT_ACTIVATION_STACK\";\n      break;\n    case 1072365552:\n      error_string = \"STATUS_SXS_INVALID_DEACTIVATION\";\n      break;\n    case 1072365566:\n      error_string = \"STATUS_SXS_CANT_GEN_ACTCTX\";\n      break;\n    case 1073739514:\n      error_string = \"STATUS_VIRUS_INFECTED\";\n      break;\n    case 1073740004:\n      error_string = \"STATUS_INVALID_THREAD\";\n      break;\n    case 1073740016:\n      error_string = \"STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING\";\n      break;\n    case 1073740022:\n      error_string = \"STATUS_THREADPOOL_HANDLE_EXCEPTION\";\n      break;\n    case 1073740767:\n      error_string = \"STATUS_VERIFIER_STOP\";\n      break;\n    case 1073740768:\n      error_string = \"STATUS_ASSERTION_FAILURE\";\n      break;\n    case 1073740771:\n      error_string = \"STATUS_FATAL_USER_CALLBACK_EXCEPTION\";\n      break;\n    case 1073740777:\n      error_string = \"STATUS_INVALID_CRUNTIME_PARAMETER\";\n      break;\n    case 1073740782:\n      error_string = \"STATUS_DELAY_LOAD_FAILED\";\n      break;\n    case 1073740959:\n      error_string = \"STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT\";\n      break;\n    case 1073741131:\n      error_string = \"STATUS_FLOAT_MULTIPLE_TRAPS\";\n      break;\n    case 1073741132:\n      error_string = \"STATUS_FLOAT_MULTIPLE_FAULTS\";\n      break;\n    case 1073741205:\n      error_string = \"STATUS_DLL_INIT_FAILED_LOGOFF\";\n      break;\n    case 1073741212:\n      error_string = \"STATUS_RESOURCE_NOT_OWNED\";\n      break;\n    case 1073741431:\n      error_string = \"STATUS_TOO_LATE\";\n      break;\n    case 1073741511:\n      error_string = \"STATUS_ENTRYPOINT_NOT_FOUND\";\n      break;\n    case 1073741523:\n      error_string = \"STATUS_COMMITMENT_LIMIT\";\n      break;\n    case 1073741558:\n      error_string = \"STATUS_PROCESS_IS_TERMINATING\";\n      break;\n    case 1073741569:\n      error_string = \"STATUS_BAD_FUNCTION_TABLE\";\n      break;\n    case 1073741581:\n      error_string = \"STATUS_INVALID_PARAMETER_5\";\n      break;\n    case 1073741595:\n      error_string = \"STATUS_INTERNAL_ERROR\";\n      break;\n    case 1073741662:\n      error_string = \"STATUS_MEDIA_WRITE_PROTECTED\";\n      break;\n    case 1073741670:\n      error_string = \"STATUS_INSUFFICIENT_RESOURCES\";\n      break;\n    case 1073741701:\n      error_string = \"STATUS_INVALID_IMAGE_FORMAT\";\n      break;\n    case 1073741738:\n      error_string = \"STATUS_DELETE_PENDING\";\n      break;\n    case 1073741744:\n      error_string = \"STATUS_EA_TOO_LARGE\";\n      break;\n    case 1073741749:\n      error_string = \"STATUS_THREAD_IS_TERMINATING\";\n      break;\n    case 1073741756:\n      error_string = \"STATUS_QUOTA_EXCEEDED\";\n      break;\n    case 1073741757:\n      error_string = \"STATUS_SHARING_VIOLATION\";\n      break;\n    case 1073741766:\n      error_string = \"STATUS_OBJECT_PATH_NOT_FOUND\";\n      break;\n    case 1073741772:\n      error_string = \"STATUS_OBJECT_NAME_NOT_FOUND\";\n      break;\n    case 1073741784:\n      error_string = \"STATUS_BAD_STACK\";\n      break;\n    case 1073741785:\n      error_string = \"STATUS_UNWIND\";\n      break;\n    case 1073741788:\n      error_string = \"STATUS_OBJECT_TYPE_MISMATCH\";\n      break;\n    case 1073741796:\n      error_string = \"STATUS_INVALID_SYSTEM_SERVICE\";\n      break;\n    case 1073741820:\n      error_string = \"STATUS_INFO_LENGTH_MISMATCH\";\n      break;\n    case 1073741822:\n      error_string = \"STATUS_NOT_IMPLEMENTED\";\n      break;\n    case 1073741823:\n      error_string = \"STATUS_UNSUCCESSFUL\";\n      break;\n    case 2147483644:\n      error_string = \"STATUS_SINGLE_STEP\";\n      break;\n    case 2147483645:\n      error_string = \"STATUS_BREAKPOINT\";\n      break;\n    case 2147483646:\n      error_string = \"STATUS_DATATYPE_MISALIGNMENT\";\n      break;\n    default:\n      // Render small error values as integers, and larger values as hex.\n      error_string =\n          (error_code >= 0 && error_code < 65536)\n              ? base::NumberToString(error_code)\n              : base::StringPrintf(\"0x%08lX\",\n                                   static_cast<unsigned long>(error_code));\n  }\n\n  return base::UTF8ToUTF16(error_string);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Converts an error code to a corresponding error message string.","ghc_query":"error code message string conversion error handling localization"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_split_window\\split_window_control_menu.cc:41-65","function":"SplitWindowControlMenu::Run","codesnippet":"{\n  if (menu_runner_) {\n    menu_runner_->Cancel();\n  }\n\n  root_ = new views::MenuItemView(this);\n  root_->set_has_icons(true);\n\n  PopulateMenu(root_, BuildMenuModel());\n\n  menu_runner_ = std::make_unique<views::MenuRunner>(\n      root_,\n      views::MenuRunner::HAS_MNEMONICS | views::MenuRunner::CONTEXT_MENU);\n\n  // static_cast is safe to use here because the button's button controller is\n  // set by ourselves in InitButtons, it is the type of MenuButtonController.\n  menu_runner_->RunMenuAt(\n      parent,\n      static_cast<views::MenuButtonController*>(button->button_controller()),\n      button->GetBoundsInScreen(),\n      (is_opened_from_omnibox_ ||\n       features::edge::IsEdgeSplitWindowNewToolbarEnabled())\n          ? views::MenuAnchorPosition::kTopLeft\n          : views::MenuAnchorPosition::kBubbleTopLeft,\n      ui::mojom::MenuSourceType::kNone);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and displays a context menu with icons.","ghc_query":"context menu initialize display icons right-click popup menu"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\tabs\\split_tab_util.cc:18-43","function":"GetIndexOfLastActiveTab","codesnippet":"{\n  const std::vector<tabs::TabInterface*> split_tabs =\n      tab_strip_model->GetSplitData(split_id)->ListTabs();\n  // Check if a tab is activated first before comparing the WebContent's last\n  // focused time because the activation happens before focus time updates and\n  // wouldn't be accurate for tabs that just had its activation state changed.\n  for (tabs::TabInterface* tab : split_tabs) {\n    if (tab->IsActivated()) {\n      return tab_strip_model->GetIndexOfTab(tab);\n    }\n  }\n\n  tabs::TabInterface* const recently_active = *std::max_element(\n      split_tabs.begin(), split_tabs.end(),\n      [](tabs::TabInterface* a, tabs::TabInterface* b) {\n        auto get_last_focused_time_for_tab = [](const tabs::TabInterface* tab) {\n          return resource_coordinator::TabLifecycleUnitSource::\n              GetTabLifecycleUnitExternal(tab->GetContents())\n                  ->GetLastFocusedTime();\n        };\n        return get_last_focused_time_for_tab(b) >\n               get_last_focused_time_for_tab(a);\n      });\n\n  return tab_strip_model->GetIndexOfTab(recently_active);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Finds the index of the activated or most recently focused tab.","ghc_query":"tab index activated focused recently active tab selection"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\chromeos\\extensions\\login_screen\\login\\shared_session_handler.cc:72-109","function":"SharedSessionHandler::LaunchSharedManagedGuestSession","codesnippet":"{\n  if (!IsDeviceRestrictedManagedGuestSessionEnabled()) {\n    return extensions::login_api_errors::\n        kDeviceRestrictedManagedGuestSessionNotEnabled;\n  }\n\n  if (session_manager::SessionManager::Get()->session_state() !=\n      session_manager::SessionState::LOGIN_PRIMARY) {\n    return extensions::login_api_errors::kLoginScreenIsNotActive;\n  }\n\n  CHECK(session_secret_.empty());\n  CHECK(user_secret_hash_.empty());\n  CHECK(user_secret_salt_.empty());\n\n  auto* existing_user_controller =\n      ash::ExistingUserController::current_controller();\n  if (existing_user_controller->IsSigninInProgress())\n    return extensions::login_api_errors::kAnotherLoginAttemptInProgress;\n\n  const user_manager::User* user = GetManagedGuestSessionUser();\n  if (user == nullptr)\n    return extensions::login_api_errors::kNoManagedGuestSessionAccounts;\n\n  if (!CreateAndSetUserSecretHashAndSalt(password))\n    return extensions::login_api_errors::kScryptFailure;\n\n  session_secret_ = GenerateRandomString(kSessionSecretLength);\n\n  ash::UserContext context(user_manager::UserType::kPublicAccount,\n                           user->GetAccountId());\n  context.SetKey(ash::Key(session_secret_));\n  context.SetCanLockManagedGuestSession(true);\n  existing_user_controller->Login(context, ash::SigninSpecifics());\n\n  return std::nullopt;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initiates a login process for a managed guest session if conditions are met.","ghc_query":"managed guest session login process initiate conditions"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\login\\screens\\pin_setup_screen.cc:142-194","function":"PinSetupScreen::GetSkipReason","codesnippet":"{\n  CHECK(hardware_support_.has_value());\n\n  if (context.skip_post_login_screens_for_tests) {\n    return SkipReason::kSkippedForTests;\n  }\n\n  if (!context.extra_factors_token.has_value()) {\n    return SkipReason::kMissingExtraFactorsToken;\n  }\n\n  if (!ash::AuthSessionStorage::Get()->IsValid(\n          context.extra_factors_token.value())) {\n    return SkipReason::kExpiredToken;\n  }\n\n  if (chrome_user_manager_util::IsManagedGuestSessionOrEphemeralLogin()) {\n    return SkipReason::kManagedGuestSessionOrEphemeralLogin;\n  }\n\n  AccountId account_id = ash::AuthSessionStorage::Get()\n                             ->Peek(context.extra_factors_token.value())\n                             ->GetAccountId();\n  if (cryptohome_pin_engine_.ShouldSkipSetupBecauseOfPolicy(account_id)) {\n    return SkipReason::kNotAllowedByPolicy;\n  }\n\n  // Hardware capability check. In order for the screen to be shown, the device\n  // needs to support PIN for login, OR be a tablet device.\n  const bool is_device_a_tablet =\n      display::Screen::GetScreen()->InTabletMode() ||\n      switches::ShouldOobeUseTabletModeFirstRun();\n  const bool has_login_support =\n      hardware_support_.value() == HardwareSupport::kLoginCompatible;\n  if (!(is_device_a_tablet || has_login_support)) {\n    return SkipReason::kUsupportedHardware;\n  }\n\n  // Further checks for the PIN-only setup mode. It needs to have login support\n  // and it is only available for consumers.\n  if (IsInSetupMode(PinSetupMode::kSetupAsPrimaryFactor, context)) {\n    if (!has_login_support) {\n      return SkipReason::kNotSupportedAsPrimaryFactor;\n    }\n\n    if (IsUserEnterpriseManaged()) {\n      return SkipReason::kNotSupportedAsPrimaryFactorForManagedUsers;\n    }\n  }\n\n  // Will not be skipped.\n  return std::nullopt;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the reason for skipping a login screen based on various conditions.","ghc_query":"login screen skip reason conditions authentication bypass"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\metrics\\structured\\storage_manager_impl.cc:164-201","function":"StorageManagerImpl::OnFlushCompleted","codesnippet":"{\n  // If |key| has a value then the events were successfully written to disk.\n  // Otherwise, there was an error while preparing the events or while writing\n  // the file.\n  if (key.has_value()) {\n    LogStorageManagerFlushStatus(StorageManagerFlushStatus::kSuccessful);\n    NotifyOnFlushed(*key);\n    return;\n  }\n\n  switch (key.error()) {\n    case FlushError::kQuotaExceeded:\n      LogStorageManagerFlushStatus(StorageManagerFlushStatus::kQuotaExceeded);\n      // The file is already flushed, just cleanup until we are under quota.\n      if (dropping_flushed_queued_.load()) {\n        break;\n      }\n      dropping_flushed_queued_.store(true);\n      task_runner_->PostTask(\n          FROM_HERE,\n          base::BindOnce(&StorageManagerImpl::DropFlushedUntilUnderQuota,\n                         weak_factory_.GetWeakPtr()));\n      break;\n    // The write failed and we are unable to recover. The events that were being\n    // written are unrecoverable and are lost.\n    // TODO(b/342008451): Recover lost events when writing flushed events fails.\n    case FlushError::kDiskFull:\n      LogStorageManagerFlushStatus(StorageManagerFlushStatus::kDiskFull);\n      break;\n    case FlushError::kWriteError:\n      LogStorageManagerFlushStatus(StorageManagerFlushStatus::kWriteError);\n      break;\n    case FlushError::kSerializationFailed:\n      LogStorageManagerFlushStatus(\n          StorageManagerFlushStatus::kEventSerializationError);\n      break;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles the outcome of writing events to disk, logging the status and managing errors.","ghc_query":"writing events disk log status manage errors file operation"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\updater\\app\\app_install.cc:120-156","function":"AppInstall::SendPing","codesnippet":"{\n  base::ThreadPool::CreateSequencedTaskRunner(\n      {base::MayBlock(), base::WithBaseSyncPrimitives()})\n      ->PostTask(\n          FROM_HERE,\n          base::BindOnce(\n              [](base::OnceClosure callback, UpdaterScope scope,\n                 int exit_code) {\n                if (exit_code == kErrorOk || !UsageStatsProvider::Create(scope)\n                                                  ->AnyAppEnablesUsageStats()) {\n                  std::move(callback).Run();\n                  return;\n                }\n\n                update_client::CrxComponent ping_data;\n                ping_data.app_id = kUpdaterAppId;\n                ping_data.version = base::Version(kUpdaterVersion);\n                ping_data.requires_network_encryption = false;\n                update_client::UpdateClientFactory(CreatePingConfigurator())\n                    ->SendPing(\n                        ping_data,\n                        {\n                            .event_type =\n                                update_client::protocol_request::kEventInstall,\n                            .result = update_client::protocol_request::\n                                kEventResultError,\n                            .error_code = exit_code,\n                        },\n                        base::BindOnce(\n                            [](base::OnceClosure callback,\n                               update_client::Error) {\n                              std::move(callback).Run();\n                            },\n                            std::move(callback)));\n              },\n              base::BindPostTaskToCurrentDefault(std::move(callback)),\n              updater_scope(), exit_code));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sends a ping with error data if usage stats are enabled and the exit code is not OK.","ghc_query":"ping error data usage stats exit code metrics reporting crash"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\services\\speech\\audio_source_fetcher_impl.cc:78-144","function":"AudioSourceFetcherImpl::Start","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  // If we've already started fetching audio from this device with these params,\n  // return early. Otherwise start over and reset.\n  if (is_started_) {\n    if (device_id == device_id_ && audio_parameters.Equals(audio_parameters_)) {\n      LOG(ERROR)\n          << \"AudioSourceFetcher was already running, and was asked to restart \"\n             \"with the same device ID and audio parameters. Doing nothing.\";\n      return;\n    } else {\n      Stop();\n    }\n  }\n\n  device_id_ = device_id;\n  audio_parameters_ = audio_parameters;\n\n  // Resample only if the recognizer is server based and the device's sample\n  // rate is > 16khz.\n  if (is_server_based_ && audio_parameters_.sample_rate() >\n                              kServerBasedRecognitionAudioSampleRate) {\n    server_based_recognition_params_ = media::AudioParameters(\n        media::AudioParameters::AUDIO_PCM_LOW_LATENCY,\n        is_multi_channel_supported_ ? audio_parameters_.channel_layout_config()\n                                    : media::ChannelLayoutConfig::Mono(),\n        kServerBasedRecognitionAudioSampleRate,\n        media::AudioTimestampHelper::TimeToFrames(\n            kServerBasedRecognitionAudioBufferSize,\n            kServerBasedRecognitionAudioSampleRate));\n\n    // Bind to current loop to ensure the `ConvertingAudioFifo::OutputCallback`\n    // and `ConvertingAudioFifo::Push` to be called on same thread.\n    converter_ = std::make_unique<media::ConvertingAudioFifo>(\n        audio_parameters_, server_based_recognition_params_.value());\n    resample_callback_ = base::BindPostTaskToCurrentDefault(\n        base::BindRepeating(&AudioSourceFetcherImpl::SendAudioToResample,\n                            weak_factory_.GetWeakPtr()));\n  }\n\n  auto audio_log_remote = VLOG_IS_ON(1)\n                              ? audio_log_receiver_.BindNewPipeAndPassRemote()\n                              : mojo::NullRemote();\n  audio_capturer_source_ = audio::CreateInputDevice(\n      std::move(stream_factory), device_id_,\n      audio::DeadStreamDetection::kEnabled, std::move(audio_log_remote));\n  DCHECK(audio_capturer_source_);\n\n  send_error_callback_ = base::BindPostTaskToCurrentDefault(base::BindRepeating(\n      &AudioSourceFetcherImpl::SendError, weak_factory_.GetWeakPtr()));\n\n  // TODO(crbug.com/40753481): Check implementation / sandbox policy on Mac and\n  // Windows.\n#if BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_LINUX)\n  is_started_ = true;\n  // Initialize the AudioCapturerSource with |this| as the CaptureCallback,\n  // get the parameters for the device ID, then start audio capture.\n  send_audio_callback_ = base::BindPostTaskToCurrentDefault(base::BindRepeating(\n      &AudioSourceFetcherImpl::SendAudioToSpeechRecognitionService,\n      weak_factory_.GetWeakPtr()));\n  GetAudioCapturerSource()->Initialize(audio_parameters_, this);\n  GetAudioCapturerSource()->Start();\n#endif\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and starts audio capture for speech recognition, handling device and parameter changes.","ghc_query":"audio capture speech recognition initialize start device parameters"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\apps\\link_capturing\\web_apps_intent_picker_delegate.cc:118-173","function":"WebAppsIntentPickerDelegate::LoadSingleAppIcon","codesnippet":"{\n  CHECK(ShouldShowIntentPickerWithApps());\n  CHECK(provider_);\n  CHECK(entry_type == PickerEntryType::kWeb ||\n        entry_type == PickerEntryType::kMacOs);\n\n  if (entry_type == PickerEntryType::kWeb) {\n    web_app::WebAppIconManager& icon_manager = provider_->icon_manager();\n    // First, iterate over all icons with the given order of purposes, and\n    // verify if there exists an icon that can be loaded. The order of purposes\n    // helps ensure we first look for ANY and MASKABLE icons before going for\n    // MONOCHROME.\n    std::vector<web_app::IconPurpose> ordered_purpose = {\n        web_app::IconPurpose::MASKABLE, web_app::IconPurpose::ANY,\n        web_app::IconPurpose::MONOCHROME};\n    auto size_and_purpose =\n        icon_manager.FindIconMatchBigger(app_id, ordered_purpose, size_in_dep);\n    if (!size_and_purpose.has_value()) {\n      std::move(icon_loaded_callback).Run(ui::ImageModel());\n      return;\n    }\n\n    web_app::IconPurpose purpose_to_get = size_and_purpose.value().purpose;\n    auto transform_bitmaps_to_icon_metadata = base::BindOnce(\n        [](std::map<web_app::SquareSizePx, SkBitmap> icons) -> ui::ImageModel {\n          bool is_valid_icon = !icons.empty();\n          if (!is_valid_icon) {\n            return ui::ImageModel();\n          }\n\n          CHECK_EQ(icons.size(), 1u);\n          return ui::ImageModel::FromImageSkia(\n              gfx::ImageSkia::CreateFrom1xBitmap(icons.begin()->second));\n        });\n    icon_manager.ReadIconAndResize(app_id, purpose_to_get, size_in_dep,\n                                   std::move(transform_bitmaps_to_icon_metadata)\n                                       .Then(std::move(icon_loaded_callback)));\n  } else if (entry_type == apps::PickerEntryType::kMacOs) {\n#if BUILDFLAG(IS_MAC)\n    // Read from the cached app information if an app with universal links were\n    // found.\n    ui::ImageModel mac_app_icon;\n    if (mac_app_info_.has_value()) {\n      CHECK_EQ(mac_app_info_->launch_name, app_id);\n      mac_app_icon = ui::ImageModel::FromImage(\n          mac_app_info_->icon.CreateExact(gfx::Size(size_in_dep, size_in_dep)));\n    }\n    std::move(icon_loaded_callback).Run(mac_app_icon);\n#else\n    NOTREACHED();\n#endif  // BUILDFLAG(IS_MAC)\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Loads and returns an app icon based on the specified entry type and platform.","ghc_query":"app icon load entry type platform application icon loading"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\shelf\\app_service\\app_service_app_window_crostini_tracker.cc:224-258","function":"AppServiceAppWindowCrostiniTracker::GetShelfAppId","codesnippet":"{\n  if (ShouldSkipWindow(window)) {\n    return std::string();\n  }\n\n  // Handle browser windows.\n  Browser* browser = chrome::FindBrowserWithWindow(window);\n  if (browser) {\n    return std::string();\n  }\n\n  // Currently Crostini can only be used from the primary profile. In the\n  // future, this may be replaced by some way of matching the container that\n  // runs this app with the user that owns it.\n  Profile* primary_account_profile =\n      ash::ProfileHelper::Get()->GetProfileByAccountId(\n          user_manager::UserManager::Get()->GetPrimaryUser()->GetAccountId());\n  std::string shelf_app_id = guest_os::GetGuestOsShelfAppId(\n      primary_account_profile, exo::GetShellApplicationId(window),\n      exo::GetShellStartupId(window));\n\n  // When install a new Crostini app and run it directly, Crostini might not get\n  // the correct app id yet when `window` is created, but use an unregistered\n  // app id for a short term. Then the unregistered app id is saved in\n  // InstanceRegistry for `window`. So when the app id is set for `window`\n  // later, the app id inconsistent DCHECK is hit, which could affect the\n  // instance saved in InstanceRegistry. To prevent the updating for `window` in\n  // InstanceRegistry, call MaybeModifyInstance to check the saved app id and\n  // the expected shelf_app_id, and if they are not consistent, modify the app\n  // id to use `shelf_app_id`.\n  if (!shelf_app_id.empty()) {\n    MaybeModifyInstance(primary_account_profile, window, shelf_app_id);\n  }\n  return shelf_app_id;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates and potentially updates the app ID for a Crostini window.","ghc_query":"Crostini window app ID generate update Linux container application"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_auth\\edge_linked_account_info_finder.cc:223-285","function":"HandleLinkeAccountInfoFetchCallResponse","codesnippet":"{\n  DCHECK_CURRENTLY_ON(EdgeThreadType::UI);\n\n  // handle response body\n  EdgeAuthErrorInfo error_info = GetLinkedAccountUrlRequestErrorInfo(\n      state_holder->simple_url_loader.get(), response_body.get());\n\n  auto linked_account_info_fetch_error =\n      EdgeAuthErrorToEdgeLinkedAccountInfoFetchError(error_info);\n  EdgeLinkedAccountInfoAcquireResult result;\n  auto exit_fn = base::MakeScopeExit([&] {\n    LogLinkedAccountFetchErrorTelemetry(linked_account_info_fetch_error,\n                                        EdgeAccountType::kAAD);\n    state_holder->RunFailureCallback(error_info,\n                                     linked_account_info_fetch_error,\n                                     result.is_tenant_supported);\n  });\n\n  if (response_body && !response_body->empty()) {\n    auto json_object = base::JSONReader::Read(*response_body);\n    if (!json_object) {\n      error_info.primary_error = EdgeAuthErrorType::kUrlRequestError;\n      error_info.secondary_error =\n          EdgeAuthSecondaryErrorType::kJsonParsingFailed;\n      return;\n    }\n\n    auto error = json_object->FindIntKey(kErrorCode);\n    if (error != 5001) {\n      result.is_tenant_supported = true;\n    }\n\n    // When link to MSA account was not found for the user i.e either unlinked\n    // or not linked\n    if (error != 5005) {\n      const std::string* anid_str = json_object->GetDict().FindString(kAnid);\n      if (!anid_str || anid_str->empty()) {\n        linked_account_info_fetch_error =\n            EdgeLinkedAccountInfoFetchErrors::kMissingAnid;\n        return;\n      }\n\n      const std::string* email_str = json_object->GetDict().FindString(kEmail);\n      if (!email_str || email_str->empty()) {\n        linked_account_info_fetch_error =\n            EdgeLinkedAccountInfoFetchErrors::kMissingEmail;\n        return;\n      }\n      result.linked_account_info.msa_anid = *anid_str;\n      result.linked_account_info.msa_email = *email_str;\n      result.linked_account_info.account_type = EdgeAccountType::kMSA;\n      state_holder->RunSuccessCallback(result);\n    } else {\n      linked_account_info_fetch_error =\n          EdgeLinkedAccountInfoFetchErrors::kLinkNotFound;\n      state_holder->RunFailureCallback(error_info,\n                                       linked_account_info_fetch_error,\n                                       result.is_tenant_supported);\n    }\n    exit_fn.Dismiss();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Processes response body to fetch and validate linked account information.","ghc_query":"response body fetch validate linked account information API response"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\policy\\messaging_layer\\upload\\file_upload_job.cc:319-359","function":"FileUploadJob::EventHelper::RepostAndComplete","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  // Post a new event reflecting its state to track later.\n  // If `job_` is not available, do not allow to upload the current event.\n  if (!job_) {\n    Complete(Status(error::DATA_LOSS, \"Upload Job has been removed\"));\n    base::UmaHistogramEnumeration(reporting::kUmaDataLossErrorReason,\n                                  DataLossErrorReason::UPLOAD_JOB_REMOVED,\n                                  DataLossErrorReason::MAX_VALUE);\n    return;\n  }\n  // Job is still around.\n  // If the job failed, post retry event unless retry count will drop to 0.\n  if (job_->tracker().has_status() && job_->settings().retry_count() > 1) {\n    // Post retry event.\n    PostRetry();\n  }\n\n  // Update the new event with its status.\n  if (job_->tracker().access_parameters().empty() &&\n      !job_->tracker().has_status()) {\n    // The job_ is in progress (not succeeded and not failed),\n    // flag the new tracking event to be processed when reaching uploader.\n    record_copy_.set_needs_local_unencrypted_copy(true);\n  }\n  // Copy its tracking state to the new event.\n  *log_upload_event_.mutable_upload_settings() = job_->settings();\n  *log_upload_event_.mutable_upload_tracker() = job_->tracker();\n  // Patch the copy event.\n  if (!log_upload_event_.SerializeToString(record_copy_.mutable_data())) {\n    Complete(Status(error::INVALID_ARGUMENT,\n                    base::StrCat({\"Updated event \",\n                                  Destination_Name(record_copy_.destination()),\n                                  \" failed to serialize\"})));\n    return;\n  }\n  // Repost the copy event and return result via `Complete`.\n  FileUploadJob::AddRecordToStorage(\n      priority_, std::move(record_copy_),\n      base::BindPostTaskToCurrentDefault(base::BindOnce(\n          &EventHelper::Complete, weak_ptr_factory_.GetWeakPtr())));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles event upload by checking job status, retrying if needed, and updating event tracking information.","ghc_query":"event upload job status retry event tracking upload retry mechanism"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\browsing_data\\core\\browsing_data_policies_utils.cc:42-97","function":"AppendSyncTypesIfRequired","codesnippet":"{\n  // Map of browsing data types to sync types that need to be disabled for\n  // them.\n  static constexpr auto kDataToSyncTypesMap =\n      base::MakeFixedFlatMap<std::string_view, syncer::UserSelectableTypeSet>(\n          {{policy_data_types::kBrowsingHistoryName,\n            {syncer::UserSelectableType::kHistory,\n             syncer::UserSelectableType::kTabs}},\n           {policy_data_types::kPasswordSigninName,\n            {syncer::UserSelectableType::kPasswords}},\n           {policy_data_types::kSiteSettingsName,\n            {syncer::UserSelectableType::kPreferences}},\n#if EXCLUDED_FROM_EDGE\n           {policy_data_types::kAutofillName,\n            {syncer::UserSelectableType::kAutofill,\n             syncer::UserSelectableType::kPayments}},\n#else\n           {policy_data_types::kAutofillName,\n            {syncer::UserSelectableType::kAutofill}},\n#endif  // EXCLUDED_FROM_EDGE\n           {policy_data_types::kDownloadHistoryName, {}},\n           {policy_data_types::kCookiesAndOtherSiteDataName,\n            {syncer::UserSelectableType::kCookies}},\n           {policy_data_types::kCachedImagesAndFilesName, {}},\n           {policy_data_types::kHostedAppDataName, {}}});\n\n  // When a new sync type or browsing data type is introduced in the code,\n  // kDataToSyncTypesMap should be updated if needed to ensure that browsing\n  // data that can be cleared by policy is not already synced across devices.\n  static_assert(static_cast<int>(syncer::UserSelectableType::kLastType) ==\n#if !BUILDFLAG(IS_IOS)\n                    13,\n#else\n                    12,\n#endif  // !BUILDFLAG(IS_IOS)\n                \"It looks like a sync type was added or removed. Please update \"\n                \"`kDataToSyncTypesMap` value maps above if it affects any of \"\n                \"the browsing data types.\");\n  // Change to +3 from +1 to match the kDataToSyncTypesMap with BrowsingDataType\n  // enums EDGE_UWP,MF_PROTECTED_MEDIA_DATA since policy_data_types does not\n  // contain these types\n  static_assert(\n      static_cast<int>(PolicyDataType::kNumTypes) ==\n          static_cast<int>(kDataToSyncTypesMap.size()),\n      \"It looks like a browsing data type that can be managed by policy was \"\n      \"added or removed. Please update `kDataToSyncTypesMap` above to include \"\n      \"the new type and the sync types it maps to if this data is synced.\");\n\n  const auto it = kDataToSyncTypesMap.find(browsing_data_type.GetString());\n  if (it == kDataToSyncTypesMap.end()) {\n    return;\n  }\n  for (const syncer::UserSelectableType sync_type_needed : it->second) {\n    sync_types->Put(sync_type_needed);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps browsing data types to corresponding sync types that need to be disabled.","ghc_query":"browsing data types sync types disable mapping sync preferences"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\vr\\elements\\text.cc:175-213","function":"TextTexture::PrepareDrawText","codesnippet":"{\n  DCHECK(bounds);\n  lines_.clear();\n\n  gfx::Rect rect(*bounds);\n  std::vector<std::u16string> strings;\n  gfx::ElideRectangleText(text, font_list, bounds->width(),\n                          bounds->height() ? bounds->height() : INT_MAX,\n                          gfx::WRAP_LONG_WORDS, &strings);\n\n  int height = 0;\n  int line_height = 0;\n  for (size_t i = 0; i < strings.size(); i++) {\n    std::unique_ptr<gfx::RenderText> render_text =\n        gfx::RenderText::CreateRenderText();\n    UpdateRenderText(render_text.get(), strings[i], font_list, color);\n\n    if (i == 0) {\n      // Measure line and center text vertically.\n      line_height = render_text->GetStringSize().height();\n      rect.set_height(line_height);\n      if (bounds->height()) {\n        const int text_height = strings.size() * line_height;\n        rect += gfx::Vector2d(0, (bounds->height() - text_height) / 2);\n      }\n    }\n\n    render_text->SetDisplayRect(rect);\n    height += line_height;\n    rect += gfx::Vector2d(0, line_height);\n    lines_.push_back(std::move(render_text));\n  }\n\n  // Set calculated height.\n  if (bounds->height() == 0)\n    bounds->set_height(height);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Renders and vertically centers elided text within specified bounds.","ghc_query":"render elided text vertical center bounds truncate text overflow"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\user_education\\common\\tutorial\\tutorial.cc:379-408","function":"Tutorial::Builder::BuildFromDescription","codesnippet":"{\n  Tutorial::Builder builder;\n  builder.SetContext(context);\n\n  // Last step doesn't have a progress counter.\n  const int max_progress = CountProgress(description.steps) - 1;\n  int current_progress = 0;\n  for (const auto& step : description.steps) {\n    builder.AddStep(BuildFromDescriptionStep(\n        step, max_progress, current_progress,\n        &step == &description.steps.back(), description.can_be_restarted,\n        description.complete_button_text_id, tutorial_service));\n  }\n  DCHECK_EQ(current_progress, max_progress + 1);\n\n  // Note that the step number we are using here is not the same as the the\n  // InteractionSequence::AbortCallback step (`sequence_step`) which counts all\n  // steps; `current_step` in this case is the visual bubble count, which does\n  // not count hidden steps.\n  builder.SetAbortedCallback(base::BindOnce(\n      [](int step_number, TutorialService* tutorial_service,\n         const ui::InteractionSequence::AbortedData&) {\n        tutorial_service->AbortTutorial(step_number);\n      },\n      max_progress, tutorial_service));\n\n  return builder.Build();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Builds and returns a tutorial sequence with progress tracking and abort functionality.","ghc_query":"tutorial sequence progress tracking abort functionality user education"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\storage_monitor\\storage_info.cc:93-121","function":"StorageInfo::CrackDeviceId","codesnippet":"{\n  size_t prefix_length = device_id.find_first_of(':');\n  std::string prefix = prefix_length != std::string::npos\n                           ? device_id.substr(0, prefix_length + 1)\n                           : std::string();\n\n  Type found_type;\n  if (prefix == kRemovableMassStorageWithDCIMPrefix) {\n    found_type = REMOVABLE_MASS_STORAGE_WITH_DCIM;\n  } else if (prefix == kRemovableMassStorageNoDCIMPrefix) {\n    found_type = REMOVABLE_MASS_STORAGE_NO_DCIM;\n  } else if (prefix == kFixedMassStoragePrefix) {\n    found_type = FIXED_MASS_STORAGE;\n  } else if (prefix == kMtpPtpPrefix) {\n    found_type = MTP_OR_PTP;\n  } else if (prefix == kMacImageCapturePrefix) {\n    found_type = MAC_IMAGE_CAPTURE;\n  } else {\n    // Users may have legacy device IDs in their profiles, like iPhoto, iTunes,\n    // or Picasa. Just reject them as invalid devices here.\n    return false;\n  }\n  if (type)\n    *type = found_type;\n\n  if (unique_id)\n    *unique_id = device_id.substr(prefix_length + 1);\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Identifies device type based on its ID prefix and extracts the unique ID.","ghc_query":"device type ID prefix extract unique ID identification"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_perf_center\\edge_perf_center_ui.cc:540-582","function":"EdgePerfCenterUI::LoadPerfSectionState","codesnippet":"{\n  PrefService* pref = profile->GetPrefs();\n  CHECK(pref);\n\n  base::Value::Dict hub_data;\n  hub_data.Set(\"performanceMode\",\n               edge::performance_control_center::PerfCenterController::\n                   GetPerformanceModePrefValue());\n  hub_data.Set(\"sleepingTabsEnabled\",\n               edge::sleeping_tabs::SleepingTabsManager::IsSleepingTabsTurnedOn(\n                   profile));\n  hub_data.Set(\"sleepingTabsManaged\",\n               pref->IsManagedPreference(prefs::kSleepingTabsEnabled));\n  hub_data.Set(\"performanceDetector\",\n               pref->GetBoolean(prefs::kEdgePerfCenterPerformanceDetector));\n  hub_data.Set(\"performanceModeMainToggle\",\n               edge::performance_control_center::PerfCenterController::\n                   GetPerformanceModeMainTogglePrefValue());\n  hub_data.Set(\"performanceModeActive\",\n               edge::performance_control_center::PerfCenterFeature::\n                   IsEfficiencyModeV1Active());\n  hub_data.Set(\"efficiencyModeV2Active\",\n               edge::performance_control_center::PerfCenterFeature::\n                   IsEfficiencyModeV2Active());\n  hub_data.Set(\"performanceButtonPinnedState\", false /*not used in this mode*/);\n  hub_data.Set(\"efficiencyModeToggleManaged\",\n               edge::performance_control_center::PerfCenterController::\n                   IsEfficiencyModeToggleManaged());\n\n  bool is_game_mode_active = false;\n\n#if BUILDFLAG(IS_WIN) && defined(ARCH_CPU_64_BITS)  // Perf game mode\n  is_game_mode_active =\n      edge::performance_control_center::PerfGameModeController::IsOn();\n#endif  // BUILDFLAG(IS_WIN) && defined(ARCH_CPU_64_BITS)\n\n  hub_data.Set(\"perfGameModeActive\", is_game_mode_active);\n\n  base::Value::Dict hub_data_root;\n  hub_data_root.Set(\"perfSectionInitialState\", std::move(hub_data));\n\n  source->AddLocalizedStrings(hub_data_root);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Collects and sets performance-related preferences and states for a user profile.","ghc_query":"performance preferences user profile state collection browser performance"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\location_bar\\selected_keyword_view.cc:47-74","function":"SelectedKeywordView::GetKeywordLabelNames","codesnippet":"{\n  KeywordLabelNames names;\n  if (service) {\n    const TemplateURL* template_url =\n        service->GetTemplateURLForKeyword(keyword);\n    bool is_extension_keyword = false;\n    bool is_gemini_keyword = false;\n    bool is_page_keyword =\n        template_url &&\n        template_url->starter_pack_id() == TemplateURLStarterPackData::kPage;\n    names.short_name = service->GetKeywordShortName(\n        keyword, &is_extension_keyword, &is_gemini_keyword);\n    if (is_gemini_keyword) {\n      names.full_name = l10n_util::GetStringFUTF16(\n          IDS_OMNIBOX_SELECTED_KEYWORD_ASK_TEXT, names.short_name);\n    } else if (is_extension_keyword) {\n      names.full_name = names.short_name;\n    } else if (is_page_keyword) {\n      names.full_name =\n          l10n_util::GetStringUTF16(IDS_STARTER_PACK_PAGE_KEYWORD_TEXT);\n    } else {\n      names.full_name = l10n_util::GetStringFUTF16(IDS_OMNIBOX_KEYWORD_TEXT_MD,\n                                                   names.short_name);\n    }\n  }\n  return names;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates keyword label names based on the keyword type and service data.","ghc_query":"keyword label names generate keyword type service data omnibox search"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_screenshot\\screenshot_key_manager_impl.cc:355-386","function":"ScreenshotKeyManagerImpl::OnKeyPressed","codesnippet":"{\n  bool has_active_browser = false;\n  auto* browser = GetOneBrowser(&has_active_browser);\n  if (IsDLPBlocked(browser)) {\n    return;\n  }\n  auto trigger = has_active_browser ? ShortcutTrigger::GlobalForeground\n                                    : ShortcutTrigger::GlobalBackground;\n  if (accelerator == covision_key_config_.accelerator) {\n    if (IsLensBlockedByPolicyOrSettings(browser)) {\n      return;\n    }\n    base::UmaHistogramEnumeration(kCovisionTrigger, trigger);\n    if (has_active_browser && browser->is_type_normal()) {\n      ContentOverlay::Get(browser).Toggle();\n      RecordLensStart(StartLensFrom::HotkeyInEdge);\n    } else {\n      StartLensOutsideEdge(browser, false);\n    }\n  } else {\n    base::UmaHistogramEnumeration(kScreenshotTrigger, trigger);\n    LaunchScreenshot()\n        .FromEntry(ScreenshotEntry::ScreenshotShortcut)\n        .Execute(EnsureProfile(browser));\n    if (edge::webshot::features::IsWebCaptureUniformExperienceEnabled()) {\n      // Screenshot invocations using global shortcut will also be part of\n      // trigger population.\n      edge::webshot::LogWebCaptureTriggerEvent(browser);\n    }\n  }\n  base::FeatureList::TriggerUsage(features::kEdgeScreenshot);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles shortcut actions for either launching a screenshot tool or starting a lens feature based on browser state and configuration.","ghc_query":"shortcut actions screenshot tool lens feature browser state configuration"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\performance_controls\\memory_saver_chip_view.cc:80-145","function":"MemorySaverChipView::UpdateImpl","codesnippet":"{\n  content::WebContents* const web_contents = GetWebContents();\n  if (!web_contents) {\n    return;\n  }\n\n  auto* const tab = tabs::TabInterface::GetFromContents(web_contents);\n  if (!tab) {\n    return;\n  }\n  MemorySaverChipTabHelper* const tab_helper =\n      tab->GetTabFeatures()->memory_saver_chip_helper();\n  CHECK(tab_helper);\n  auto chip_state = tab_helper->chip_state();\n\n  if (chip_state != memory_saver::ChipState::HIDDEN) {\n    if (!tab_helper->ShouldChipAnimate()) {\n      return;\n    }\n\n    switch (chip_state) {\n      case memory_saver::ChipState::EXPANDED_EDUCATION: {\n        SetVisible(true);\n        AnimateIn(IDS_MEMORY_SAVER_CHIP_LABEL);\n        RecordMemorySaverChipState(MemorySaverChipState::kExpandedEducation);\n        break;\n      }\n      case memory_saver::ChipState::EXPANDED_WITH_SAVINGS: {\n        SetVisible(true);\n        int64_t const memory_savings =\n            memory_saver::GetDiscardedMemorySavingsInBytes(web_contents);\n        std::u16string memory_savings_string = ui::FormatBytes(memory_savings);\n        SetLabel(l10n_util::GetStringFUTF16(IDS_MEMORY_SAVER_CHIP_SAVINGS_LABEL,\n                                            {memory_savings_string}),\n                 l10n_util::GetStringFUTF16(\n                     IDS_MEMORY_SAVER_CHIP_WITH_SAVINGS_ACCNAME,\n                     {memory_savings_string}));\n        AnimateIn(std::nullopt);\n        RecordMemorySaverChipState(MemorySaverChipState::kExpandedWithSavings);\n        break;\n      }\n      case memory_saver::ChipState::COLLAPSED_FROM_EXPANDED: {\n        SetVisible(true);\n        UnpauseAnimation();\n        AnimateOut();\n        ResetSlideAnimation(false);\n        break;\n      }\n      case memory_saver::ChipState::COLLAPSED: {\n        SetVisible(true);\n        GetViewAccessibility().SetName(chip_accessible_label_);\n        RecordMemorySaverChipState(MemorySaverChipState::kCollapsed);\n        break;\n      }\n      default: {\n        NOTREACHED();\n      }\n    }\n  } else {\n    AnimateOut();\n    ResetSlideAnimation(false);\n    SetVisible(false);\n  }\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  IconLabelBubbleView::UpdateExpandedCollapsedAccessibleState();\n#endif\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates the visibility and animation state of a memory saver chip based on its current state.","ghc_query":"memory saver chip visibility animation state update performance UI"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\services\\on_device_translation\\test\\mock_translate_kit_lib.cc:244-266","function":"uintptr_t\nTranslateKitCreateTranslator","codesnippet":"{\n  CHECK(kit_ptr);\n  if (std::string_view(source_lang.language_code,\n                       source_lang.language_code_size) == \"crash\") {\n    LOG(ERROR) << \"Intentionally terminating current process to simulate\"\n                  \" the on device translation service crash for testing.\";\n    // Use `TerminateCurrentProcessImmediately()` instead of `CHECK()` to avoid\n    // 'Fatal error' dialog on Windows debug.\n    base::Process::TerminateCurrentProcessImmediately(1);\n  }\n  auto translator =\n      reinterpret_cast<FakeTranslateKit*>(kit_ptr)->MaybeCreateTranslator(\n          std::string_view(source_lang.language_code,\n                           source_lang.language_code_size),\n          std::string_view(target_lang.language_code,\n                           target_lang.language_code_size));\n  if (translator) {\n    return reinterpret_cast<uintptr_t>(translator.release());\n  }\n  return 0;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Simulates a crash for testing or creates a translator object.","ghc_query":"simulate crash testing create translator object crash reporting"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\crx_file\\crx_creator.cc:129-151","function":"WriteCRX","codesnippet":"{\n  const std::string header_str = header.SerializeAsString();\n  const auto header_size_octets = base::I32ToLittleEndian(header_str.size());\n\n  constexpr auto format_version_octets = std::to_array<uint8_t>({3, 0, 0, 0});\n  base::File crx(output_path,\n                 base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_WRITE);\n  if (!crx.IsValid()) {\n    return CreatorResult::ERROR_FILE_NOT_WRITABLE;\n  }\n  static_assert(sizeof(char) == sizeof(uint8_t), \"Unsupported char size.\");\n  if (!file->IsValid())\n    return CreatorResult::ERROR_FILE_NOT_READABLE;\n  if (!crx.WriteAtCurrentPosAndCheck(kCrxFileHeaderMagic) ||\n      !crx.WriteAtCurrentPosAndCheck(format_version_octets) ||\n      !crx.WriteAtCurrentPosAndCheck(header_size_octets) ||\n      !crx.WriteAtCurrentPosAndCheck(base::as_byte_span(header_str)) ||\n      !WriteArchive(&crx, file)) {\n    return CreatorResult::ERROR_FILE_WRITE_FAILURE;\n  }\n  return CreatorResult::OK;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a CRX file with a specified header and archive content.","ghc_query":"crx file header archive content create extension package"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_frame\\olympia\\olympia_frame.cc:29-54","function":"OlympiaFrame::Init","codesnippet":"{\n  // For Non Client Frame View to work, it must be of type Window to handle\n  // non-client events such as resize, move, minimize, maximize, etc.\n  views::Widget::InitParams params(\n      views::Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET,\n      views::Widget::InitParams::TYPE_WINDOW);\n  params.name = \"OlympiaFrame\";\n  // Corner radius only works if the OS supports it.\n  params.corner_radius = 12;\n  params.activatable = views::Widget::InitParams::Activatable::kYes;\n  params.delegate = olympia_view_;\n  params.delegate->SetCanResize(true);\n  params.delegate->SetCanMaximize(true);\n  params.delegate->SetCanMinimize(true);\n  // Removing the standard frame is needed since it is a TYPE_WINDOW widget.\n  params.remove_standard_frame = true;\n  params.native_widget = new OlympiaWindowNativeWidget(this);\n  params.force_software_compositing = false;\n#if BUILDFLAG(IS_WIN)\n  // Due to power consumption, this may need to be turned off later. It is on\n  // for now to ensure that the frame is rendered correctly.\n  params.edge_preferred_material_type = gfx::mojom::EdgeMaterialType::kMica;\n#endif  // BUILDFLAG(IS_WIN)\n\n  Widget::Init(std::move(params));\n  SetVisibilityAnimationTransition(views::Widget::ANIMATE_NONE);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes a window widget with specific parameters for non-client frame handling and appearance settings.","ghc_query":"initialize window widget non-client frame handling appearance settings"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\login\\saml\\password_sync_token_verifier.cc:77-107","function":"PasswordSyncTokenVerifier::CheckForPasswordNotInSync","codesnippet":"{\n  // In-session password change is as of now the only way to trigger the sync\n  // token update. We do not need to poll if this feature is not enabled.\n  PrefService* prefs = primary_profile_->GetPrefs();\n  if (!prefs->GetBoolean(prefs::kSamlInSessionPasswordChangeEnabled)) {\n    return;\n  }\n  DCHECK(!password_sync_token_fetcher_);\n  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =\n      primary_profile_->GetURLLoaderFactory();\n  // url_loader_factory is nullptr in unit tests so constructing\n  // PasswordSyncTokenFetcher does not make sense there.\n  if (!url_loader_factory.get()) {\n    return;\n  }\n  password_sync_token_fetcher_ = std::make_unique<PasswordSyncTokenFetcher>(\n      url_loader_factory, primary_profile_, this);\n\n  // Get current sync token for primary_user_.\n  std::string token_to_verify = fake_token;\n  user_manager::KnownUser known_user(g_browser_process->local_state());\n  const std::string* sync_token =\n      known_user.GetPasswordSyncToken(primary_user_->GetAccountId());\n  // Local copy of the token exists on the device and will be used for\n  // verification. Otherwise we will create it by sending user through the\n  // online re-auth.\n  if (sync_token && !sync_token->empty()) {\n    token_to_verify = *sync_token;\n  }\n\n  password_sync_token_fetcher_->StartTokenVerify(token_to_verify);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Verifies and updates the password sync token if in-session password change is enabled.","ghc_query":"password sync token verify update in-session password change"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\predictors\\autocomplete_action_predictor.cc:114-149","function":"AutocompleteActionPredictor::AutocompleteActionPredictor","codesnippet":"{\n  if (profile_->IsOffTheRecord()) {\n    main_profile_predictor_ = AutocompleteActionPredictorFactory::GetForProfile(\n        profile_->GetOriginalProfile());\n    DCHECK(main_profile_predictor_);\n    main_profile_predictor_->incognito_predictor_ = this;\n    if (main_profile_predictor_->initialized_) {\n      CopyFromMainProfile();\n    }\n  } else {\n    // Request the in-memory database from the history to force it to load so\n    // it's available as soon as possible.\n    history::HistoryService* history_service =\n        HistoryServiceFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    if (history_service) {\n      history_service->InMemoryDatabase();\n    }\n\n    table_ =\n        PredictorDatabaseFactory::GetForProfile(profile_)->autocomplete_table();\n\n    // Create local caches using the database as loaded. We will garbage collect\n    // rows from the caches and the database once the history service is\n    // available.\n    auto rows =\n        std::make_unique<std::vector<AutocompleteActionPredictorTable::Row>>();\n    auto* rows_ptr = rows.get();\n    table_->GetTaskRunner()->PostTaskAndReply(\n        FROM_HERE,\n        base::BindOnce(&AutocompleteActionPredictorTable::GetAllRows, table_,\n                       rows_ptr),\n        base::BindOnce(&AutocompleteActionPredictor::CreateCaches,\n                       weak_ptr_factory_.GetWeakPtr(), std::move(rows)));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes autocomplete prediction for a user profile.","ghc_query":"autocomplete prediction initialize user profile omnibox suggestions"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\metrics\\structured\\ash_structured_metrics_recorder.cc:95-123","function":"AshStructuredMetricsRecorder::AddSequenceMetadata","codesnippet":"{\n  auto* event_sequence_metadata = proto->mutable_event_sequence_metadata();\n\n  event_sequence_metadata->set_reset_counter(\n      event.event_sequence_metadata().reset_counter);\n  event_sequence_metadata->set_system_uptime(\n      event.recorded_time_since_boot().InMilliseconds());\n  event_sequence_metadata->set_event_unique_id(\n      base::HashMetricName(event.event_sequence_metadata().event_unique_id));\n\n  const int rotation_age =\n      key_data.GetKeyAgeInWeeks(project_validator.project_hash()).value_or(0);\n  event_sequence_metadata->set_client_id_rotation_weeks(rotation_age);\n\n  std::optional<uint64_t> primary_id =\n      key_data_provider_->GetId(event.project_name());\n  if (primary_id.has_value()) {\n    proto->set_user_project_id(primary_id.value());\n  }\n\n  std::optional<uint64_t> secondary_id =\n      key_data_provider_->GetSecondaryId(event.project_name());\n  if (secondary_id.has_value()) {\n    proto->set_device_project_id(secondary_id.value());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates event sequence metadata and sets project IDs in a protocol buffer.","ghc_query":"event sequence metadata project IDs protocol buffer protobuf update"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\extension_uninstall_dialog.cc:255-296","function":"ExtensionUninstallDialog::Uninstall","codesnippet":"{\n  DCHECK(profile_);\n  const Extension* current_extension =\n      ExtensionRegistry::Get(profile_)->GetExtensionById(\n          extension_->id(), ExtensionRegistry::EVERYTHING);\n  if (current_extension) {\n    if (current_extension->was_installed_by_default()) {\n      base::RecordAction(base::UserMetricsAction(\n          \"Extensions.RemovedDefaultInstalledExtension\"));\n    }\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    MayBeLogExtensionChurnUserHistogram(\n        profile_, current_extension,\n        ExtensionChurnUser::kExtensions_Uninstalled_ChurnUser);\n    bool success =\n        (ExtensionRegistrar::Get(profile_)->UninstallExtension(\n            extension_->id(), uninstall_reason_, error));\n    if (success) {\n#if !BUILDFLAG(IS_ANDROID)\n      if (parent_) {\n        views::Widget* widget =\n            views::Widget::GetWidgetForNativeWindow(parent_);\n        if (widget) {\n          views::View* view = widget->GetRootView();\n          if (view) {\n            gfx::NativeViewAccessible native_view_accessible =\n                view->GetNativeViewAccessible();\n            if (native_view_accessible) {\n              edge::a11y::RaiseExtensionUninstalledEvent(\n                  native_view_accessible,\n                  base::UTF8ToUTF16(extension_->name()));\n            }\n          }\n        }\n      }\n#endif  // !BUILDFLAG(IS_ANDROID)\n      return true;\n    }\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  }\n  *error = kExtensionRemovedError;\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Uninstalls an extension and logs related events if successful.","ghc_query":"uninstall extension log events extension service removal"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\guest_os\\guest_os_terminal.cc:332-434","function":"RecordTerminalSettingsChangesUMAs","codesnippet":"{\n  static constexpr auto kSettingsMap = base::MakeFixedFlatMap<std::string_view,\n                                                              TerminalSetting>({\n      {\"alt-gr-mode\", TerminalSetting::kAltGrMode},\n      {\"alt-backspace-is-meta-backspace\",\n       TerminalSetting::kAltBackspaceIsMetaBackspace},\n      {\"alt-is-meta\", TerminalSetting::kAltIsMeta},\n      {\"alt-sends-what\", TerminalSetting::kAltSendsWhat},\n      {\"audible-bell-sound\", TerminalSetting::kAudibleBellSound},\n      {\"desktop-notification-bell\", TerminalSetting::kDesktopNotificationBell},\n      {\"background-color\", TerminalSetting::kBackgroundColor},\n      {\"background-image\", TerminalSetting::kBackgroundImage},\n      {\"background-size\", TerminalSetting::kBackgroundSize},\n      {\"background-position\", TerminalSetting::kBackgroundPosition},\n      {\"backspace-sends-backspace\", TerminalSetting::kBackspaceSendsBackspace},\n      {\"character-map-overrides\", TerminalSetting::kCharacterMapOverrides},\n      {\"close-on-exit\", TerminalSetting::kCloseOnExit},\n      {\"cursor-blink\", TerminalSetting::kCursorBlink},\n      {\"cursor-blink-cycle\", TerminalSetting::kCursorBlinkCycle},\n      {\"cursor-shape\", TerminalSetting::kCursorShape},\n      {\"cursor-color\", TerminalSetting::kCursorColor},\n      {\"color-palette-overrides\", TerminalSetting::kColorPaletteOverrides},\n      {\"copy-on-select\", TerminalSetting::kCopyOnSelect},\n      {\"use-default-window-copy\", TerminalSetting::kUseDefaultWindowCopy},\n      {\"clear-selection-after-copy\", TerminalSetting::kClearSelectionAfterCopy},\n      {\"ctrl-plus-minus-zero-zoom\", TerminalSetting::kCtrlPlusMinusZeroZoom},\n      {\"ctrl-c-copy\", TerminalSetting::kCtrlCCopy},\n      {\"ctrl-v-paste\", TerminalSetting::kCtrlVPaste},\n      {\"east-asian-ambiguous-as-two-column\",\n       TerminalSetting::kEastAsianAmbiguousAsTwoColumn},\n      {\"enable-8-bit-control\", TerminalSetting::kEnable8BitControl},\n      {\"enable-bold\", TerminalSetting::kEnableBold},\n      {\"enable-bold-as-bright\", TerminalSetting::kEnableBoldAsBright},\n      {\"enable-blink\", TerminalSetting::kEnableBlink},\n      {\"enable-clipboard-notice\", TerminalSetting::kEnableClipboardNotice},\n      {\"enable-clipboard-write\", TerminalSetting::kEnableClipboardWrite},\n      {\"enable-dec12\", TerminalSetting::kEnableDec12},\n      {\"enable-csi-j-3\", TerminalSetting::kEnableCsiJ3},\n      {\"environment\", TerminalSetting::kEnvironment},\n      {\"font-family\", TerminalSetting::kFontFamily},\n      {\"font-size\", TerminalSetting::kFontSize},\n      {\"font-smoothing\", TerminalSetting::kFontSmoothing},\n      {\"foreground-color\", TerminalSetting::kForegroundColor},\n      {\"enable-resize-status\", TerminalSetting::kEnableResizeStatus},\n      {\"hide-mouse-while-typing\", TerminalSetting::kHideMouseWhileTyping},\n      {\"home-keys-scroll\", TerminalSetting::kHomeKeysScroll},\n      {\"keybindings\", TerminalSetting::kKeybindings},\n      {\"media-keys-are-fkeys\", TerminalSetting::kMediaKeysAreFkeys},\n      {\"meta-sends-escape\", TerminalSetting::kMetaSendsEscape},\n      {\"mouse-right-click-paste\", TerminalSetting::kMouseRightClickPaste},\n      {\"mouse-paste-button\", TerminalSetting::kMousePasteButton},\n      {\"word-break-match-left\", TerminalSetting::kWordBreakMatchLeft},\n      {\"word-break-match-right\", TerminalSetting::kWordBreakMatchRight},\n      {\"word-break-match-middle\", TerminalSetting::kWordBreakMatchMiddle},\n      {\"page-keys-scroll\", TerminalSetting::kPageKeysScroll},\n      {\"pass-alt-number\", TerminalSetting::kPassAltNumber},\n      {\"pass-ctrl-number\", TerminalSetting::kPassCtrlNumber},\n      {\"pass-ctrl-n\", TerminalSetting::kPassCtrlN},\n      {\"pass-ctrl-t\", TerminalSetting::kPassCtrlT},\n      {\"pass-ctrl-tab\", TerminalSetting::kPassCtrlTab},\n      {\"pass-ctrl-w\", TerminalSetting::kPassCtrlW},\n      {\"pass-meta-number\", TerminalSetting::kPassMetaNumber},\n      {\"pass-meta-v\", TerminalSetting::kPassMetaV},\n      {\"paste-on-drop\", TerminalSetting::kPasteOnDrop},\n      {\"receive-encoding\", TerminalSetting::kReceiveEncoding},\n      {\"scroll-on-keystroke\", TerminalSetting::kScrollOnKeystroke},\n      {\"scroll-on-output\", TerminalSetting::kScrollOnOutput},\n      {\"scrollbar-visible\", TerminalSetting::kScrollbarVisible},\n      {\"scroll-wheel-may-send-arrow-keys\",\n       TerminalSetting::kScrollWheelMaySendArrowKeys},\n      {\"scroll-wheel-move-multiplier\",\n       TerminalSetting::kScrollWheelMoveMultiplier},\n      {\"terminal-encoding\", TerminalSetting::kTerminalEncoding},\n      {\"shift-insert-paste\", TerminalSetting::kShiftInsertPaste},\n      {\"user-css\", TerminalSetting::kUserCss},\n      {\"user-css-text\", TerminalSetting::kUserCssText},\n      {\"allow-images-inline\", TerminalSetting::kAllowImagesInline},\n      {\"theme\", TerminalSetting::kTheme},\n      {\"theme-variations\", TerminalSetting::kThemeVariations},\n      {\"find-result-color\", TerminalSetting::kFindResultColor},\n      {\"find-result-selected-color\", TerminalSetting::kFindResultSelectedColor},\n      {\"line-height-padding-size\", TerminalSetting::kLineHeightPaddingSize},\n      {\"keybindings-os-defaults\", TerminalSetting::kKeybindingsOsDefaults},\n      {\"screen-padding-size\", TerminalSetting::kScreenPaddingSize},\n      {\"screen-border-size\", TerminalSetting::kScreenBorderSize},\n      {\"screen-border-color\", TerminalSetting::kScreenBorderColor},\n      {\"line-height\", TerminalSetting::kLineHeight},\n  });\n\n  const base::Value::Dict& settings =\n      profile->GetPrefs()->GetDict(guest_os::prefs::kGuestOsTerminalSettings);\n  for (const auto item : settings) {\n    // Only record settings for /hterm/profiles/default/.\n    if (!base::StartsWith(item.first, kSettingPrefix,\n                          base::CompareCase::SENSITIVE)) {\n      continue;\n    }\n    const auto it = kSettingsMap.find(\n        std::string_view(item.first).substr(kSettingPrefixSize));\n    base::UmaHistogramEnumeration(\n        \"Crostini.TerminalSettingsChanged\",\n        it != kSettingsMap.end() ? it->second : TerminalSetting::kUnknown);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Records changes to terminal settings for a specific profile.","ghc_query":"terminal settings profile changes record preferences command prompt"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_agent_untrusted\\edge_agent_untrusted_ui.cc:40-80","function":"EdgeAgentUntrustedUI::EdgeAgentUntrustedUI","codesnippet":"{\n  edge::WebUIPageMetricsHistogramData::CreateOrUpdateForWebContents(\n      web_ui->GetWebContents(), \"AgentUntrusted\");\n  // Create the trusted source for edge://agent-untrusted.\n  content::WebUIDataSource* source = content::WebUIDataSource::CreateAndAdd(\n      web_ui->GetWebContents()->GetBrowserContext(),\n      chrome::kEdgeAgentUntrustedURL);\n\n  // Add required resources.\n  edge_webui::SetupWebUIDataSource(web_ui, source, this,\n                                   kEdgeAgentUntrustedWebuiResources,\n                                   IDR_EDGE_AGENT_UNTRUSTED_WEBUI_INDEX_HTML);\n\n  source->OverrideContentSecurityPolicy(\n      network::mojom::CSPDirectiveName::ConnectSrc,\n      \"connect-src \"\n      \"wss://copilotstaging.microsoft.com/ \"\n      \"wss://copilot.microsoft.com/ \"\n      \"ws://localhost:22402/ \"\n      \"ws://localhost:8081/tasks/ \"\n      \"https://copilotstaging.microsoft.com/ \"\n      \"https://copilot.microsoft.com/ \"\n      \"'self';\");\n\n  // Needed for dynamic mojom file load.\n  source->OverrideContentSecurityPolicy(\n      network::mojom::CSPDirectiveName::ScriptSrc,\n      \"script-src 'self' chrome-untrusted://resources;\");\n\n  source->AddInteger(\n      \"backendOverride\",\n      static_cast<int>(edge::agent::features::GetBackendServerHostType()));\n  source->AddInteger(\"debugFlags\",\n                     static_cast<int>(edge::agent::features::GetDebugFlags()));\n  source->AddBoolean(\"isAgentTestingEnabled\",\n                     edge::agent::features::IsEdgeAgentTestingEnabled());\n\n  source->UseStringsJs();\n\n  page_handler_ = std::make_unique<EdgeAgentUntrustedHandler>();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets up a web UI data source with specific resources and security policies for an untrusted Edge agent page.","ghc_query":"web UI data source resources security policies untrusted Edge agent"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\login\\quick_unlock\\auth_token.cc:46-67","function":"AuthToken::ReplaceUserContext","codesnippet":"{\n  if (!user_context_) {\n    // This happens theoretically in the following rare situation:\n    // 1. An auth editing operation is triggered, e.g. the user changes their\n    // pin.\n    // 2. After the operation is triggered, the auth token is reset, e.g.\n    //    because its lifetime timeout is exceeded. This clears the user\n    //    context stored in the auth token.\n    // 3. Nevertheless, the auth operation triggered in 1 succeeds, and we\n    //    reload the auth factors configuration.\n    // 4. We try to set the user context with the updated user context.\n    //\n    // Usually we make the user reauthenticate a bit before the token is\n    // invalidated, so this should only happen if some clocks are off, or if an\n    // auth editing operation takes very long.\n    LOG(WARNING) << \"Replacement user context is ignored because auth token \"\n                    \"has been reset\";\n    return;\n  }\n\n  Reset();\n  user_context_ = std::move(user_context);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates the user context unless the auth token has been reset.","ghc_query":"update user context auth token reset authentication identity"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\search\\start_suggest_service.cc:212-237","function":"StartSuggestService::SuggestionsParsed","codesnippet":"{\n  std::move(callback).Run([&] {\n    QuerySuggestions query_suggestions;\n    if (result.has_value() && result.value().is_list()) {\n      SearchSuggestionParser::Results results;\n      AutocompleteInput input;\n      if (SearchSuggestionParser::ParseSuggestResults(\n              result->GetList(), input, *scheme_classifier_,\n              /*default_result_relevance=*/-1, /*is_keyword_result=*/false,\n              &results)) {\n        for (SearchSuggestionParser::SuggestResult suggest :\n             results.suggest_results) {\n          QuerySuggestion query;\n          query.query = suggest.suggestion();\n          query.destination_url = GetQueryDestinationURL(\n              query.query, template_url_service_->GetDefaultSearchProvider());\n          query_suggestions.push_back(std::move(query));\n        }\n        suggestions_cache_[kTrendingQuerySuggestionCachedResults] =\n            query_suggestions;\n      }\n    }\n    return query_suggestions;\n  }());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses search suggestions and updates the suggestions cache.","ghc_query":"parse search suggestions update cache omnibox autocomplete"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\autofill\\core\\browser\\filling\\payments\\field_filling_payments_util.cc:173-198","function":"GetCreditCardTypeSelectControlValue","codesnippet":"{\n  if (std::optional<std::u16string> select_control_value =\n          GetSelectControlValue(value, field_options, failure_to_fill)) {\n    return *select_control_value;\n  }\n  if (std::optional<std::u16string> select_control_value =\n          GetSelectControlValueSubstringMatch(value, /*ignore_whitespace=*/true,\n                                              field_options, failure_to_fill)) {\n    return *select_control_value;\n  }\n  if (value == l10n_util::GetStringUTF16(IDS_AUTOFILL_CC_AMEX)) {\n    if (std::optional<std::u16string> select_control_value =\n            GetSelectControlValueSubstringMatch(\n                u\"AmEx\",\n                /*ignore_whitespace=*/true, field_options, failure_to_fill)) {\n      return *select_control_value;\n    }\n  }\n\n  if (failure_to_fill) {\n    *failure_to_fill += \"Failed to fill credit card type. \";\n  }\n  return {};\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines and returns the appropriate select control value for credit card type, or logs a failure message.","ghc_query":"credit card type select control value dropdown form autofill payment"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\page_content_annotations\\core\\page_content_annotations_model_manager.cc:107-151","function":"PageContentAnnotationsModelManager::MaybeStartNextAnnotationJob","codesnippet":"{\n  if (job_state_ == JobExecutionState::kRunning) {\n    return;\n  }\n\n  JobQueue::Pointer job_ptr = job_queue_.FirstMax();\n  if (job_ptr.is_null()) {\n    if (page_visibility_model_handler_) {\n      page_visibility_model_handler_->UnloadModel();\n    }\n    return;\n  }\n\n  DCHECK(job_state_ == JobExecutionState::kIdle ||\n         job_state_ == JobExecutionState::kComplete);\n  job_state_ = JobExecutionState::kRunning;\n\n  std::unique_ptr<PageContentAnnotationJob> job = job_queue_.Erase(job_ptr);\n\n  base::OnceClosure on_job_complete_callback = base::BindOnce(\n      &PageContentAnnotationsModelManager::OnJobExecutionComplete,\n      weak_ptr_factory_.GetWeakPtr());\n\n  // Reset every other model from memory so that there aren't a bunch of models\n  // all loaded at the same time.\n\n  if (job->type() != AnnotationType::kContentVisibility &&\n      page_visibility_model_handler_) {\n    page_visibility_model_handler_->UnloadModel();\n  }\n\n  if (job->type() == AnnotationType::kContentVisibility) {\n    if (!page_visibility_model_handler_) {\n      job->FillWithNullOutputs();\n      job->OnComplete();\n      job.reset();\n      std::move(on_job_complete_callback).Run();\n      return;\n    }\n    page_visibility_model_handler_->ExecuteJob(\n        std::move(on_job_complete_callback), std::move(job));\n    return;\n  }\n\n  NOTREACHED();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Executes a job from the queue and manages model unloading based on job type.","ghc_query":"execute job queue manage model unloading job type task execution"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\safe_browsing\\content\\browser\\client_report_util.cc:124-171","function":"GetSecurityInterstitialInteractionFromCommand","codesnippet":"{\n  switch (command) {\n    case security_interstitials::CMD_DONT_PROCEED:\n      return CSBRR::InterstitialInteraction::CMD_DONT_PROCEED;\n    case security_interstitials::CMD_PROCEED:\n      return CSBRR::InterstitialInteraction::CMD_PROCEED;\n    case security_interstitials::CMD_SHOW_MORE_SECTION:\n      return CSBRR::InterstitialInteraction::CMD_SHOW_MORE_SECTION;\n    case security_interstitials::CMD_OPEN_HELP_CENTER:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_HELP_CENTER;\n    case security_interstitials::CMD_OPEN_DIAGNOSTIC:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_DIAGNOSTIC;\n    case security_interstitials::CMD_RELOAD:\n      return CSBRR::InterstitialInteraction::CMD_RELOAD;\n    case security_interstitials::CMD_OPEN_DATE_SETTINGS:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_DATE_SETTINGS;\n    case security_interstitials::CMD_OPEN_LOGIN:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_LOGIN;\n    case security_interstitials::CMD_DO_REPORT:\n      return CSBRR::InterstitialInteraction::CMD_DO_REPORT;\n    case security_interstitials::CMD_DONT_REPORT:\n      return CSBRR::InterstitialInteraction::CMD_DONT_REPORT;\n    case security_interstitials::CMD_OPEN_REPORTING_PRIVACY:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_REPORTING_PRIVACY;\n    case security_interstitials::CMD_OPEN_WHITEPAPER:\n      return CSBRR::InterstitialInteraction::CMD_OPEN_WHITEPAPER;\n    case security_interstitials::CMD_REPORT_PHISHING_ERROR:\n      return CSBRR::InterstitialInteraction::CMD_REPORT_PHISHING_ERROR;\n    case security_interstitials::CMD_OPEN_ENHANCED_PROTECTION_SETTINGS:\n      return CSBRR::InterstitialInteraction::\n          CMD_OPEN_ENHANCED_PROTECTION_SETTINGS;\n    case security_interstitials::CMD_CLOSE_INTERSTITIAL_WITHOUT_UI:\n      return CSBRR::InterstitialInteraction::CMD_CLOSE_INTERSTITIAL_WITHOUT_UI;\n    case security_interstitials::CMD_TEXT_FOUND:\n    case security_interstitials::CMD_TEXT_NOT_FOUND:\n    case security_interstitials::CMD_ERROR:\n    case security_interstitials::CMD_REQUEST_SITE_ACCESS_PERMISSION:\n    case security_interstitials::CMD_INTERSTITIAL_PAGE_LOADED:\n    case security_interstitials::CMD_MCAS_SUPPORT_PAGE:\n    case security_interstitials::CMD_OPEN_EDGE_PRIVACY_SETTINGS:\n    case security_interstitials::CMD_OPEN_EDGE_FEEDBACK_DIALOG:\n    case security_interstitials::CMD_TYPOSQUATTING_PROCEED_AND_ALWAYS_ALLOW:\n    case security_interstitials::CMD_OPEN_ANDROID_ADVANCED_PROTECTION_SETTINGS:\n      break;\n  }\n  return CSBRR::InterstitialInteraction::UNSPECIFIED;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps security interstitial commands to corresponding interstitial interaction responses.","ghc_query":"security interstitial commands interaction responses security warning pages"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\actor\\tools\\history_tool.cc:125-156","function":"HistoryTool::DidFinishNavigation","codesnippet":"{\n  if (!IsInvokeInProgress()) {\n    return;\n  }\n\n  if (in_flight_navigation_ids_.erase(navigation_handle->GetNavigationId())) {\n    mojom::ActionResultPtr result;\n    auto details_msg = [](NavigationHandle* handle) {\n      std::string msg;\n      if (handle->GetNavigationDiscardReason()) {\n        msg = absl::StrFormat(\"DiscardReason[%d] \",\n                              handle->GetNavigationDiscardReason().value());\n      }\n      if (handle->GetNetErrorCode() != net::OK) {\n        msg +=\n            absl::StrFormat(\"ErrorCode[%s]\",\n                            net::ErrorToShortString(handle->GetNetErrorCode()));\n      }\n      return msg;\n    };\n\n    if (!navigation_handle->HasCommitted()) {\n      result = MakeResult(mojom::ActionResultCode::kHistoryFailedBeforeCommit,\n                          details_msg(navigation_handle));\n    } else if (navigation_handle->IsErrorPage()) {\n      result = MakeResult(mojom::ActionResultCode::kHistoryErrorPage,\n                          details_msg(navigation_handle));\n    } else {\n      result = MakeOkResult();\n    }\n    FinishToolInvocationIfNeeded(std::move(result));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles navigation completion by determining the result based on navigation status and errors.","ghc_query":"navigation completion result navigation status errors handling navigation"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\autofill\\address_editor_view.cc:119-147","function":"AddressEditorView::CreateEditorView","codesnippet":"{\n  text_fields_.clear();\n  field_change_callbacks_.clear();\n\n  const int kBetweenChildSpacing =\n      ChromeLayoutProvider::Get()->GetDistanceMetric(\n          views::DISTANCE_CONTROL_LIST_VERTICAL);\n\n  SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical,\n      gfx::Insets::VH(kBetweenChildSpacing / 2, 0), kBetweenChildSpacing));\n\n  views::View* first_field = nullptr;\n  for (const auto& field : controller_->editor_fields()) {\n    views::View* view = CreateInputField(field);\n    if (first_field == nullptr) {\n      first_field = view;\n    }\n  }\n  initial_focus_view_ = first_field;\n\n  if (controller_->is_validatable()) {\n    validation_error_ =\n        AddChildView(views::Builder<views::Label>()\n                         .SetMultiLine(true)\n                         .SetEnabledColor(ui::kColorAlertHighSeverity)\n                         .SetHorizontalAlignment(gfx::ALIGN_LEFT)\n                         .Build());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and arranges input fields with validation support.","ghc_query":"initialize arrange input fields validation support form validation"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\app_list\\search\\local_image_search\\image_annotation_worker.cc:246-275","function":"ImageAnnotationWorker::Initialize","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  CHECK(annotation_storage);\n  annotation_storage_ = annotation_storage;\n  // This function is called from `AnnotationStorage`. Thus, we will the task\n  // runner `AnnotationStorage` currently runs on.\n  main_task_runner_ = base::SequencedTaskRunner::GetCurrentDefault();\n\n  on_file_change_callback_ = base::BindRepeating(\n      &ImageAnnotationWorker::OnFileChange, weak_ptr_factory_.GetWeakPtr());\n\n  if (use_ocr_) {\n    optical_character_recognizer_->SetDisconnectedCallback(\n        base::BindRepeating(&ImageAnnotationWorker::OnOcrDisconnected,\n                            ocr_weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  if (use_ica_) {\n    DVLOG(1) << \"Initializing ICA DLC.\";\n    image_content_annotator_ = std::make_unique<ImageContentAnnotator>(\n        base::BindRepeating(&ImageAnnotationWorker::OnIcaDisconnected,\n                            weak_ptr_factory_.GetWeakPtr()));\n    image_content_annotator_->EnsureAnnotatorIsConnected();\n  }\n\n  main_task_runner_->PostDelayedTask(\n      FROM_HERE,\n      base::BindOnce(&ImageAnnotationWorker::OnDlcInstalled,\n                     weak_ptr_factory_.GetWeakPtr()),\n      kInitialIndexingDelay);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes image annotation components and sets up callbacks for file changes and disconnections.","ghc_query":"image annotation initialize components callbacks file changes disconnection"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\extension_disabled_ui_desktop.cc:218-251","function":"ExtensionDisabledGlobalError::BubbleViewAcceptButtonPressed","codesnippet":"{\n  if (is_extension_disabled_due_to_settings_privilege_) {\n    RemoveGlobalError();\n    // Delay so this bubble closes properly.\n    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n        FROM_HERE,\n        base::BindOnce(\n            // Adapt scoped_refptr<> as it can't be bound to const&.\n            [](base::WeakPtr<ExtensionRegistrar> registrar,\n               const scoped_refptr<const Extension>& extension) {\n              if (registrar) {\n                CHECK(extension);\n                registrar->GrantPermissionsAndEnableExtension(*extension);\n              }\n            },\n            ExtensionRegistrar::Get(profile_)->GetWeakPtr(),\n            base::RetainedRef(extension_)));\n  } else {\n  // Delay extension reenabling so this bubble closes properly.\n  base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n      FROM_HERE,\n      base::BindOnce(\n          // Adapt scoped_refptr<> as it can't be bound to const&.\n          [](base::WeakPtr<ExtensionRegistrar> registrar,\n             const scoped_refptr<const Extension>& extension) {\n            if (registrar) {\n              CHECK(extension);\n              registrar->GrantPermissionsAndEnableExtension(*extension);\n            }\n          },\n          ExtensionRegistrar::Get(profile_)->GetWeakPtr(),\n          base::RetainedRef(extension_)));\n    }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Enables an extension by granting necessary permissions.","ghc_query":"enable extension grant permissions extension service extension system"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\offline_pages\\recent_tab_helper.cc:191-268","function":"RecentTabHelper::DidFinishNavigation","codesnippet":"{\n  if (!navigation_handle->IsInPrimaryMainFrame() ||\n      !navigation_handle->HasCommitted() ||\n      navigation_handle->IsSameDocument()) {\n    DVLOG_IF(1, navigation_handle->IsInPrimaryMainFrame())\n        << \"Primary main frame navigation ignored (reasons: \"\n        << !navigation_handle->HasCommitted() << \", \"\n        << navigation_handle->IsSameDocument()\n        << \") to: \" << web_contents()->GetLastCommittedURL().spec();\n    return;\n  }\n\n  if (!EnsureInitialized())\n    return;\n  DVLOG(1) << \"Navigation acknowledged to: \"\n           << web_contents()->GetLastCommittedURL().spec();\n\n  // If there is an ongoing downloads request, lets make Background Offliner\n  // take over downloading that page.\n  if (downloads_ongoing_snapshot_info_) {\n    DVLOG(1) << \" - Passing ongoing downloads request to Background Offliner\";\n    ReportDownloadStatusToRequestCoordinator(\n        downloads_ongoing_snapshot_info_.get(), false);\n  }\n\n  // If currently loading an offline page get a pointer to it. It will be null\n  // otherwise.\n  const OfflinePageItem* current_offline_page =\n      OfflinePageUtils::GetOfflinePageFromWebContents(web_contents());\n\n  // If the previous page was saved, delete it now unless we are currently\n  // loading that very snapshot.\n  if (last_n_latest_saved_snapshot_info_ &&\n      (!current_offline_page ||\n       current_offline_page->offline_id !=\n           last_n_latest_saved_snapshot_info_->request_id)) {\n    DVLOG(1) << \" - Deleting previous last_n snapshot with offline_id \"\n             << last_n_latest_saved_snapshot_info_->request_id;\n    PageCriteria criteria;\n    criteria.offline_ids =\n        std::vector<int64_t>{last_n_latest_saved_snapshot_info_->request_id};\n    page_model_->DeletePagesWithCriteria(criteria, base::DoNothing());\n    last_n_latest_saved_snapshot_info_.reset();\n  }\n\n  // Cancel any and all in flight snapshot tasks from the previous page.\n  CancelInFlightSnapshots();\n  downloads_snapshot_on_hold_ = false;\n\n  // Always reset so that posted tasks get canceled.\n  snapshot_controller_->Reset();\n\n  // Check for conditions that should stop us from creating snapshots of\n  // this page:\n  // - It is an error page.\n  // - The navigated URL is not supported.\n  // - The page being loaded is already an offline page.\n  bool can_save =\n      !navigation_handle->IsErrorPage() &&\n      OfflinePageModel::CanSaveURL(web_contents()->GetLastCommittedURL()) &&\n      current_offline_page == nullptr;\n  DVLOG_IF(1, !can_save)\n      << \" - Page can not be saved for offline usage (reasons: \"\n      << !navigation_handle->IsErrorPage() << \", \"\n      << OfflinePageModel::CanSaveURL(web_contents()->GetLastCommittedURL())\n      << \", \" << (current_offline_page == nullptr) << \")\";\n\n  if (!can_save)\n    snapshot_controller_->Stop();\n  // Last N should be disabled when:\n  // - Running on low end devices.\n  // - Viewing POST content for privacy considerations.\n  // - Disabled by flag.\n  last_n_listen_to_tab_hidden_ =\n      can_save && !delegate_->IsLowEndDevice() && !navigation_handle->IsPost();\n  DVLOG_IF(1, can_save && !last_n_listen_to_tab_hidden_)\n      << \" - Page can not be saved by last_n\";\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles navigation events to manage offline page snapshots and ongoing downloads.","ghc_query":"navigation events offline page snapshots downloads offline browsing"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\services\\edge_wdag_win\\shared\\test\\hv_socket_fuzzer.cc:137-163","function":"LLVMFuzzerTestOneInput","codesnippet":"{\n  if (size > 0) {\n    {\n      auto protocol_fuzzer = std::make_unique<ProtocolFuzzer>();\n      wdag::HvBuffer buffer = MakeValidDataMessage(data, size);\n      protocol_fuzzer->Writer().Write(std::move(buffer));\n      protocol_fuzzer->protocol_->ReadMessage();\n      protocol_fuzzer->WaitForMessage();\n      protocol_fuzzer->protocol_->ReadMessage();\n      protocol_fuzzer->CloseWriter();\n      protocol_fuzzer->WaitForClose();\n    }\n\n    {\n      auto protocol_fuzzer = std::make_unique<ProtocolFuzzer>();\n      wdag::HvBuffer buffer = MakeMessageSizeTooSmall(data, size);\n      protocol_fuzzer->Writer().Write(std::move(buffer));\n      protocol_fuzzer->protocol_->ReadMessage();\n      protocol_fuzzer->WaitForMessage();\n      if (!protocol_fuzzer->Closed())\n        protocol_fuzzer->protocol_->ReadMessage();\n      protocol_fuzzer->CloseWriter();\n      protocol_fuzzer->WaitForClose();\n    }\n  }\n\n  return 0;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Tests protocol handling with valid and undersized message data.","ghc_query":"protocol handling test valid undersized message data testing network protocol"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\win\\edge_wdag\\host\\nav_throttle.cc:73-110","function":"NavThrottle::CheckURL","codesnippet":"{\n  TRACE_EVENT_WITH_FLOW0(\"wdag\", \"wdag::host::NavThrottle\", this,\n                         TRACE_EVENT_FLAG_FLOW_OUT);\n\n  nav_start_ = base::TimeTicks::Now();\n  // iFrame are allowed to proceed.\n  // On host, it will render untrusted iframes to match spartan behavior\n  // (unless strict mode is enabled).\n  // In container, it will be blocked by network filter if policy is enabled.\n  if (!navigation_handle()->IsInMainFrame())\n    return CompleteNow(NavigationThrottle::PROCEED);\n\n  // Avoid checking navigations within the same document (We have checked it\n  // already)\n  if (navigation_handle()->IsSameDocument())\n    return CompleteNow(NavigationThrottle::PROCEED);\n\n  GURL url = navigation_handle()->GetURL();\n  if (IsUrlUntrustedPdf(url)) {\n    wdag::host::NavigateToPDFInContainer(url,\n                                         IsOffTheRecord(navigation_handle()));\n    CancelNow();\n    return NavigationThrottle::CANCEL;\n  }\n\n  if (!ShouldAskFirewall(navigation_handle()))\n    return CompleteNow(NavigationThrottle::PROCEED);\n\n  if (IsBypassForCaptivePortalActive() && IsBehindCaptivePortal())\n    return CompleteNow(NavigationThrottle::PROCEED);\n\n  // traceid is not used as a pointer, but as an unique id\n  intptr_t traceid = reinterpret_cast<intptr_t>(this);\n  base::ThreadPool::PostTask(\n      FROM_HERE, {base::MayBlock()},\n      base::BindOnce(&AskFirewall, url, traceid, weak_factory_.GetWeakPtr()));\n\n  return NavigationThrottle::DEFER;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Controls navigation behavior based on URL trust and firewall checks.","ghc_query":"navigation behavior URL trust firewall checks security policy"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\telemetry_client\\classification\\edge_sampling_service.cc:129-165","function":"SamplingService::SetSamplingThreshold","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  int sample_id = not_set_sample_id;\n  // If Sample Id has been passed on the command line, then take that value.\n  // Otherwise, take the value set in the pref_service.\n  if (GetHostSampleId(&sample_id)) {\n    if (local_state != nullptr && registered_prefs_) {\n      local_state->SetInteger(prefs::SampleIdPrefName, sample_id);\n    }\n  } else {\n    if (local_state != nullptr && registered_prefs_) {\n      sample_id = local_state->GetInteger(prefs::SampleIdPrefName);\n    }\n  }\n  uint64_t sample_id_unsigned = static_cast<uint64_t>(sample_id);\n\n  // This is what is defined as outside the bounds for the histogram.\n  bool is_sample_id_outside_bounds =\n      (sample_id < not_set_sample_id) || (sample_id > max_sample_id);\n\n  // Ensure that the Sample Id is set and is not outside the range [1, 100\n  // million], if it is or the caller has indicated that we must reset the Id,\n  // then generate a new one.\n  if (is_sample_id_outside_bounds || (sample_id == not_set_sample_id) ||\n      force_reset) {\n    sample_id_unsigned = CreateSampleId(max_sample_id);\n    sample_id = static_cast<int>(sample_id_unsigned);\n    if (local_state != nullptr && registered_prefs_) {\n      local_state->SetInteger(prefs::SampleIdPrefName, sample_id);\n    }\n  }\n\n  sampling_threshold_ =\n      ((static_cast<double>(sample_id_unsigned) / max_sample_id) *\n       kUpSamplePopSample);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates and validates a sample ID, updating preferences if necessary.","ghc_query":"generate validate sample ID update preferences metrics sampling"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\headless\\test\\pdf_utils.cc:24-51","function":"PDFPageBitmap::Render","codesnippet":"{\n  std::optional<gfx::SizeF> page_size_in_points =\n      chrome_pdf::GetPDFPageSizeByIndex(pdf_data, page_index);\n  if (!page_size_in_points) {\n    return false;\n  }\n\n  page_size_in_points_ = page_size_in_points.value();\n\n  gfx::SizeF page_size_in_pixels =\n      gfx::ScaleSize(page_size_in_points_,\n                     static_cast<float>(kDpi) / printing::kPointsPerInch);\n\n  gfx::Rect page_rect(gfx::ToCeiledSize(page_size_in_pixels));\n\n  constexpr chrome_pdf::RenderOptions options = {\n      .stretch_to_bounds = false,\n      .keep_aspect_ratio = true,\n      .autorotate = true,\n      .use_color = true,\n      .render_device_type = chrome_pdf::RenderDeviceType::kPrinter,\n  };\n\n  bitmap_size_ = page_rect.size();\n  bitmap_data_.resize(kColorChannels * bitmap_size_.GetArea());\n  return chrome_pdf::RenderPDFPageToBitmap(pdf_data, page_index,\n                                           bitmap_data_.data(), bitmap_size_,\n                                           gfx::Size(kDpi, kDpi), options);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Renders a PDF page to a bitmap image.","ghc_query":"PDF page render bitmap image conversion document rendering"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_hub_apps\\hub_app_context_driver.cc:183-208","function":"HubAppContextDriver::DidStartNavigation","codesnippet":"{\n  if (!navigation_handle->IsInPrimaryMainFrame()) {\n    return;\n  }\n\n  // Check if we are changing pages.\n  if (!navigation_handle->IsSameDocument()) {\n    has_created_notifications_for_page_ = false;\n\n    // Reset the `page_load_timer_` since we have switched pages.\n    page_load_timer_.Stop();\n\n    // Reset the app_ids we need to create a notification for when the\n    // WebContents becomes visible.\n    apps_waiting_for_visiblity_change_.clear();\n\n    // Clear the `pending_auto_shower_params_` and `pending_auto_show_timers_`\n    // since we have navigated away from the page that created all of them.\n    ClearClosedHubApps();\n    pending_auto_show_timers_.clear();\n\n    // Remove ourselves as an observer since we are no longer storing anything\n    // in `apps_waiting_for_visiblity_change_`.\n    RemoveHubAppsServiceObserver();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles page navigation by resetting notifications and timers when a new page is loaded.","ghc_query":"page navigation reset notifications timers page load navigation events"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_page_understanding\\content\\renderer\\page_understanding_page_sanitizer.cc:125-158","function":"PageUnderstandingPageSanitizer::ParseHeaderContent","codesnippet":"{\n  if (!frame) {\n    return;\n  }\n  WebDocument document = frame->GetDocument();\n  WebElement head = document.Head();\n\n  if (head.IsNull()) {\n    return;\n  }\n\n  for (blink::WebNode child = head.FirstChild(); !child.IsNull();\n       child = child.NextSibling()) {\n    if (!child.IsElementNode()) {\n      continue;\n    }\n\n    blink::WebElement element = child.To<blink::WebElement>();\n    if (element.HasHTMLTagName(blink::WebString::FromUTF8(kTagMeta)) &&\n        element.HasAttribute(blink::WebString::FromUTF8(kAttrName))) {\n      std::string name =\n          element.GetAttribute(blink::WebString::FromUTF8(kAttrName)).Utf8();\n\n      if (name.find(kMetaDescription) != std::string::npos) {\n        std::string desc = DecodeHTMLCodes(\n            element.GetAttribute(blink::WebString::FromUTF8(kAttrContent))\n                .Utf8());\n        SplitStringByWhitespace(desc, tokens, max_tokens);\n      }\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Extracts and tokenizes the meta description content from a web document's head element.","ghc_query":"meta description extraction tokenize web document head element HTML parsing"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\password_manager\\password_manager_settings_service_factory.cc:65-91","function":"PasswordManagerSettingsServiceFactory::BuildServiceInstanceForBrowserContext","codesnippet":"{\n  TRACE_EVENT0(\"passwords\", \"PasswordManagerSettingsServiceCreation\");\n  Profile* profile = Profile::FromBrowserContext(context);\n#if BUILDFLAG(IS_ANDROID)\n  if (base::FeatureList::IsEnabled(\n          password_manager::features::kLoginDbDeprecationAndroid)) {\n    // For the first run after the feature is enabled, before the unmigrated\n    // passwords are exported, `IsPasswordManagerAvailable` can return false.\n    // However, password saving isn't possible in that run anyway.\n    if (password_manager_android_util::IsPasswordManagerAvailable(\n            profile->GetPrefs(),\n            std::make_unique<\n                password_manager_android_util::PasswordManagerUtilBridge>())) {\n      return std::make_unique<PasswordManagerSettingsServiceAndroidImpl>(\n          profile->GetPrefs(), SyncServiceFactory::GetForProfile(profile));\n    }\n    return nullptr;\n  }\n  if (password_manager_android_util::AreMinUpmRequirementsMet()) {\n    return std::make_unique<PasswordManagerSettingsServiceAndroidMigrationImpl>(\n        profile->GetPrefs(), SyncServiceFactory::GetForProfile(profile));\n  }\n#endif\n  return std::make_unique<password_manager::PasswordManagerSettingsServiceImpl>(\n      profile->GetPrefs());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns an appropriate PasswordManagerSettingsService instance based on platform and feature flags.","ghc_query":"PasswordManagerSettingsService instance platform feature flags password manager settings"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\editor_menu\\editor_menu_view.cc:183-225","function":"EditorMenuView::CalculatePreferredSize","codesnippet":"{\n  if (!available_size.width().is_bounded()) {\n    return PreTargetHandlerView::CalculatePreferredSize(available_size);\n  }\n\n  int width = available_size.width().value();\n  // When the width of editor menu view is updated, we will adjust the number of\n  // rows chips (see: UpdateChipsContainer). Thus, here we need to pre-compute\n  // the expected number of rows here and so we can estimate the height rather\n  // than relying on the default logic.\n\n  const int chip_container_width = width - kChipsContainerInsets.width();\n  int running_width = 0;\n  int num_rows = 0;\n  int chip_height = 0;\n\n  for (views::View* row : chips_container_->children()) {\n    for (views::View* chip : row->children()) {\n      const int chip_width = chip->GetPreferredSize().width();\n      if (num_rows > 0 &&\n          running_width + kChipsHorizontalPadding + chip_width <=\n              chip_container_width) {\n        running_width += kChipsHorizontalPadding + chip_width;\n      } else {\n        ++num_rows;\n        running_width = chip_width;\n      }\n\n      chip_height = chip->height();\n    }\n  }\n\n  const int title_height_with_padding =\n      title_container_->height() + GetTitleContainerInsets().height();\n  const int chips_height_with_padding =\n      GetChipsContainerHeightWithPaddings(chip_height, num_rows);\n  const int textfield_height_with_padding =\n      textfield_->height() + kTextfieldContainerInsets.height();\n\n  return gfx::Size(width, title_height_with_padding +\n                              chips_height_with_padding +\n                              textfield_height_with_padding);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Calculates the preferred size of a view based on available width and child component dimensions.","ghc_query":"preferred size view available width child component dimensions layout"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\location_bar\\edge_keyword_hint_view.cc:191-291","function":"KeywordHintView::UpdateViews","codesnippet":"{\n  // TODO(pkasting): Arguably, much of the code below would be better as\n  // property change handlers in file-scope subclasses of Label etc.\n  if (keyword_.empty()) {\n    return;\n  }\n\n  DCHECK(profile_);\n  TemplateURLService* url_service =\n      TemplateURLServiceFactory::GetForProfile(profile_);\n  if (!url_service) {\n    return;\n  }\n  bool is_extension_keyword;\n  bool is_ask_google_keyword = false;\n  std::u16string short_name(url_service->GetKeywordShortName(\n      keyword_, &is_extension_keyword, &is_ask_google_keyword));\n  short_name_ = short_name;\n\n  if (is_touch_ui_) {\n    int message_id = is_extension_keyword\n                         ? IDS_OMNIBOX_EXTENSION_KEYWORD_HINT_TOUCH\n                         : IDS_OMNIBOX_KEYWORD_HINT_TOUCH;\n    std::u16string visible_text =\n        l10n_util::GetStringFUTF16(message_id, short_name);\n    chip_label_->SetText(visible_text);\n    chip_label_->SetEnabledColor(bubble_outline_color_);\n    chip_label_->SetBackgroundColor(background_color_);\n    int corner_radius = views::LayoutProvider::Get()->GetCornerRadiusMetric(\n        views::Emphasis::kMedium);\n    chip_view_->SetBackground(views::CreateBackgroundFromPainter(\n        views::Painter::CreateRoundRectWith1PxBorderPainter(\n            background_color_, bubble_outline_color_, corner_radius)));\n    GetViewAccessibility().SetName(visible_text);\n  } else {\n    const std::u16string tab_text = l10n_util::GetStringUTF16(IDS_APP_TAB_KEY);\n    std::vector<size_t> full_content_param_offsets;\n    int full_message_id = is_extension_keyword\n                              ? IDS_OMNIBOX_EXTENSION_KEYWORD_HINT\n                              : IDS_OMNIBOX_KEYWORD_HINT;\n    const std::u16string full_keyword_hint =\n        l10n_util::GetStringFUTF16(full_message_id, std::u16string(),\n                                   short_name, &full_content_param_offsets);\n    DCHECK_EQ(2U, full_content_param_offsets.size());\n    const size_t full_tab_chip_start = full_content_param_offsets[0];\n    // Set text for the full text view.\n    const std::u16string full_leading_text =\n        full_keyword_hint.substr(0, full_tab_chip_start);\n    const std::u16string full_trailing_text =\n        full_keyword_hint.substr(full_tab_chip_start);\n    const std::u16string tab_key_name =\n        l10n_util::GetStringUTF16(IDS_OMNIBOX_KEYWORD_HINT_KEY_ACCNAME);\n    const std::u16string accessible_text =\n        full_leading_text + tab_key_name + full_trailing_text;\n    GetViewAccessibility().SetName(accessible_text);\n    full_text_width_ = SetViewText(full_text_view_, full_leading_text, tab_text,\n                                   full_trailing_text);\n\n      // Set text for the medium text view.\n      std::vector<size_t> middle_content_param_offsets;\n      int middle_message_id = is_extension_keyword\n                                  ? IDS_OMNIBOX_EXTENSION_KEYWORD_HINT_MIDDLE\n                                  : IDS_OMNIBOX_KEYWORD_HINT_MIDDLE;\n      const std::u16string middle_keyword_hint =\n          l10n_util::GetStringFUTF16(middle_message_id, std::u16string(),\n                                     short_name, &middle_content_param_offsets);\n      DCHECK_EQ(2U, middle_content_param_offsets.size());\n      size_t middle_tab_chip_start = middle_content_param_offsets[0];\n      std::u16string middle_leading_text =\n          middle_keyword_hint.substr(0, middle_tab_chip_start);\n      std::u16string middle_trailing_text =\n          middle_keyword_hint.substr(middle_tab_chip_start);\n      middle_text_width_ = SetViewText(middle_text_view_, middle_leading_text,\n                                       tab_text, middle_trailing_text);\n\n      // Set text for the short text view.\n      size_t short_tab_chip_start = 0;\n      int short_message_id = is_extension_keyword\n                                 ? IDS_OMNIBOX_EXTENSION_KEYWORD_HINT_SHORT\n                                 : IDS_OMNIBOX_KEYWORD_HINT_SHORT;\n      const std::u16string short_keyword_hint = l10n_util::GetStringFUTF16(\n          short_message_id, std::u16string(), &short_tab_chip_start);\n      std::u16string short_leading_text =\n          short_keyword_hint.substr(0, short_tab_chip_start);\n      std::u16string short_trailing_text =\n          short_keyword_hint.substr(short_tab_chip_start);\n      short_text_width_ = SetViewText(short_text_view_, short_leading_text,\n                                      tab_text, short_trailing_text);\n\n      // Set text for the chip view.\n      chip_label_->SetText(tab_text);\n      chip_label_->SetEnabledColor(bubble_outline_color_);\n      chip_label_->SetBackgroundColor(background_color_);\n      int corner_radius = views::LayoutProvider::Get()->GetCornerRadiusMetric(\n          views::Emphasis::kMedium);\n      chip_view_->SetBackground(views::CreateBackgroundFromPainter(\n          views::Painter::CreateRoundRectWith1PxBorderPainter(\n              background_color_, bubble_outline_color_, corner_radius)));\n      chip_view_->SizeToPreferredSize();\n      SetTooltipOnChipLabel(chip_label_);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets keyword hint text and accessibility properties for UI elements based on the keyword type and UI mode.","ghc_query":"keyword hint text accessibility properties UI elements keyword type UI mode"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\profile_resetter\\resettable_settings_snapshot.cc:239-362","function":"GetReadableFeedbackForSnapshot","codesnippet":"{\n  DCHECK(profile);\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  base::Value::List list;\n  AddPair(list,\n          l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_LOCALE),\n          g_browser_process->GetApplicationLocale());\n  AddPair(list, l10n_util::GetStringUTF16(IDS_VERSION_UI_USER_AGENT),\n          embedder_support::GetUserAgent());\n  std::string version(version_info::GetVersionNumber());\n  version += chrome::GetChannelName(chrome::WithExtendedStable(true));\n  AddPair(list,\n          l10n_util::GetStringUTF16(IDS_PRODUCT_NAME),\n          version);\n\n  // Add snapshot data.\n  const std::vector<GURL>& urls = snapshot.startup_urls();\n  std::string startup_urls;\n  for (auto i = urls.begin(); i != urls.end(); ++i) {\n    if (!startup_urls.empty())\n      startup_urls += ' ';\n    startup_urls += i->host();\n  }\n  if (!startup_urls.empty()) {\n    AddPair(list,\n            l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_STARTUP_URLS),\n            startup_urls);\n  }\n\n  std::u16string startup_type;\n  switch (snapshot.startup_type()) {\n    case SessionStartupPref::DEFAULT:\n      startup_type =\n          l10n_util::GetStringUTF16(IDS_SETTINGS_ON_STARTUP_OPEN_NEW_TAB);\n      break;\n    case SessionStartupPref::LAST:\n      startup_type =\n          l10n_util::GetStringUTF16(IDS_SETTINGS_ON_STARTUP_CONTINUE);\n      break;\n    case SessionStartupPref::URLS:\n      startup_type =\n          l10n_util::GetStringUTF16(IDS_SETTINGS_ON_STARTUP_OPEN_SPECIFIC);\n      break;\n    case SessionStartupPref::LAST_AND_URLS:\n      startup_type = l10n_util::GetStringUTF16(\n          IDS_SETTINGS_ON_STARTUP_CONTINUE_AND_OPEN_SPECIFIC);\n      break;\n    default:\n      break;\n  }\n  AddPair(list,\n          l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_STARTUP_TYPE),\n          startup_type);\n\n  if (!snapshot.homepage().empty()) {\n    AddPair(list,\n            l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_HOMEPAGE),\n            snapshot.homepage());\n  }\n\n  int is_ntp_message_id = snapshot.homepage_is_ntp()\n      ? IDS_RESET_PROFILE_SETTINGS_YES\n      : IDS_RESET_PROFILE_SETTINGS_NO;\n  AddPair(list,\n          l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_HOMEPAGE_IS_NTP),\n          l10n_util::GetStringUTF16(is_ntp_message_id));\n\n  int show_home_button_id = snapshot.show_home_button()\n      ? IDS_RESET_PROFILE_SETTINGS_YES\n      : IDS_RESET_PROFILE_SETTINGS_NO;\n  AddPair(\n      list,\n      l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_SHOW_HOME_BUTTON),\n      l10n_util::GetStringUTF16(show_home_button_id));\n\n  TemplateURLService* service =\n      TemplateURLServiceFactory::GetForProfile(profile);\n  DCHECK(service);\n  const TemplateURL* dse = service->GetDefaultSearchProvider();\n  if (dse) {\n    AddPair(list,\n            l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_DSE),\n            dse->GenerateSearchURL(service->search_terms_data()).host());\n  }\n\n  if (snapshot.shortcuts_determined()) {\n    std::u16string exe_name = base::FilePath(chrome::kBrowserProcessExecutableName).AsUTF16Unsafe();\n    std::u16string shortcut_targets;\n    const std::vector<ShortcutCommand>& shortcuts = snapshot.shortcuts();\n    for (auto i = shortcuts.begin(); i != shortcuts.end(); ++i) {\n      if (!shortcut_targets.empty())\n        shortcut_targets += u\"\\n\";\n      shortcut_targets += exe_name;\n      shortcut_targets += u\" \";\n      shortcut_targets += base::WideToUTF16(i->second);\n    }\n    if (!shortcut_targets.empty()) {\n      AddPair(list,\n              l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_SHORTCUTS),\n              shortcut_targets);\n    }\n  } else {\n    AddPair(list,\n            l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_SHORTCUTS),\n            l10n_util::GetStringUTF16(\n                IDS_RESET_PROFILE_SETTINGS_PROCESSING_SHORTCUTS));\n  }\n\n  const ResettableSettingsSnapshot::ExtensionList& extensions =\n      snapshot.enabled_extensions();\n  std::string extension_names;\n  for (auto i = extensions.begin(); i != extensions.end(); ++i) {\n    if (!extension_names.empty())\n      extension_names += '\\n';\n    extension_names += i->second;\n  }\n  if (!extension_names.empty()) {\n    AddPair(list,\n            l10n_util::GetStringUTF16(IDS_RESET_PROFILE_SETTINGS_EXTENSIONS),\n            extension_names);\n  }\n  return list;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a list of key browser profile settings and their current values.","ghc_query":"browser profile settings list key values current configuration"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_wallet\\core\\browser\\express_checkout\\global_configs\\ecommerce_config.cc:54-94","function":"ECommerceConfigParser::TryOverrideDisallowedSitesFromCheckoutConfig","codesnippet":"{\n  bloom_filter->clear();\n  if (!(bloomfilter_config && bloomfilter_config->is_dict())) {\n    return;\n  }\n  // Invalid schema\n  auto* filter_seeds = bloomfilter_config->FindKey(kBloomFilterSeedKey);\n  auto* filter_length = bloomfilter_config->FindKey(kBloomFilterLengthKey);\n  auto* filter_base64_str =\n      bloomfilter_config->FindKey(kDisallowedSitesByteKey);\n  if (!(filter_length && filter_length->is_int() && filter_seeds &&\n        filter_seeds->is_list() && filter_base64_str &&\n        filter_base64_str->is_string())) {\n    return;\n  }\n\n  std::optional<std::vector<uint8_t>> filter_bytes =\n      base::Base64Decode(filter_base64_str->GetString());\n  if (!filter_bytes.has_value()) {\n    return;\n  }\n\n  // Invalid length\n  uint32_t num_bits = filter_length->GetInt();\n  if (num_bits > filter_bytes.value().size() * 8 ||\n      num_bits + 8 <= filter_bytes.value().size() * 8) {\n    return;\n  }\n  // Try parse values\n  SeedVector seeds = {};\n  for (const auto& seed : filter_seeds->GetList()) {\n    if (!seed.is_int()) {\n      return;\n    }\n    seeds.push_back(seed.GetInt());\n  }\n  ByteVector bytes = filter_bytes.value();\n  // No issue, override\n  *bloom_filter = BloomFilter(seeds, bytes, num_bits);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Configures a bloom filter using provided configuration data.","ghc_query":"bloom filter configure configuration data setup probabilistic"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\lookalikes\\lookalike_url_service.cc:301-347","function":"LookalikeUrlService::CheckSafetyTipStatusWithEngagedSites","codesnippet":"{\n  base::TimeTicks start = base::TimeTicks::Now();\n\n  LookalikeUrlCheckResult lookalike_result =\n      CheckUrlForLookalikes(url, engaged_sites,\n                            /*stop_checking_on_allowlist_or_ignore=*/false);\n\n  SafetyTipCheckResult result;\n  result.url = url;\n\n  if (lookalike_result.action_type != LookalikeActionType::kShowSafetyTip) {\n    std::move(callback).Run(result);\n    RecordReputationStatusWithEngagedSitesTime(start);\n    return;\n  }\n\n  result.safety_tip_status = SafetyTipStatus::kNone;\n  result.suggested_url = lookalike_result.suggested_url;\n\n#if MICROSOFT_EDGE_BUILD\n  result.match_type = lookalike_result.match_type;\n#endif  // MICROSOFT_EDGE_BUILD\n\n  result.safety_tip_status = SafetyTipStatus::kLookalike;\n  result.lookalike_heuristic_triggered = true;\n\n  if (lookalike_result.is_allowlisted) {\n    // This will record a UKM but it won't show a warning.\n    result.safety_tip_status = SafetyTipStatus::kNone;\n    std::move(callback).Run(result);\n    RecordReputationStatusWithEngagedSitesTime(start);\n    return;\n  }\n\n  if (lookalike_result.is_warning_previously_dismissed) {\n    result.safety_tip_status = SafetyTipStatus::kLookalikeIgnored;\n    // The local allowlist is used by both the interstitial and safety tips, so\n    // it's possible to hit this case even when we're not in the conditions\n    // above. It's also possible to get kNone here when a domain is added to\n    // the server-side allowlist after it has been ignored. In these cases,\n    // there's no additional action required.\n  }\n  std::move(callback).Run(result);\n  RecordReputationStatusWithEngagedSitesTime(start);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks a URL for lookalike characteristics and determines the appropriate safety tip status.","ghc_query":"URL lookalike characteristics safety tip status determine check"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\share\\share_ranking.cc:156-202","function":"MaybeUpdateRankingFromHistory","codesnippet":"{\n  const double DAMPENING = 1.1;\n\n  if (length == 0) {\n    // Special case: if length is 0 here, the only thing that will be shown is\n    // the \"More\" tile, and the logic below to find lowest/highest within the\n    // first length tiles will all break. Bail out here.\n    return old_ranking;\n  }\n\n  const std::string lowest_shown_recent =\n      LowestShown(old_ranking, recent_share_history, length);\n  const std::string lowest_shown_all =\n      LowestShown(old_ranking, all_share_history, length);\n  const std::string highest_unshown_recent =\n      HighestUnshown(old_ranking, recent_share_history, length);\n  const std::string highest_unshown_all =\n      HighestUnshown(old_ranking, all_share_history, length);\n\n  std::vector<std::string> new_ranking = old_ranking;\n\n  auto recent_count_for = [&](const std::string& key) {\n    return recent_share_history.count(key) > 0 ? recent_share_history.at(key)\n                                               : 0;\n  };\n\n  auto all_count_for = [&](const std::string& key) {\n    return all_share_history.count(key) > 0 ? all_share_history.at(key) : 0;\n  };\n\n  if (!highest_unshown_recent.empty() &&\n      recent_count_for(highest_unshown_recent) >\n          recent_count_for(lowest_shown_recent) * DAMPENING) {\n    SwapRankingElement(new_ranking, lowest_shown_recent,\n                       highest_unshown_recent);\n  } else if (!highest_unshown_all.empty() &&\n             all_count_for(highest_unshown_all) >\n                 all_count_for(lowest_shown_all) * DAMPENING) {\n    SwapRankingElement(new_ranking, lowest_shown_all, highest_unshown_all);\n  }\n\n  CHECK_EQ(old_ranking.size(), new_ranking.size());\n  return new_ranking;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adjusts a ranking list based on recent and overall share history.","ghc_query":"ranking list adjust recent overall share history"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\keyboard_accessory\\android\\payment_method_accessory_controller_impl.cc:198-267","function":"PaymentMethodAccessoryControllerImpl::GetSheetData","codesnippet":"{\n  // Note that also GetAutofillManager() can return nullptr.\n  const BrowserAutofillManager* autofill_manager =\n      GetWebContents().GetFocusedFrame() ? GetAutofillManager() : nullptr;\n\n  std::vector<UserInfo> info_to_add;\n  bool allow_filling =\n      autofill_manager &&\n      ShouldAllowCreditCardFallbacks(autofill_manager->client(),\n                                     autofill_manager->last_query_form());\n\n  std::vector<const CachedServerCardInfo*> unmasked_cards =\n      GetUnmaskedCreditCards();\n  if (!unmasked_cards.empty()) {\n    // Add the cached server cards first, so that they show up on the top of the\n    // manual filling view.\n    std::ranges::transform(unmasked_cards, std::back_inserter(info_to_add),\n                           [allow_filling](const CachedServerCardInfo* data) {\n                             return TranslateCachedCard(data, allow_filling);\n                           });\n  }\n  // Only add cards that are not present in the cache. Otherwise, we might\n  // show duplicates.\n  bool add_all_cards = unmasked_cards.empty() || !autofill_manager;\n  for (const CardOrVirtualCard& card_or_virtual : GetAllCreditCards()) {\n    const CreditCard* card = UnwrapCardOrVirtualCard(card_or_virtual);\n    if (add_all_cards || !autofill_manager->GetCreditCardAccessManager()\n                              .IsCardPresentInUnmaskedCache(*card)) {\n      info_to_add.push_back(TranslateCard(card, allow_filling));\n    }\n  }\n\n  std::vector<FooterCommand> footer_commands = {FooterCommand(\n      l10n_util::GetStringUTF16(\n          IDS_MANUAL_FILLING_CREDIT_CARD_SHEET_ALL_ADDRESSES_LINK),\n      AccessoryAction::MANAGE_CREDIT_CARDS)};\n  if (!GetLoyaltyCards().empty()) {\n    footer_commands.emplace_back(\n        l10n_util::GetStringUTF16(\n            IDS_MANUAL_FILLING_CREDIT_CARD_SHEET_ALL_LOYALTY_CARDS_LINK),\n        AccessoryAction::MANAGE_LOYALTY_CARDS);\n  }\n\n  bool has_suggestions = !info_to_add.empty();\n\n  AccessorySheetData data = CreateAccessorySheetData(\n      AccessoryTabType::CREDIT_CARDS, GetTitle(has_suggestions),\n      /*plusAddressTitle=*/std::u16string(), std::move(info_to_add),\n      std::move(footer_commands));\n\n  for (auto* offer : GetPromoCodeOffers()) {\n    data.add_promo_code_info(TranslateOffer(offer));\n  }\n\n  for (const Iban& iban : GetIbans()) {\n    data.add_iban_info(TranslateIban(iban));\n  }\n\n  for (const LoyaltyCard& loyalty_card : GetLoyaltyCards()) {\n    data.add_loyalty_card_info(LoyaltyCardInfo(\n        loyalty_card.merchant_name(), loyalty_card.program_logo(),\n        base::UTF8ToUTF16(loyalty_card.loyalty_card_number())));\n  }\n\n  if (has_suggestions && !allow_filling && autofill_manager) {\n    data.set_warning(\n        l10n_util::GetStringUTF16(IDS_AUTOFILL_WARNING_INSECURE_CONNECTION));\n  }\n  return data;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates accessory sheet data for credit card autofill suggestions and related information.","ghc_query":"accessory sheet data credit card autofill suggestions information"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\isolated_web_apps\\policy\\isolated_web_app_policy_manager.cc:256-282","function":"IsolatedWebAppPolicyManager::StartImpl","codesnippet":"{\n  const int pending_inits_count = GetPendingInitCount();\n  SetPendingInitCount(pending_inits_count + 1);\n\n  if (pending_inits_count > 0) {\n    base::UmaHistogramCounts100(\n        \"WebApp.Isolated.PolicyManager.PendingInitializations\",\n        /*sample=*/pending_inits_count);\n  }\n\n  if (pending_inits_count <= kIsolatedWebAppForceInstallMaxRetryTreshold) {\n    ConfigureObserversOnSessionStart();\n    CleanupAndProcessPolicyOnSessionStart();\n  } else {\n    auto configure_observers = base::BindOnce(\n        &IsolatedWebAppPolicyManager::ConfigureObserversOnSessionStart,\n        weak_ptr_factory_.GetWeakPtr());\n    auto cleanup_and_process_policy = base::BindOnce(\n        &IsolatedWebAppPolicyManager::CleanupAndProcessPolicyOnSessionStart,\n        weak_ptr_factory_.GetWeakPtr());\n\n    base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\n        FROM_HERE,\n        std::move(configure_observers)\n            .Then(std::move(cleanup_and_process_policy)),\n        kIsolatedWebAppForceInstallEmergencyDelay);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Manages initialization and configuration tasks for isolated web app policies based on pending count.","ghc_query":"isolated web app policies initialization configuration tasks pending count"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\manta\\manta_service_callbacks.cc:64-99","function":"LogTimeCost","codesnippet":"{\n  switch (request_type) {\n    case MantaMetricType::kOrca:\n      base::UmaHistogramTimes(\"Ash.MantaService.OrcaProvider.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kScanner:\n      base::UmaHistogramTimes(\"Ash.MantaService.ScannerProvider.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kSnapper:\n      base::UmaHistogramTimes(\"Ash.MantaService.SnapperProvider.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kMahiSummary:\n      base::UmaHistogramTimes(\"Ash.MantaService.MahiProvider.Summary.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kMahiElucidation:\n      base::UmaHistogramTimes(\n          \"Ash.MantaService.MahiProvider.Elucidation.TimeCost\", time_cost);\n      break;\n    case MantaMetricType::kMahiQA:\n      base::UmaHistogramTimes(\"Ash.MantaService.MahiProvider.QA.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kAnchovy:\n      base::UmaHistogramTimes(\"Ash.MantaService.AnchovyProvider.TimeCost\",\n                              time_cost);\n      break;\n    case MantaMetricType::kWalrus:\n      base::UmaHistogramTimes(\"Ash.MantaService.WalrusProvider.TimeCost\",\n                              time_cost);\n      break;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs time cost metrics for different Manta service providers based on request type.","ghc_query":"Manta service providers time cost metrics request type log performance"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_hub\\history_hub_content_provider.cc:246-275","function":"HistoryHubContentProvider::OnPopupOpen","codesnippet":"{\n  BaseHubContentProvider::OnPopupOpen(reason, trigger_origin);\n\n  is_popup_ = true;\n\n  if (session_start_time_.is_null()) {\n    session_start_time_ = base::TimeTicks::Now();\n    num_views_in_session_ = 1;\n    engagement_in_session_ = false;\n    search_in_session_ = false;\n  } else {\n    num_views_in_session_++;\n  }\n\n  session_end_time_ = base::TimeTicks();\n\n  // Cancel any pending try to close.\n  if (close_session_task_->IsRunning()) {\n    close_session_task_->Stop();\n  }\n\n  engagement_in_page_ = false;\n  search_in_page_ = false;\n  search_engagement_in_page_ = false;\n  search_with_ai_results_ = false;\n  search_with_ai_results_visible_ = false;\n\n  RecordHubOpened(browser()->profile());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes session metrics and records a hub opening event.","ghc_query":"session metrics initialize record hub opening event"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_e_drop\\android\\e_drop_bridge.cc:569-597","function":"JNI_EDropUtils_UploadFileWithUri","codesnippet":"{\n  Profile* profile = Profile::FromJavaObject(jprofile);\n  std::string screenshot_path = base::android::ConvertJavaStringToUTF8(env, uri);\n  if (!profile || screenshot_path.empty()) {\n    return false;\n  }\n  edge_e_drop::EDropService* e_drop_service_ =\n      EDropServiceFactory::GetForProfile(profile,\n                                         ServiceAccessType::EXPLICIT_ACCESS);\n  auto* sync_service = SyncServiceFactory::GetForProfile(profile);\n  if (!sync_service || sync_service->GetTransportState() !=\n                           syncer::SyncService::TransportState::ACTIVE) {\n    return false;\n  }\n\n  if (e_drop_service_) {\n    e_drop_service_->UploadByDataProvider(\n        std::make_unique<one_drive::FileDataProviderAndroid>(\n            base::FilePath(screenshot_path),\n            e_drop_service_->GetUploadManager()->GetUploadTempDir()));\n    metrics::RecordEDropApkfileSupsellStep(\n        static_cast<metrics::MicrosoftEDropScreenshotStepType>(new_state));\n    return true;\n  }\n  return false;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Uploads a screenshot to a service if the profile and sync conditions are met.","ghc_query":"screenshot upload service profile sync conditions"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\device_signals\\core\\browser\\user_permission_service_impl.cc:56-87","function":"UserPermissionServiceImpl::ShouldCollectConsent","codesnippet":"{\n  if (HasUserConsented()) {\n    // Already have the user consent, so no need to collect.\n    return false;\n  }\n\n  // Unmanaged profiles are not considered unaffiliated contexts.\n  bool is_unaffiliated_user = IsDeviceCloudManaged() &&\n                              user_delegate_->IsManagedUser() &&\n                              !user_delegate_->IsAffiliated();\n\n  bool consent_required_by_specific_policy =\n      IsConsentFlowPolicyEnabled() &&\n      (!IsDeviceCloudManaged() ||\n       (IsNewEvSignalsUnaffiliatedEnabled() && is_unaffiliated_user));\n\n  bool consent_required_by_dependent_policy = false;\n  std::set<policy::PolicyScope> scopes =\n      user_delegate_->GetPolicyScopesNeedingSignals();\n  if (scopes.find(policy::POLICY_SCOPE_USER) != scopes.end()) {\n    if (IsDeviceCloudManaged()) {\n      // Managed device, only trigger the consent flow if the user is\n      // unaffiliated.\n      consent_required_by_dependent_policy = is_unaffiliated_user;\n    } else {\n      // Unmanaged device.\n      consent_required_by_dependent_policy = true;\n    }\n  }\n\n  return consent_required_by_specific_policy ||\n         consent_required_by_dependent_policy;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines if user consent is required based on policy and device management status.","ghc_query":"user consent required policy device management status determine"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings\\edge_settings_iris_handler.cc:181-221","function":"SettingsIrisMessageHandler::SendIrisImpression","codesnippet":"{\n  // Don't pass in params for this message handler as this makes an\n  // external url request and we don't want the web_ui to change\n  // the external url or its parameter.\n  DCHECK(params.empty());\n  if (!iris_data_fetcher_)\n    return;\n\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\n          \"edge_settings_iris_impression_sender\",\n          R\"(\n        semantics {\n          sender: \"Edge Settings page\"\n          description:\n            \"Sends iris impression callback to IRIS for placement\"\n          trigger:\n            \"Link in ad on settings page\"\n          data:\n            \"Placement id fetched from IRIS.\"\n          destination: MICROSOFT_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: NO\n          setting:\n            \"This feature cannot be disabled by settings\"\n          policy_exception_justification: \"Not implemented.\"\n        })\");\n  auto impression_url = iris_data_fetcher_->GetImpressionRequestForPlacement(\n      kSettingsIrisPlacementId);\n  if (impression_url.has_value()) {\n    const std::string impression_histogram_name(\n        \"Microsoft.Settings.Iris.ImpressionRequestResult\");\n    // This deletes itself after the impressions request to iris is complete.\n    // The ownership is transferred to the callback in IrisTelemetryTrigger.\n    IrisTelemetryTrigger* iris_impression_trigger = new IrisTelemetryTrigger(\n        kSettingsIrisPlacementId, impression_url.value());\n    iris_impression_trigger->SendIrisTelemeteryForPlacement(\n        traffic_annotation, impression_histogram_name);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sends an iris impression callback to a Microsoft-owned service for placement tracking.","ghc_query":"iris impression callback Microsoft-owned service placement tracking"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_android_webview\\browser\\aw_browser_terminator.cc:145-171","function":"AwBrowserTerminator::OnChildExit","codesnippet":"{\n  content::RenderProcessHost* rph =\n      content::RenderProcessHost::FromID(info.process_host_id);\n\n  // Post message when child exit, ignoring TerminationInfo check to ensure\n  // render crash inside iframe can get notified.\n  JNIEnv* env = base::android::AttachCurrentThread();\n  Java_WebViewChildProcessCrashObserver_childCrashed(env, info.pid);\n\n  // Excluded to prevent double triggering in Edge.\n  // crash_reporter::CrashMetricsReporter::GetInstance()->ChildProcessExited(info);\n\n  if (info.normal_termination) {\n    return;\n  }\n\n  LOG(ERROR) << \"Renderer process (\" << info.pid << \") crash detected (code \"\n             << info.crash_signo << \").\";\n\n  std::vector<ScopedJavaGlobalRef<jobject>> java_web_contents;\n  GetJavaWebContentsForRenderProcess(rph, &java_web_contents);\n\n  content::GetUIThreadTaskRunner({base::TaskPriority::HIGHEST})\n      ->PostTask(FROM_HERE,\n                 base::BindOnce(OnRenderProcessGone, java_web_contents,\n                                info.pid, info.is_crashed()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Notifies and logs when a renderer process crashes.","ghc_query":"renderer process crash notify log monitoring event"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_hub_apps\\service\\hub_apps_order_engine.cc:63-110","function":"HubAppsOrderEngine::HubAppsOrderEngine","codesnippet":"{\n  DCHECK(delegate_);\n  PrefService* pref_service = delegate_->GetPrefService();\n  pref_change_registrar_ = std::make_unique<PrefChangeRegistrar>();\n  pref_change_registrar_->Init(pref_service);\n\n  pref_change_registrar_->Add(\n      prefs::kHubAppPreferences,\n      base::BindRepeating(&HubAppsOrderEngine::OnHubAppPrefsChanged,\n                          weak_factory_.GetWeakPtr()));\n  pref_change_registrar_->Add(\n      prefs::kShowHubAppInSidebarButtons,\n      base::BindRepeating(&HubAppsOrderEngine::OnSidebarButtonVisibilityChanged,\n                          weak_factory_.GetWeakPtr()));\n  pref_change_registrar_->Add(\n      prefs::kEdgeSidebarVisibility,\n      base::BindRepeating(&HubAppsOrderEngine::OnRawOrderDataChanged,\n                          weak_factory_.GetWeakPtr()));\n\n  const base::Value::Dict* hub_app_prefs =\n      pref_service->GetValue(prefs::kHubAppPreferences).GetIfDict();\n  if (hub_app_prefs) {\n    auto* user_generated_value = hub_app_prefs->FindByDottedPath(\n        UserGeneratedHubAppsPrefsHandler::kHubAppKey);\n    if (user_generated_value) {\n      user_generated_prefs_node_ = user_generated_value->Clone();\n    }\n    auto* user_generated_index_node =\n        hub_app_prefs->FindByDottedPath(DictKeyWithSidebarMode(\n            UserGeneratedHubAppsPrefsHandler::kHubAppKeyIndexKey,\n            sidebar_mode));\n    if (user_generated_index_node) {\n      user_generated_index_node_ = user_generated_index_node->Clone();\n    }\n  }\n\n  visibility_map_ = LoadVisibilityFromPref();\n  order_raw_data_ = LoadOrderRawDataFromPref();\n\n  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\n      FROM_HERE,\n      base::BindOnce(&HubAppsOrderEngine::\n                         UpdateAdd2BottomToPrefsToSimulateAccountLevelFlag,\n                     weak_factory_.GetWeakPtr()),\n      base::Seconds(10));\n  UpdateAdd2BottomToPrefsToSimulateAccountLevelFlag();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes preference change listeners and loads user-generated preferences and visibility data.","ghc_query":"preference change listeners initialize load user-generated preferences visibility data"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_pinned_sites\\pinned_sites_launch_manager.cc:189-234","function":"LaunchManager::LaunchUrl","codesnippet":"{\n  VLOG(1) << \"LaunchUrl start, url='\" << internal::GetDebugSpec(url) << \"'\";\n  internal::BrowserTab tab = internal::FindTabWithPinUrl(profile, url);\n  if (tab.browser) {\n    // For existing browser, make sure its window is activated.\n    if (tab.browser->window()) {\n      tab.browser->window()->Activate();\n    }\n  } else {\n    constexpr bool user_gesture = true;\n    tab.browser = Browser::Create(Browser::CreateParams(profile, user_gesture));\n  }\n\n  const bool tab_switch = tab.index > -1;\n  if (tab_switch) {\n    VLOG(3) << \"  Activating tab at index \" << tab.index << \" in browser 0x\"\n            << std::hex << tab.browser;\n    tab.browser->tab_strip_model()->ActivateTabAt(\n        tab.index, {TabStripUserGestureDetails(\n                       TabStripUserGestureDetails::GestureType::kOther)});\n  } else {\n    VLOG(3) << \"  Adding new tab to browser 0x\" << std::hex << tab.browser;\n    NavigateParams nav_params(tab.browser, url,\n                              ui::PAGE_TRANSITION_AUTO_BOOKMARK);\n    nav_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;\n    Navigate(&nav_params);\n  }\n\n  // |window()| can be null if the window is still being created.\n  if (tab.browser->window()) {\n    tab.browser->window()->Show();\n  }\n\n#if BUILDFLAG(IS_WIN)\n  // Update the pinned sites cache. This is to work well with tiles that were\n  // created outside of Edge after the last cache update, and then launched.\n  // Otherwise, the cache would be stale, resulting in bad side effects like\n  // not glomming the opened tab to the new tile, and the pin to taskbar command\n  // not being disabled.\n  if (Cache::IsEnabled()) {\n    Cache::GetInstance()->Update();\n  }\n#endif  // BUILDFLAG(IS_WIN)\n\n  VLOG(1) << \"LaunchUrl end, tab_switch=\" << std::boolalpha << tab_switch;\n  return tab_switch;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Launches a URL in a browser tab, activating an existing tab or creating a new one if necessary.","ghc_query":"URL launch browser tab activate existing create new navigation"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\isolated_web_apps\\test\\isolated_web_app_fake_response_reader_factory.cc:23-45","function":"CreateDummyIntegrityBlock","codesnippet":"{\n  auto raw_integrity_block = web_package::mojom::BundleIntegrityBlock::New();\n  raw_integrity_block->size = 123;\n\n  auto entry =\n      web_package::mojom::BundleIntegrityBlockSignatureStackEntry::New();\n  entry->signature_info = web_package::mojom::SignatureInfo::NewEd25519(\n      web_package::mojom::SignatureInfoEd25519::New());\n  entry->signature_info->get_ed25519()->public_key =\n      test::GetDefaultEd25519KeyPair().public_key;\n  auto signed_web_bundle_id =\n      web_package::SignedWebBundleId::CreateForPublicKey(\n          test::GetDefaultEd25519KeyPair().public_key);\n  raw_integrity_block->signature_stack.push_back(std::move(entry));\n  raw_integrity_block->attributes =\n      web_package::test::GetAttributesForSignedWebBundleId(\n          signed_web_bundle_id.id());\n\n  auto integrity_block = web_package::SignedWebBundleIntegrityBlock::Create(\n      std::move(raw_integrity_block));\n  CHECK(integrity_block.has_value()) << integrity_block.error();\n\n  return *integrity_block;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a signed web bundle integrity block.","ghc_query":"web bundle integrity signed block signature verification"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\optimization_guide\\core\\model_info.cc:30-65","function":"ModelInfo::Create","codesnippet":"{\n  std::optional<base::FilePath> model_file_path =\n      StringToFilePath(model.model().download_url());\n  if (!model_file_path)\n#if defined(MICROSOFT_EDGE_BUILD)  // Edge allows models with only metadata\n    model_file_path = base::FilePath();\n#else\n    return nullptr;\n#endif\n  if (!model.model_info().has_version())\n    return nullptr;\n\n  base::flat_map<base::FilePath::StringType, base::FilePath> additional_files;\n  for (const proto::AdditionalModelFile& additional_file :\n       model.model_info().additional_files()) {\n    std::optional<base::FilePath> additional_file_path =\n        StringToFilePath(additional_file.file_path());\n    if (!additional_file_path || additional_file_path->empty()) {\n      continue;\n    }\n    if (!additional_file_path->IsAbsolute()) {\n      NOTREACHED() << FilePathToString(*additional_file_path);\n    }\n    additional_files[additional_file_path->BaseName().value()] =\n        *additional_file_path;\n  }\n\n  std::optional<proto::Any> model_metadata;\n  if (model.model_info().has_model_metadata())\n    model_metadata = model.model_info().model_metadata();\n\n  // Private ctor, so we can't use std::make_unique.\n  return base::WrapUnique(new ModelInfo(*model_file_path, additional_files,\n                                        model.model_info().version(),\n                                        model_metadata));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a ModelInfo object with file paths and metadata.","ghc_query":"ModelInfo create object file paths metadata model information"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\global_media_controls\\cast_device_selector_view.cc:56-103","function":"IssueHoverButton::IssueHoverButton","codesnippet":"{\n  label()->SetVisible(false);\n  SetBorder(views::CreateEmptyBorder(gfx::Insets()));\n  ink_drop_container()->SetProperty(views::kViewIgnoredByLayoutKey, true);\n  GetViewAccessibility().SetName(\n      base::JoinString({device_name, status_text}, u\"\\n\"));\n  auto* layout = SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kHorizontal, kIconHoverButtonInsets,\n      kDeviceEntrySeparator));\n\n  // Create a column to hold the info icon view.\n  auto* icon_view_column =\n      AddChildView(std::make_unique<views::BoxLayoutView>());\n  icon_view_column->SetCanProcessEventsWithinSubtree(false);\n  icon_view_column->SetCrossAxisAlignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n\n  auto* icon_view = icon_view_column->AddChildView(\n      std::make_unique<views::ImageView>(ui::ImageModel::FromVectorIcon(\n          GetVectorIcon(icon), status_text_color_id, kDeviceEntryIconSize)));\n  icon_view->SetCanProcessEventsWithinSubtree(false);\n\n  // Create a column to hold the device name label and status text label.\n  auto* label_column = AddChildView(std::make_unique<views::BoxLayoutView>());\n  label_column->SetCanProcessEventsWithinSubtree(false);\n  label_column->SetOrientation(views::BoxLayout::Orientation::kVertical);\n  label_column->SetCrossAxisAlignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n  label_column->SetBetweenChildSpacing(kDeviceContainerSeparator);\n  layout->SetFlexForView(label_column, 1);\n\n  device_name_label_ = label_column->AddChildView(\n      std::make_unique<views::Label>(device_name, views::style::CONTEXT_LABEL,\n                                     views::style::STYLE_BODY_2));\n  device_name_label_->SetCanProcessEventsWithinSubtree(false);\n  device_name_label_->SetEnabledColor(device_name_color_id);\n\n  status_text_label_ = label_column->AddChildView(\n      std::make_unique<views::Label>(status_text, views::style::CONTEXT_LABEL,\n                                     views::style::STYLE_BODY_4));\n  status_text_label_->SetCanProcessEventsWithinSubtree(false);\n  status_text_label_->SetEnabledColor(status_text_color_id);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a UI layout with an icon and labels for device name and status text.","ghc_query":"UI layout icon labels device name status text"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\session_crashed_bubble_view.cc:249-273","function":"SessionCrashedBubble::ShowIfNotOffTheRecordProfile","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (browser->profile()->IsOffTheRecord()) {\n    return;\n  }\n\n  // Observes possible browser removal before Show is called.\n  auto browser_observer =\n      std::make_unique<SessionCrashedBubbleView::BrowserRemovalObserver>(\n          browser);\n\n  if (DoesSupportConsentCheck()) {\n    GoogleUpdateSettings::CollectStatsConsentTaskRunner()\n        ->PostTaskAndReplyWithResult(\n            FROM_HERE,\n            base::BindOnce(&GoogleUpdateSettings::GetCollectStatsConsent),\n            base::BindOnce(&SessionCrashedBubbleView::Show,\n                           std::move(browser_observer), skip_tab_checking));\n  } else {\n    // remove the hard-coded part once we have a way of getting user preference\n    SessionCrashedBubbleView::Show(std::move(browser_observer),\n                                   skip_tab_checking, false);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Displays a session crashed notification if the browser is not in incognito mode.","ghc_query":"session crashed notification incognito mode browser crash display"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\edge_side_pane\\borrow_tab_utils.cc:31-64","function":"FlashCurrentWebContents","codesnippet":"{\n  if (!web_contents) {\n    return;\n  }\n  std::u16string js_str =\n      uR\"(\n        (()=>{\n          const flashEl = document.createElement(\"div\");\n          flashEl.style.position = \"fixed\";\n          flashEl.style.top = \"0\";\n          flashEl.style.left = \"0\";\n          flashEl.style.width = \"100%\";\n          flashEl.style.height = \"100%\";\n          flashEl.style.zIndex = '999999999';\n          flashEl.style.backgroundColor = 'rgba(200, 225, 255, 0.9)';\n          flashEl.style.transitionDuration = '0.5s';\n          flashEl.style.opacity = 0;\n          document.body.appendChild(flashEl);\n          setTimeout(()=>{\n              flashEl.style.opacity = 1;\n              setTimeout(()=>{\n                  flashEl.style.opacity = 0;\n                  setTimeout(()=>{\n                      document.body.removeChild(flashEl);\n                  }\n                  , 500);\n              }\n              , 500);\n          }\n          , 100);\n        })();\n  )\";\n  web_contents->GetPrimaryMainFrame()->ExecuteJavaScriptInIsolatedWorld(\n      js_str, base::DoNothing(), 1);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adds a temporary full-screen flash overlay to a webpage.","ghc_query":"full-screen flash overlay temporary webpage visual feedback"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\location_bar\\edge_keyword_hint_view.cc:143-188","function":"KeywordHintView::SetViewText","codesnippet":"{\n  // Remove all previous text in the view.\n  view->RemoveAllChildViews();\n\n  // Add the text before the chip.\n  auto* leading_label = view->AddChildView(\n      std::make_unique<views::Label>(leading_text, CONTEXT_OMNIBOX_DECORATION));\n  leading_label->SetEnabledColor(text_color_);\n  leading_label->SetBackgroundColor(background_color_);\n  int width = leading_label->GetPreferredSize().width();\n\n  // Add the chip container.\n  auto* chip_container = view->AddChildView(std::make_unique<views::View>());\n  chip_container->SetLayoutManager(std::make_unique<views::FillLayout>());\n  chip_container->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred, true));\n  int corner_radius = views::LayoutProvider::Get()->GetCornerRadiusMetric(\n      views::Emphasis::kMedium);\n  chip_container->SetBackground(views::CreateBackgroundFromPainter(\n      views::Painter::CreateRoundRectWith1PxBorderPainter(\n          background_color_, bubble_outline_color_, corner_radius)));\n\n  // Add the text to the chip.\n  auto* chip_label = chip_container->AddChildView(\n      std::make_unique<EdgeChipLabel>(chip_text, CONTEXT_OMNIBOX_DECORATION));\n  chip_container->SizeToPreferredSize();\n  chip_label->SetEnabledColor(bubble_outline_color_);\n  chip_label->SetBackgroundColor(background_color_);\n  SetTooltipOnChipLabel(chip_label);\n\n  gfx::Insets chip_insets = GetInsetsForChip(chip_container, chip_label);\n  width += chip_container->GetPreferredSize().width() + chip_insets.width();\n\n  // Add text after the chip.\n  auto* trailing_label = view->AddChildView(std::make_unique<views::Label>(\n      trailing_text, CONTEXT_OMNIBOX_DECORATION));\n  trailing_label->SetEnabledColor(text_color_);\n  trailing_label->SetBackgroundColor(background_color_);\n  width += trailing_label->GetPreferredSize().width();\n\n  return width;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a view with labeled text and a stylized chip, returning the total width.","ghc_query":"view create labeled text stylized chip total width"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\dbus\\drive_file_stream_service_provider.cc:35-62","function":"DriveFileStreamServiceProvider::HandleOpenIpcChannel","codesnippet":"{\n  std::string id;\n  base::ScopedFD fd;\n  dbus::MessageReader reader(method_call);\n  if (!reader.PopString(&id)) {\n    std::move(response_sender)\n        .Run(dbus::ErrorResponse::FromMethodCall(\n            method_call, DBUS_ERROR_INVALID_ARGS,\n            \"First argument is not string.\"));\n    return;\n  }\n  if (!reader.PopFileDescriptor(&fd)) {\n    std::move(response_sender)\n        .Run(dbus::ErrorResponse::FromMethodCall(method_call,\n                                                 DBUS_ERROR_INVALID_ARGS,\n                                                 \"Second argument is not FD.\"));\n    return;\n  }\n  if (!mojo_bootstrap::PendingConnectionManager::Get().OpenIpcChannel(\n          id, std::move(fd))) {\n    std::move(response_sender)\n        .Run(dbus::ErrorResponse::FromMethodCall(method_call, DBUS_ERROR_FAILED,\n                                                 \"Failed to open IPC\"));\n    return;\n  }\n  std::move(response_sender).Run(dbus::Response::FromMethodCall(method_call));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Opens an IPC channel using a string ID and file descriptor from a D-Bus method call.","ghc_query":"IPC channel open D-Bus method call file descriptor string ID"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\api\\document_scan\\document_scan_api_handler.cc:167-193","function":"DocumentScanAPIHandler::OnScannerListReceived","codesnippet":"{\n  auto api_response =\n      std::move(mojo_response).To<api::document_scan::GetScannerListResponse>();\n  // Clear all the previously valid tokens and handles.  The backend has closed\n  // any open handles and canceled any active jobs when this extension called\n  // GetScannerList.\n  ExtensionState& state = extension_state_[runner->extension_id()];\n  state.active_scanner_ids.clear();\n  state.scanner_handles.clear();\n  state.active_job_handles.clear();\n  state.approved_scanner_handles.clear();\n\n  // If the response contains any result other than access denied, the user must\n  // have approved discovery.  If the result is access denied, the user either\n  // denied the discovery dialog or the backend refused to do discovery.  Treat\n  // both cases as not approved so the user will be prompted again.\n  state.discovery_approved =\n      api_response.result != api::document_scan::OperationResult::kAccessDenied;\n\n  for (auto& scanner : api_response.scanners) {\n    state.active_scanner_ids[scanner.scanner_id] = {.name = scanner.name};\n  }\n\n  std::move(callback).Run(std::move(api_response));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Processes scanner list response and updates extension state with scanner details and discovery approval status.","ghc_query":"scanner list response extension state update details discovery approval status"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\infobars\\infobar_view.cc:298-325","function":"InfoBarView::Layout","codesnippet":"{\n  const int spacing = GetElementSpacing();\n  int start_x = 0;\n  if (icon_) {\n    icon_->SetPosition(gfx::Point(spacing, OffsetY(icon_)));\n    start_x = icon_->bounds().right();\n  }\n\n  const int content_minimum_width = GetContentMinimumWidth();\n  if (content_minimum_width > 0) {\n    start_x += spacing + content_minimum_width;\n  }\n\n  if (close_button_) {\n    const gfx::Insets close_button_spacing = GetCloseButtonSpacing();\n    close_button_->SizeToPreferredSize();\n    close_button_->SetPosition(gfx::Point(\n        std::max(\n            start_x + close_button_spacing.left(),\n            width() - close_button_spacing.right() - close_button_->width()),\n        OffsetY(close_button_)));\n\n    // Set inkdrop and highlight path as rounded rectangle.\n    views::InstallRoundRectHighlightPathGenerator(close_button_);\n\n    // For accessibility reasons, the close button should come last.\n    DCHECK_EQ(close_button_, close_button_->parent()->children().back());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Positions UI elements including an icon, content, and a close button within a container.","ghc_query":"UI element position icon content close button container layout"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ssl\\https_upgrades_navigation_throttle.cc:45-115","function":"HttpsUpgradesNavigationThrottle::MaybeCreateAndAdd","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  // HTTPS-First Mode is only relevant for primary main-frame HTTP(S)\n  // navigations.\n  content::NavigationHandle& handle = registry.GetNavigationHandle();\n  if (!handle.GetURL().SchemeIsHTTPOrHTTPS() ||\n      !handle.IsInPrimaryMainFrame() || handle.IsSameDocument()) {\n    return;\n  }\n\n  PrefService* prefs = profile->GetPrefs();\n  security_interstitials::https_only_mode::HttpInterstitialState\n      interstitial_state;\n  interstitial_state.enabled_by_pref =\n      prefs && prefs->GetBoolean(prefs::kHttpsOnlyModeEnabled);\n\n  if (base::FeatureList::IsEnabled(features::kHttpsFirstModeIncognito)) {\n    if (profile->IsIncognitoProfile() && prefs &&\n        prefs->GetBoolean(prefs::kHttpsFirstModeIncognito)) {\n      interstitial_state.enabled_by_incognito = true;\n    }\n  }\n\n  StatefulSSLHostStateDelegate* state =\n      static_cast<StatefulSSLHostStateDelegate*>(\n          profile->GetSSLHostStateDelegate());\n\n  if (IsBalancedModeEnabled(prefs) && state &&\n      !state->HttpsFirstBalancedModeSuppressedForTesting()) {\n    interstitial_state.enabled_in_balanced_mode = true;\n  }\n\n  auto* storage_partition =\n      handle.GetWebContents()->GetPrimaryMainFrame()->GetStoragePartition();\n\n  HttpsFirstModeService* hfm_service =\n      HttpsFirstModeServiceFactory::GetForProfile(profile);\n  if (hfm_service) {\n    // Can be null in some cases, e.g. when using Ash sign-in profile.\n    hfm_service->IncrementRecentNavigationCount();\n    interstitial_state.enabled_by_typically_secure_browsing =\n        hfm_service->IsInterstitialEnabledByTypicallySecureUserHeuristic();\n  }\n\n  // StatefulSSLHostStateDelegate can be null during tests.\n  if (state &&\n      state->IsHttpsEnforcedForUrl(handle.GetURL(), storage_partition) &&\n      !MustDisableSiteEngagementHeuristic(profile)) {\n    interstitial_state.enabled_by_engagement_heuristic = true;\n  }\n\n  bool https_upgrades_enabled =\n      interstitial_state.enabled_by_pref ||\n      base::FeatureList::IsEnabled(features::kHttpsUpgrades);\n  if (!https_upgrades_enabled) {\n    return;\n  }\n\n  // Ensure that the HttpsOnlyModeTabHelper has been created (this does nothing\n  // if it has already been created for the WebContents). There are cases where\n  // the tab helper won't get created by the initialization in\n  // chrome/browser/ui/tab_helpers.cc but the criteria for adding the throttle\n  // are still met (see crbug.com/1233889 for one example).\n  HttpsOnlyModeTabHelper::CreateForWebContents(handle.GetWebContents());\n\n  registry.AddThrottle(std::make_unique<HttpsUpgradesNavigationThrottle>(\n      registry, profile, std::move(blocking_page_factory), interstitial_state));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adds an HTTPS upgrade throttle for eligible main-frame HTTP(S) navigations.","ghc_query":"HTTPS upgrade throttle main-frame navigation HTTP eligible"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_continuous_migration\\continuous_migration_logger_win.cc:226-250","function":"ContinuousMigrationLogger::WriteLogsToFile","codesnippet":"{\n  base::FilePath target_file = DeleteOldFilesAndGetTargetFile(destination_dir);\n\n  if (target_file.empty()) {\n    target_file = CreateNewLogWithTimestamp(destination_dir, base::Time::Now());\n  }\n\n  std::string final_log_contents;\n  int record_counter = 0;\n  for (const CMLog& log : logs) {\n    final_log_contents += FormatLog(log) + \"\\n\";\n    record_counter++;\n    // Perform batching to avoid string buffer overflow in case of large number\n    // of logs.\n    if (record_counter == 100) {\n      AppendContentsToFile(target_file, final_log_contents);\n      record_counter = 0;\n      final_log_contents.clear();\n    }\n  }\n\n  if (!final_log_contents.empty())\n    AppendContentsToFile(target_file, final_log_contents);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Appends formatted log entries to a file, creating a new file if necessary.","ghc_query":"log file append format entries create"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_vpn\\vpn_token_service_token_fetcher.cc:109-135","function":"VpnTokenServiceTokenFetcher::ParseResponse","codesnippet":"{\n  if (!response->is_dict()) {\n    OnError(VpnTokenManagerStatus::kJsonMissingResponsesKeyError, {});\n    return;\n  }\n\n  base::Value::List* list_value = response->GetDict().FindList(\"responses\");\n  if (!list_value) {\n    OnError(VpnTokenManagerStatus::kJsonMissingResponsesKeyError, {});\n    return;\n  }\n\n  std::vector<std::string> server_signed_tokens;\n  std::transform(list_value->cbegin(), list_value->cend(),\n                 std::back_inserter(server_signed_tokens),\n                 [](const base::Value& value) {\n                   std::string decoded;\n                   // We should never fail here. If we do the tokens will be\n                   // dropped in the Finalize cryptography step, but it means\n                   // our user will have less tokens this period\n                   base::Base64Decode(value.GetString(), &decoded);\n                   return decoded;\n                 });\n\n  std::move(callback_).Run(VpnTokenManagerStatus::kOk, {},\n                           std::move(server_signed_tokens));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Processes JSON response to decode and collect server-signed tokens.","ghc_query":"JSON response server-signed tokens decode collect process"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\wallpaper_handlers\\mock_sea_pen_fetcher.cc:49-69","function":"MockSeaPenFetcher::MockSeaPenFetcher","codesnippet":"{\n  ON_CALL(*this, FetchThumbnails)\n      .WillByDefault(\n          [](manta::proto::FeatureName feature_name,\n             const ash::personalization_app::mojom::SeaPenQueryPtr& query,\n             OnFetchThumbnailsComplete callback) {\n            base::SequencedTaskRunner::GetCurrentDefault()->PostTask(\n                FROM_HERE,\n                base::BindOnce(std::move(callback), MakeFakeImageResults(),\n                               manta::MantaStatusCode::kOk));\n          });\n\n  ON_CALL(*this, FetchWallpaper)\n      .WillByDefault(\n          [](manta::proto::FeatureName feature_name,\n             const ash::SeaPenImage& image,\n             const ash::personalization_app::mojom::SeaPenQueryPtr& query,\n             OnFetchWallpaperComplete callback) {\n            std::move(callback).Run(\n                ash::SeaPenImage(CreateJpgBytes(), image.id));\n          });\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sets default behaviors for fetching thumbnails and wallpaper images using mock callbacks.","ghc_query":"thumbnail fetching wallpaper mock callbacks image default behaviors"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\permissions\\permission_prompt_chip.cc:112-149","function":"PermissionPromptChip::PreemptivelyResolvePermissionRequest","codesnippet":"{\n  DCHECK(delegate->ShouldCurrentRequestUseQuietUI());\n\n  bool is_subscribed_to_permission_change_event = true;\n  content::PermissionController* permission_controller =\n      web_contents->GetBrowserContext()->GetPermissionController();\n\n  // If at least one RFH is not subscribed to the PermissionChange event, we\n  // should not preemptively resolve a prompt.\n  for (const auto& request : delegate->Requests()) {\n    content::RenderFrameHost* rfh =\n        content::RenderFrameHost::FromID(request->get_requesting_frame_id());\n    if (rfh == nullptr) {\n      return;\n    }\n\n    ContentSettingsType type = request->GetContentSettingsType();\n\n    blink::PermissionType permission_type =\n        permissions::PermissionUtil::ContentSettingsTypeToPermissionType(type);\n\n    // Pre-ignore is allowed only for the quiet chip. The quiet chip is\n    // enabled only for `NOTIFICATIONS` and `GEOLOCATION`.\n    DCHECK(permission_type == blink::PermissionType::NOTIFICATIONS ||\n           permission_type == blink::PermissionType::GEOLOCATION);\n\n    is_subscribed_to_permission_change_event &=\n        permission_controller->IsSubscribedToPermissionChangeEvent(\n            permission_type, rfh);\n\n    if (is_subscribed_to_permission_change_event) {\n      // This will resolve a promise so an origin is not waiting for the user's\n      // decision.\n      delegate->PreIgnoreQuietPrompt();\n    }\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles quiet UI requests by checking permission change subscriptions and potentially resolving prompts.","ghc_query":"handle quiet ui request permission change subscription resolve prompt"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync_bookmarks\\bookmark_specifics_conversions.cc:653-730","function":"IsValidBookmarkSpecifics","codesnippet":"{\n  bool is_valid = true;\n  if (specifics.ByteSizeLong() == 0) {\n    DLOG(ERROR) << \"Invalid bookmark: empty specifics.\";\n    LogInvalidSpecifics(InvalidBookmarkSpecificsError::kEmptySpecifics);\n    is_valid = false;\n  }\n  const base::Uuid guid = base::Uuid::ParseLowercase(specifics.guid());\n\n  if (!guid.is_valid()) {\n    DLOG(ERROR) << \"Invalid bookmark: invalid UUID in specifics.\";\n    LogInvalidSpecifics(InvalidBookmarkSpecificsError::kInvalidGUID);\n    is_valid = false;\n  } else if (guid.AsLowercaseString() ==\n             bookmarks::kBannedUuidDueToPastSyncBug) {\n    DLOG(ERROR) << \"Invalid bookmark: banned UUID in specifics.\";\n    LogInvalidSpecifics(InvalidBookmarkSpecificsError::kBannedGUID);\n    is_valid = false;\n  }\n\n  const base::Uuid parent_guid =\n      base::Uuid::ParseLowercase(specifics.parent_guid());\n  if (!parent_guid.is_valid()) {\n    DLOG(ERROR) << \"Invalid bookmark: invalid parent UUID in specifics.\";\n    LogInvalidSpecifics(InvalidBookmarkSpecificsError::kInvalidParentGUID);\n    is_valid = false;\n  }\n\n  switch (specifics.type()) {\n    case sync_pb::BookmarkSpecifics::UNSPECIFIED:\n      // Note that old data doesn't run into this because DataTypeWorker takes\n      // care of backfilling the field.\n      DLOG(ERROR) << \"Invalid bookmark: invalid type in specifics.\";\n      is_valid = false;\n      break;\n    case sync_pb::BookmarkSpecifics::URL:\n      if (!GURL(specifics.url()).is_valid()) {\n        DLOG(ERROR) << \"Invalid bookmark: invalid url in the specifics.\";\n        LogInvalidSpecifics(InvalidBookmarkSpecificsError::kInvalidURL);\n        is_valid = false;\n      }\n      if (specifics.favicon().empty() && !specifics.icon_url().empty()) {\n        DLOG(ERROR) << \"Invalid bookmark: specifics cannot have an icon_url \"\n                       \"without having a favicon.\";\n        LogInvalidSpecifics(\n            InvalidBookmarkSpecificsError::kIconURLWithoutFavicon);\n        is_valid = false;\n      }\n      if (!specifics.icon_url().empty() &&\n          !GURL(specifics.icon_url()).is_valid()) {\n        DLOG(ERROR) << \"Invalid bookmark: invalid icon_url in specifics.\";\n        LogInvalidSpecifics(InvalidBookmarkSpecificsError::kInvalidIconURL);\n        is_valid = false;\n      }\n      break;\n    case sync_pb::BookmarkSpecifics::FOLDER:\n      break;\n  }\n\n  if (!syncer::UniquePosition::FromProto(specifics.unique_position())\n           .IsValid()) {\n    // Ignore updates with invalid positions.\n    DLOG(ERROR) << \"Invalid bookmark: invalid unique position.\";\n    LogInvalidSpecifics(InvalidBookmarkSpecificsError::kInvalidUniquePosition);\n    is_valid = false;\n  }\n\n  // Verify all keys in meta_info are unique.\n  std::unordered_set<std::string_view> keys;\n  for (const sync_pb::MetaInfo& meta_info : specifics.meta_info()) {\n    if (!keys.insert(meta_info.key()).second) {\n      DLOG(ERROR) << \"Invalid bookmark: keys in meta_info aren't unique.\";\n      LogInvalidSpecifics(\n          InvalidBookmarkSpecificsError::kNonUniqueMetaInfoKeys);\n      is_valid = false;\n    }\n  }\n  return is_valid;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates bookmark specifics for correctness and uniqueness.","ghc_query":"validate bookmark specific correct unique verify"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_wallet\\core\\browser\\express_checkout\\trigger\\trigger_context.cc:75-101","function":"SavingsInfo::Reset","codesnippet":"{\n  is_coupon_visible = false;\n  is_coupon_disallowed = false;\n  is_support_auto_apply_in_shopping = false;\n  is_shoping_rebates_check_pass = false;\n  is_rebates_disallowed = false;\n  is_rebates_user = false;\n  is_current_url_rebates_actived = false;\n  is_rewards_enabled = false;\n  is_rewards_enrolled_user = false;\n  gift_card_infos.clear();\n  is_valid_rewards_user = false;\n  has_valid_sku = false;\n  rewards_points = 0;\n  is_points_enough = false;\n  show_coupon = false;\n  show_rebates = false;\n  show_rewards = false;\n  is_cashback_gift_card_enabled = false;\n  is_valid_cashback_gift_card_fetched = false;\n  is_denomination_more_than_cart_value = false;\n  show_cashback_gift_card = false;\n  is_cashback_currency_code_matched = false;\n  is_rebates_page_url_matched = false;\n  is_gift_card_only_triggered = false;\n  cashback_gift_card_infos.clear();\n  shopping_page_url.clear();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Resets various shopping and rewards-related flags and clears gift card information.","ghc_query":"reset shopping reward flag clear gift card information"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\win\\edge_search_indexer\\search_indexer_service.cc:589-621","function":"SearchIndexerService::OnIndexerStoppedOnBrowserClose","codesnippet":"{\n  RETURN_VOID_IF(!is_initialized() || !IndexersAreStopped());\n\n  // All data for |profile_| is deleted in OnIndexerStoppedForProfileDeletion if\n  // it was marked for deletion while we were stopping indexers.\n  if (IsProfileDirectoryMarkedForDeletion(profile_->GetPath())) {\n    return;\n  }\n\n  // There are two possibilities when the last browser window is closed:\n  // 1. Edge goes through the normal shutdown process. The utility process is\n  //    terminated for us in this case.\n  // 2. Edge keeps running in the background because of features like Edge bar.\n  //    We want to make sure that the utility process is not left running in\n  //    this case, so we kick off a timer to terminate it after some time.\n  if (chrome::GetTotalBrowserCount() == 0) {\n    int delay = kTerminateUtilityProcessDelay;\n    if (SearchIndexerService::test_observer_) {\n      delay = 1;\n    }\n\n    process_termination_timer_.Start(\n        FROM_HERE, base::Seconds(delay),\n        base::BindOnce(&SearchIndexerService::IndexingStoppedForProfile,\n                       weak_ptr_factory_.GetWeakPtr()));\n  } else {\n    // Update global indexing state for |profile_|.\n    IndexingStoppedForProfile();\n  }\n\n  if (SearchIndexerService::test_observer_) {\n    SearchIndexerService::test_observer_->OnIndexerStoppedOnBrowserClose();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Manages the termination of a utility process when the browser closes or updates indexing state.","ghc_query":"manage termination utility process browser close update indexing state"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_3p\\content\\browser\\edge_serp_client.cc:41-73","function":"ShouldLogSerpEvent","codesnippet":"{\n  DCHECK(edge_3p::features::IsEdge3PTelemetryEnabled());\n\n  if (edge_3p::features::IsEnterprise()) {\n    return edge_3p::mojom::SerpLoggingEligibilityStatus::\n        kLoggingNotAllowedForEnterpriseProfile;\n  }\n\n  if (!edge_3p::edge_serp_client_util::IsEdge3PSerpPolicyEnabled()) {\n    return edge_3p::mojom::SerpLoggingEligibilityStatus::\n        kDroppedDueToEdge3PGroupPolicyDisabled;\n  }\n\n  if (is_private) {\n    return edge_3p::mojom::SerpLoggingEligibilityStatus::\n        kLoggingNotAllowedInPrivateMode;\n  }\n\n  if (!web_contents) {\n    return edge_3p::mojom::SerpLoggingEligibilityStatus::\n        kDroppedDueToInvalidWebContent;\n  }\n\n  if (!edge_3p::features::IsEdge3PTelemetryConsentOverrideEnabled() &&\n      !edge_3p::edge_serp_client_util::HasUserConsentGiven(\n          web_contents->GetBrowserContext())) {\n    return edge_3p::mojom::SerpLoggingEligibilityStatus::\n        kLoggingNotAllowedDueToConsentNotEnabled;\n  }\n\n  return edge_3p::mojom::SerpLoggingEligibilityStatus::kSuccess;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the eligibility status for SERP logging based on various conditions.","ghc_query":"determine eligibility status serp logging condition"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\api\\proxy\\proxy_api_helpers.cc:454-483","function":"CreateProxyServerDict","codesnippet":"{\n  base::Value::Dict out;\n  const char* scheme = nullptr;\n  CHECK(proxy_chain.is_single_proxy());\n  const net::ProxyServer& proxy = proxy_chain.First();\n  switch (proxy.scheme()) {\n    case net::ProxyServer::SCHEME_HTTP:\n      scheme = \"http\";\n      break;\n    case net::ProxyServer::SCHEME_HTTPS:\n      scheme = \"https\";\n      break;\n    case net::ProxyServer::SCHEME_QUIC:\n      scheme = \"quic\";\n      break;\n    case net::ProxyServer::SCHEME_SOCKS4:\n      scheme = \"socks4\";\n      break;\n    case net::ProxyServer::SCHEME_SOCKS5:\n      scheme = \"socks5\";\n      break;\n    case net::ProxyServer::SCHEME_INVALID:\n      NOTREACHED();\n  }\n  out.Set(proxy_api_constants::kProxyConfigRuleScheme, scheme);\n  out.Set(proxy_api_constants::kProxyConfigRuleHost,\n          proxy.host_port_pair().host());\n  out.Set(proxy_api_constants::kProxyConfigRulePort,\n          proxy.host_port_pair().port());\n  return out;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a dictionary with proxy server configuration details.","ghc_query":"create dictionary proxy server configuration detail"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_nurturing\\action_handler\\nurturing_iris_action_handler.cc:65-96","function":"NurturingIrisActionHandler::HandleAction","codesnippet":"{\n  SetCampaignId(campaign_id);\n\n  if (!payload || payload->empty()) {\n    RunUiCallbackAndDeleteAction(action_store, store_index, campaign_id,\n                                 /*action_completion_status*/ false);\n    return;\n  }\n\n  const std::string* beacon_type = payload->FindString(ui::kIrisResponse);\n  const std::string* url = payload->FindString(ui::kURL);\n  std::string action;\n  if (payload->FindString(ui::kIrisAction))\n    action = *(payload->FindString(ui::kIrisAction));\n\n  GURL beacon;\n  if (url && GURL(*url).is_valid())\n    beacon = GURL(*url);\n\n  if (beacon_type && !beacon_type->empty() && !beacon.is_empty()) {\n    HandleIrisBeacon(*beacon_type, beacon, action);\n  }\n\n  RunUiCallbackAndDeleteAction(action_store, store_index, campaign_id,\n                               /*action_completion_status*/ true);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Processes a payload to handle a beacon and executes a UI callback.","ghc_query":"process payload handle beacon execute ui callback"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\security_interstitials\\core\\mitm_software_ui.cc:40-64","function":"MITMSoftwareUI::PopulateStringsForHTML","codesnippet":"{\n  // Shared with other SSL errors.\n  common_string_util::PopulateSSLLayoutStrings(cert_error_, load_time_data);\n  common_string_util::PopulateSSLDebuggingStrings(\n      ssl_info_, base::Time::NowFromSystemTime(), load_time_data);\n\n  // Set display booleans.\n  load_time_data.Set(\"overridable\", false);\n  load_time_data.Set(\"hide_primary_button\", true);\n  load_time_data.Set(\"bad_clock\", false);\n\n  // Set strings that are shared between enterprise and non-enterprise\n  // interstitials.\n  load_time_data.Set(\"tabTitle\", l10n_util::GetStringUTF16(IDS_SSL_V2_TITLE));\n  load_time_data.Set(\"heading\",\n                     l10n_util::GetStringUTF16(IDS_MITM_SOFTWARE_HEADING));\n  load_time_data.Set(\"primaryButtonText\", \"\");\n  load_time_data.Set(\"finalParagraph\", \"\");\n\n  if (is_enterprise_managed_) {\n    MITMSoftwareUI::PopulateEnterpriseUserStringsForHTML(load_time_data);\n    return;\n  }\n\n  MITMSoftwareUI::PopulateAtHomeUserStringsForHTML(load_time_data);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Populates SSL error display data for interstitial pages.","ghc_query":"populate ssl error display data interstitial page"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\dom_distiller\\edge_chrome_dom_distiller_client.cc:81-118","function":"ChromeDomDistillerClient::OnViewerInitialized","codesnippet":"{\n  if (!IsEdgeReadingViewBarEnabled())\n    return;\n\n  content::WebContents* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n\n#if BUILDFLAG(IS_ANDROID)\n  render_frame_host->ExecuteJavaScript(\n      base::UTF8ToUTF16(viewer::GetToolbarHeightJs()), {});\n#endif\n\n  std::string script = viewer::GetBarInitializationScript(\n      IDR_READING_VIEW_BAR_JS, GetReadingViewFeatures(web_contents),\n      GetReadingViewFeaturesDisabledByPolicy(web_contents));\n\n  render_frame_host->ExecuteJavaScriptInIsolatedWorld(\n      base::UTF8ToUTF16(script), {} /* callback */,\n      ISOLATED_WORLD_ID_CHROME_INTERNAL);\n\n  // Inject focus-visible polyfill\n  // This should be removed onced https://dev.azure.com/microsoftdesign/FAST/_workitems/edit/10878/ is resolved.\n  script = ui::ResourceBundle::GetSharedInstance()\n               .LoadDataResourceString(IDR_READING_VIEW_BAR_FOCUS_VISIBLE_SCRIPT);\n\n  render_frame_host->ExecuteJavaScriptInIsolatedWorld(\n      base::UTF8ToUTF16(script), {} /* callback */,\n      ISOLATED_WORLD_ID_CHROME_INTERNAL);\n\n  CreateViewerZoomController(web_contents);\n\n  // Update the browserUI with zoom level according to default font size because\n  // zoom level update to default on the JS side doesn't bubble up to cpp side.\n  // This is needed so that the viewer once created shows the correct value in\n  // the browser zoom UI i.e. omnibox lens icon and browser more menu.\n  UpdateBrowserZoomUI(web_contents,\n                      GetDistilledPagePrefs(web_contents)->GetFontSize());\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and configures the reading view bar in the browser.","ghc_query":"initialize configure reading view bar browser"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\win\\edge_wdag\\host\\manager_impl.cc:87-115","function":"MakeTransportParams","codesnippet":"{\n#if BUILDFLAG(ENABLE_WDAG_V2_PROTOTYPE)\n  if (pipe_name) {\n    mojo::NamedPlatformChannel::Options options;\n    options.enforce_local_naming = false;\n    options.server_name = host::GetFullPipeName(*pipe_name);\n    mojo::NamedPlatformChannel channel(options);\n    auto handle = channel.TakeServerEndpoint().TakePlatformHandle();\n    VLOG(0) << \"pipe-name:\"\n            << base::Value(base::WideToUTF16(options.server_name));\n    shared_named_pipe = container::SharedNamedPipe::Create(\n        container_id, options.server_name);\n    // Note, we'll continue in the face of pipe-sharing errors.\n    // Things will fail later.\n    if (!shared_named_pipe)\n      LOG(ERROR) << \"share-failed\";\n    return wdag::mojom::HostTransportParams::NewNamedPipe(\n        mojo::WrapPlatformHandle(std::move(handle)));\n  }\n#endif\n  return wdag::mojom::HostTransportParams::NewHvSocketServiceGuid(\n      GetHvSocketGuidAsString(chrome::GetChannel()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a host transport parameter using a named pipe or HV socket service GUID.","ghc_query":"create host transport parameter named pipe hv socket service guid"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\browsing_data\\navigation_entry_remover.cc:214-239","function":"RemoveNavigationEntries","codesnippet":"{\n  DCHECK(!profile->IsOffTheRecord());\n  DCHECK(!deletion_info.is_from_expiration());\n\n  base::flat_set<GURL> url_set;\n  if (!deletion_info.time_range().IsValid())\n    url_set = CreateUrlSet(deletion_info.deleted_rows());\n\n  DeleteTabNavigationEntries(profile, deletion_info.time_range(),\n                             deletion_info.restrict_urls(), url_set);\n  DeleteTabRestoreEntries(profile, deletion_info.time_range(),\n                          deletion_info.restrict_urls(), url_set);\n\n  // Removal of navigation entries may occur at any point during runtime and\n  // session service data is cleared so that it can be later rebuilt without the\n  // deleted entries.\n  // However deletion of foreign visits specifically can occur during startup\n  // and clearing session service data will delete the user's previous session\n  // with no ability to rebuild/recover (see crbug.com/1424800). Foreign visits\n  // can't be part of the local session so there is no risk of retaining the\n  // session service data in this case.\n  if (deletion_info.deletion_reason() !=\n      history::DeletionInfo::Reason::kDeleteAllForeignVisits) {\n    DeleteLastSessionFromSessionService(profile);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Deletes navigation and session entries based on specified criteria.","ghc_query":"delete navigation session entry criteria specify"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\apps\\app_service\\intent_util.cc:681-839","function":"CreateIntentFilterForArc","codesnippet":"{\n  auto intent_filter = std::make_unique<apps::IntentFilter>();\n\n  bool has_view_action = false;\n  apps::ConditionValues action_condition_values;\n  for (auto& arc_action : arc_intent_filter.actions()) {\n    const char* action = ConvertArcToAppServiceIntentAction(arc_action);\n    has_view_action = has_view_action || action == kIntentActionView;\n\n    if (!action) {\n      continue;\n    }\n\n    action_condition_values.push_back(std::make_unique<apps::ConditionValue>(\n        action, apps::PatternMatchType::kLiteral));\n  }\n  if (!action_condition_values.empty()) {\n    auto action_condition = std::make_unique<apps::Condition>(\n        apps::ConditionType::kAction, std::move(action_condition_values));\n    intent_filter->conditions.push_back(std::move(action_condition));\n  }\n\n  bool is_mime_file_filter =\n      has_view_action && arc_intent_filter.mime_types().size() > 0;\n  bool is_file_extension_filter = IsFileExtensionFilter(arc_intent_filter);\n  bool is_file_filter = is_mime_file_filter || is_file_extension_filter;\n\n  // Don't allow scheme/ host for ARC view file filters.\n  if (!is_file_filter) {\n    apps::ConditionValues scheme_condition_values;\n    for (auto& scheme : arc_intent_filter.schemes()) {\n      scheme_condition_values.push_back(std::make_unique<apps::ConditionValue>(\n          scheme, apps::PatternMatchType::kLiteral));\n    }\n    if (!scheme_condition_values.empty()) {\n      auto scheme_condition = std::make_unique<apps::Condition>(\n          apps::ConditionType::kScheme, std::move(scheme_condition_values));\n      intent_filter->conditions.push_back(std::move(scheme_condition));\n    }\n\n    apps::ConditionValues host_condition_values;\n    for (auto& authority : arc_intent_filter.authorities()) {\n      auto match_type = authority.wild() ? apps::PatternMatchType::kSuffix\n                                         : apps::PatternMatchType::kLiteral;\n      host_condition_values.push_back(\n          std::make_unique<apps::ConditionValue>(authority.host(), match_type));\n    }\n\n    if (!host_condition_values.empty()) {\n      // It's common for Android apps to include duplicate host conditions, we\n      // can de-duplicate these to reduce time/space usage down the line.\n      std::sort(\n          host_condition_values.begin(), host_condition_values.end(),\n          [](const apps::ConditionValuePtr& v1,\n             const apps::ConditionValuePtr& v2) -> bool {\n            return v1->value < v2->value ||\n                   (v1->value == v2->value && v1->match_type < v2->match_type);\n          });\n      host_condition_values.erase(\n          std::unique(host_condition_values.begin(),\n                      host_condition_values.end(),\n                      [](const apps::ConditionValuePtr& v1,\n                         const apps::ConditionValuePtr& v2) -> bool {\n                        return *v1 == *v2;\n                      }),\n          host_condition_values.end());\n\n      auto host_condition = std::make_unique<apps::Condition>(\n          apps::ConditionType::kAuthority, std::move(host_condition_values));\n      intent_filter->conditions.push_back(std::move(host_condition));\n    }\n  }\n\n  apps::ConditionValues path_condition_values;\n  bool has_invalid_path = false;\n  for (auto& path : arc_intent_filter.paths()) {\n    apps::ConditionValuePtr path_condition_value =\n        ConvertArcPatternMatcherToConditionValue(path);\n    if (path_condition_value) {\n      path_condition_values.push_back(std::move(path_condition_value));\n    } else {\n      has_invalid_path = true;\n    }\n  }\n\n  // If there is path condition set in ARC app, but we cannot get valid path,\n  // it is likely that the only path condition set in ARC is value that we\n  // cannot handle. We should not create this intent filter because empty path\n  // condition means it matches with any path, which is different from what it\n  // is expected.\n  if (path_condition_values.empty() && has_invalid_path) {\n    return nullptr;\n  }\n\n  // For ARC apps, specifying a path is optional. For any intent filters which\n  // match every URL on a host with a \"view\" action, add a path which matches\n  // everything to ensure the filter is treated as a supported link.\n  if (path_condition_values.empty() && has_view_action &&\n      arc_intent_filter.authorities().size() > 0 &&\n      arc_intent_filter.schemes().size() > 0) {\n    path_condition_values.push_back(std::make_unique<apps::ConditionValue>(\n        \"/\", apps::PatternMatchType::kPrefix));\n  }\n\n  // For path file filters, extract the desired file extension from the path\n  // fields listed in the intent filter and add it to the new filter as a\n  // general kFile condition.\n  if (is_file_extension_filter) {\n    // Convert the path condition values into extension condition values.\n    apps::ConditionValues ext_condition_values =\n        ConvertPathToExtensionConditionValues(std::move(path_condition_values));\n    // If this is a path file filter without any valid file extensions, then the\n    // entire intent filter is invalid.\n    if (ext_condition_values.size() == 0) {\n      return nullptr;\n    }\n    // Wrap any found extension condition values into one file condition.\n    auto file_condition = std::make_unique<apps::Condition>(\n        apps::ConditionType::kFile, std::move(ext_condition_values));\n    intent_filter->conditions.push_back(std::move(file_condition));\n  } else if (!path_condition_values.empty()) {\n    auto path_condition = std::make_unique<apps::Condition>(\n        apps::ConditionType::kPath, std::move(path_condition_values));\n    intent_filter->conditions.push_back(std::move(path_condition));\n  }\n\n  if (!is_file_extension_filter) {\n    apps::ConditionValues mime_type_condition_values;\n    for (auto& mime_type : arc_intent_filter.mime_types()) {\n      mime_type_condition_values.push_back(\n          std::make_unique<apps::ConditionValue>(\n              mime_type, apps::PatternMatchType::kMimeType));\n    }\n    if (!mime_type_condition_values.empty()) {\n      // For ARC view file intents, save the mime type conditions under kFile\n      // instead of kMimeType to maintain consistency with view file intents of\n      // other app types.\n      if (is_mime_file_filter) {\n        auto file_type_condition = std::make_unique<apps::Condition>(\n            apps::ConditionType::kFile, std::move(mime_type_condition_values));\n        intent_filter->conditions.push_back(std::move(file_type_condition));\n      } else {\n        auto mime_type_condition = std::make_unique<apps::Condition>(\n            apps::ConditionType::kMimeType,\n            std::move(mime_type_condition_values));\n        intent_filter->conditions.push_back(std::move(mime_type_condition));\n      }\n    }\n  }\n\n  if (!arc_intent_filter.activity_name().empty()) {\n    intent_filter->activity_name = arc_intent_filter.activity_name();\n  }\n  if (!arc_intent_filter.activity_label().empty()) {\n    intent_filter->activity_label = arc_intent_filter.activity_label();\n  }\n\n  return intent_filter;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Converts an ARC intent filter into an app service intent filter with conditions based on actions, schemes, authorities, paths, and MIME types.","ghc_query":"convert arc intent filter app service action scheme authority path mime type"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\extensions\\api\\processes\\processes_api.cc:250-318","function":"ProcessesEventRouter::OnTasksRefreshedWithBackgroundCalculations","codesnippet":"{\n  const bool has_on_updated_listeners =\n      HasEventListeners(api::processes::OnUpdated::kEventName);\n  const bool has_on_updated_with_memory_listeners =\n      HasEventListeners(api::processes::OnUpdatedWithMemory::kEventName);\n\n  if (!has_on_updated_listeners && !has_on_updated_with_memory_listeners)\n    return;\n\n  // Get the data of tasks sharing the same process only once.\n  std::set<base::ProcessId> seen_processes;\n  base::Value::Dict processes_dictionary;\n  for (const auto& task_id : task_ids) {\n    // We are not interested in tasks, but rather the processes on which they\n    // run.\n    const base::ProcessId proc_id =\n        observed_task_manager()->GetProcessId(task_id);\n    if (seen_processes.count(proc_id))\n      continue;\n\n    const int child_process_host_id =\n        observed_task_manager()->GetChildProcessUniqueId(task_id);\n    // Ignore tasks that don't have a valid child process host ID like ARC\n    // processes. We report the browser process info here though.\n    if (child_process_host_id == content::ChildProcessHost::kInvalidUniqueID)\n      continue;\n\n    seen_processes.insert(proc_id);\n    api::processes::Process process;\n    FillProcessData(task_id,\n                    observed_task_manager(),\n                    true,  // include_optional\n                    &process);\n\n    if (has_on_updated_with_memory_listeners) {\n      // Append the memory footprint to the process data.\n      const int64_t memory_footprint =\n          observed_task_manager()->GetMemoryFootprintUsage(task_id);\n      process.private_memory = static_cast<double>(memory_footprint);\n    }\n\n    // Store each process indexed by the string version of its ChildProcessHost\n    // ID.\n    processes_dictionary.Set(base::NumberToString(child_process_host_id),\n                             process.ToValue());\n  }\n\n  // Done with data collection. Now dispatch the appropriate events according to\n  // the present listeners.\n  DCHECK(has_on_updated_listeners || has_on_updated_with_memory_listeners);\n  if (has_on_updated_listeners) {\n    api::processes::OnUpdated::Processes processes;\n    processes.additional_properties.Merge(processes_dictionary.Clone());\n    // NOTE: If there are listeners to the updates with memory as well,\n    // listeners to onUpdated (without memory) will also get the memory info\n    // of processes as an added bonus.\n    DispatchEvent(events::PROCESSES_ON_UPDATED,\n                  api::processes::OnUpdated::kEventName,\n                  api::processes::OnUpdated::Create(processes));\n  }\n\n  if (has_on_updated_with_memory_listeners) {\n    api::processes::OnUpdatedWithMemory::Processes processes;\n    processes.additional_properties.Merge(std::move(processes_dictionary));\n    DispatchEvent(events::PROCESSES_ON_UPDATED_WITH_MEMORY,\n                  api::processes::OnUpdatedWithMemory::kEventName,\n                  api::processes::OnUpdatedWithMemory::Create(processes));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Dispatches process update events with optional memory data to listeners.","ghc_query":"dispatch process update event memory data listener"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\account_manager_core\\account_manager_util.cc:22-47","function":"FromMojoInvalidGaiaCredentialsReason","codesnippet":"{\n  switch (mojo_reason) {\n    case cm::GoogleServiceAuthError::InvalidGaiaCredentialsReason::kUnknown:\n      return GoogleServiceAuthError::InvalidGaiaCredentialsReason::UNKNOWN;\n    case cm::GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n        kCredentialsRejectedByServer:\n      return GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n          CREDENTIALS_REJECTED_BY_SERVER;\n    case cm::GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n        kCredentialsRejectedByClient:\n      return GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n          CREDENTIALS_REJECTED_BY_CLIENT;\n    case cm::GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n        kCredentialsMissing:\n      return GoogleServiceAuthError::InvalidGaiaCredentialsReason::\n          CREDENTIALS_MISSING;\n    default:\n      LOG(WARNING) << \"Unknown \"\n                      \"crosapi::mojom::GoogleServiceAuthError::\"\n                      \"InvalidGaiaCredentialsReason: \"\n                   << mojo_reason;\n      return GoogleServiceAuthError::InvalidGaiaCredentialsReason::UNKNOWN;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps and returns the corresponding GoogleServiceAuthError reason based on the provided mojo_reason.","ghc_query":"map return googleserviceautherror reason mojo"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\os_integration\\web_app_shortcut.cc:356-377","function":"ShortcutLocations::ToDebugValue","codesnippet":"{\n  base::Value::Dict debug_log;\n  debug_log.Set(\"on_desktop\", on_desktop);\n  debug_log.Set(\"in_quick_launch_bar\", in_quick_launch_bar);\n  debug_log.Set(\"in_startup\", in_startup);\n  std::string menu_loc;\n  switch (applications_menu_location) {\n    case APP_MENU_LOCATION_NONE:\n      menu_loc = \"LOC_NONE\";\n      break;\n    case APP_MENU_LOCATION_SUBDIR_CHROMEAPPS:\n      menu_loc = \"SUBDIR_CHROMEAPPS\";\n      break;\n    case APP_MENU_LOCATION_HIDDEN:\n      menu_loc = \"HIDDEN\";\n      break;\n    case APP_MENU_LOCATION_ROOT:\n      menu_loc = \"LOC_ROOT\";\n      break;\n  }\n  debug_log.Set(\"menu_location\", menu_loc);\n  return base::Value(std::move(debug_log));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a dictionary of application debug information and returns it.","ghc_query":"create dictionary application debug information return"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\services\\edge_search_indexer\\build_indexer_impl.cc:58-93","function":"BuildIndexerImpl::QueryVersionNumbers","codesnippet":"{\n  HRESULT hr = S_OK;\n  auto exit_fn =\n      base::MakeScopeExit([&] { std::move(callback).Run((int)hr, \"\", \"\"); });\n\n  auto properties = Make<base::win::Vector<HSTRING>>();\n  hr = properties->Append(build_version_prop_.Get());\n  if (FAILED(hr))\n    return;\n\n  hr = properties->Append(schema_version_prop_.Get());\n  if (FAILED(hr))\n    return;\n\n  // Filter must be non-empty.\n  base::win::HStringReference filter(L\"*\");\n  QueryItem(\n      scope_for_build_, filter.Get(), properties,\n      base::BindRepeating(\n          [](base::WeakPtr<BuildIndexerImpl> weak_ptr,\n             QueryVersionNumbersCallback callback, HRESULT hr,\n             ComPtr<QueryResults> query_results) {\n            if (weak_ptr) {\n              std::string build_version;\n              std::string schema_version;\n              if (SUCCEEDED(hr)) {\n                hr = weak_ptr->GetVersionNumbersFromQueryResults(\n                    query_results, build_version, schema_version);\n              }\n              std::move(callback).Run((int)hr, build_version, schema_version);\n            }\n          },\n          weak_ptr_factory_.GetWeakPtr(), base::Passed(std::move(callback))));\n\n  exit_fn.Dismiss();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Queries version numbers and executes a callback with the results.","ghc_query":"query version number execute callback result"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\profiles\\profiles_state.cc:184-220","function":"GetAvatarNameForProfile","codesnippet":"{\n  if (profile_path == ProfileManager::GetGuestProfilePath()) {\n    return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);\n  }\n\n  ProfileAttributesStorage& storage =\n      g_browser_process->profile_manager()->GetProfileAttributesStorage();\n\n  ProfileAttributesEntry* entry =\n      storage.GetProfileAttributesWithPath(profile_path);\n  if (!entry)\n    return l10n_util::GetStringUTF16(IDS_SINGLE_PROFILE_DISPLAY_NAME);\n\n  const std::u16string profile_name_to_display = entry->GetName();\n  // If the user has set their local profile name on purpose.\n  bool is_default_name = entry->IsUsingDefaultName();\n  if (!is_default_name)\n    return profile_name_to_display;\n\n  // The profile is signed in and has a GAIA name.\n  const std::u16string gaia_name_to_display = entry->GetGAIANameToDisplay();\n  if (!gaia_name_to_display.empty())\n    return profile_name_to_display;\n\n  // For a single profile that does not have a GAIA name\n  // (most probably not signed in), with a default name\n  // (i.e. of the form Person %d) not manually set, it should display\n  // IDS_SINGLE_PROFILE_DISPLAY_NAME.\n  if (storage.GetNumberOfProfiles() == 1u)\n    return l10n_util::GetStringUTF16(IDS_SINGLE_PROFILE_DISPLAY_NAME);\n\n  // If the profile is signed in but does not have a GAIA name nor a custom\n  // local profile name, show the email address if it exists.\n  // Otherwise, show the profile name which is expected to be the local\n  // profile name.\n  const std::u16string email = entry->GetUserName();\n  return email.empty() ? profile_name_to_display : email;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines and returns the display name for a user profile.","ghc_query":"determine return display name user profile"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\frame\\picture_in_picture_browser_frame_view_linux.cc:120-146","function":"PictureInPictureBrowserFrameViewLinux::OnPaint","codesnippet":"{\n  // Draw the PiP window frame borders and shadows, including the top bar\n  // background.\n  if (window_frame_provider_) {\n    window_frame_provider_->PaintWindowFrame(\n        canvas, GetLocalBounds(), GetTopAreaHeight(), ShouldPaintAsActive(),\n        GetInputInsets());\n  } else {\n    CHECK(frame_background_);\n    frame_background_->set_frame_color(\n        GetColorProvider()->GetColor(kColorPipWindowTopBarBackground));\n    frame_background_->set_use_custom_frame(frame()->UseCustomFrame());\n    frame_background_->set_is_active(ShouldPaintAsActive());\n    frame_background_->set_theme_image(GetFrameImage());\n\n    frame_background_->set_theme_image_inset(\n        browser_view()->GetThemeOffsetFromBrowserView());\n    frame_background_->set_theme_overlay_image(GetFrameOverlayImage());\n    frame_background_->set_top_area_height(GetTopAreaHeight());\n    PaintRestoredFrameBorderLinux(\n        *canvas, *this, frame_background_.get(), GetRestoredClipRegion(),\n        ShouldDrawFrameShadow(), ShouldPaintAsActive(),\n        RestoredMirroredFrameBorderInsets(), GetShadowValues(),\n        frame()->tiled());\n  }\n\n  BrowserNonClientFrameView::OnPaint(canvas);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Renders the Picture-in-Picture window frame and top bar.","ghc_query":"render picture-in-picture pip window frame top bar"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\edge_themes\\ai_image_fetcher_service.cc:222-286","function":"ParseApiResponse","codesnippet":"{\n  base::UmaHistogramTimes(std::string(kMarketingHistogramPrefix) +\n                              std::string(api_name) +\n                              std::string(kLatencySuffix),\n                          base::TimeTicks::Now() - request_start_time);\n  // figure out the response codes\n  int response_code = -1;\n  CHECK(simple_loader);\n  int error_code = simple_loader->NetError();\n  if (simple_loader->ResponseInfo() && simple_loader->ResponseInfo()->headers) {\n    response_code = simple_loader->ResponseInfo()->headers->response_code();\n  }\n\n  bool error_response = false;\n  if (response_code != net::HTTP_OK || error_code != 0) {\n    error_response = true;\n    // If response code is not OK, use the response code as error code if it is\n    // not -1. In case it is -1, use the network error code instead.\n    response_code = (response_code != -1 && response_code != net::HTTP_OK)\n                        ? response_code\n                        : error_code;\n  }\n\n  // log the response codes\n  base::UmaHistogramSparse(std::string(kMarketingHistogramPrefix) +\n                               std::string(api_name) +\n                               std::string(kResponseCodeSuffix),\n                           response_code);\n\n  // In case of empty response body, return early.\n  if (!json_response || json_response->empty()) {\n    // log the response codes\n    base::UmaHistogramBoolean(std::string(kMarketingHistogramPrefix) +\n                                  std::string(api_name) +\n                                  std::string(kEmptyResponseBodySuffix),\n                              true);\n    error_response_parser_function(std::move(callback),\n                                   data_decoder::DataDecoder::ValueOrError());\n    return;\n  }\n\n  base::UmaHistogramBoolean(std::string(kMarketingHistogramPrefix) +\n                                std::string(api_name) +\n                                std::string(kEmptyResponseBodySuffix),\n                            false);\n\n  if (!error_response) {\n    data_decoder::DataDecoder::ParseJsonIsolated(\n        *json_response,\n        base::BindOnce(success_response_parser_function, std::move(callback)));\n  } else {\n    data_decoder::DataDecoder::ParseJsonIsolated(\n        *json_response,\n        base::BindOnce(error_response_parser_function, std::move(callback)));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs API request latency and response codes, and processes JSON response based on success or error status.","ghc_query":"log api request latency response code process json success error status"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\query_parser\\query_parser.cc:411-453","function":"QueryParser::ParseQueryImpl","codesnippet":"{\n  base::i18n::BreakIterator iter(query, base::i18n::BreakIterator::BREAK_WORD);\n  // TODO(evanm): support a locale here\n  if (!iter.Init())\n    return false;\n\n  // To handle nesting, we maintain a stack of QueryNodeLists.\n  // The last element (back) of the stack contains the current, deepest node.\n  std::vector<QueryNodeList*> query_stack;\n  query_stack.push_back(root);\n\n  bool in_quotes = false;  // whether we're currently in a quoted phrase\n  while (iter.Advance()) {\n    // Just found a span between 'prev' (inclusive) and 'pos' (exclusive). It\n    // is not necessarily a word, but could also be a sequence of punctuation\n    // or whitespace.\n    if (iter.IsWord()) {\n      auto word_node = std::make_unique<QueryNodeWord>(\n          std::u16string(iter.GetString()), matching_algorithm);\n      if (in_quotes)\n        word_node->set_literal(true);\n      query_stack.back()->AddChild(std::move(word_node));\n    } else {  // Punctuation.\n      if (IsQueryQuote(query[iter.prev()])) {\n        if (!in_quotes) {\n          std::unique_ptr<QueryNodeList> quotes_node =\n              std::make_unique<QueryNodePhrase>();\n          QueryNodeList* quotes_node_ptr = quotes_node.get();\n          query_stack.back()->AddChild(std::move(quotes_node));\n          query_stack.push_back(quotes_node_ptr);\n          in_quotes = true;\n        } else {\n          query_stack.pop_back();  // Stop adding to the quoted phrase.\n          in_quotes = false;\n        }\n      }\n    }\n  }\n\n  root->RemoveEmptySubnodes();\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Parses a query string into a structured tree of word and phrase nodes.","ghc_query":"parse query string structured tree word phrase node"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\child\\pdf_child_init.cc:53-80","function":"MaybePatchGdiGetFontData","codesnippet":"{\n#if BUILDFLAG(IS_WIN)\n  // Only patch utility processes which explicitly need GDI.\n  auto& command_line = *base::CommandLine::ForCurrentProcess();\n  auto service_sandbox_type =\n      sandbox::policy::SandboxTypeFromCommandLine(command_line);\n  bool need_gdi =\n      service_sandbox_type == sandbox::mojom::Sandbox::kPrintCompositor ||\n      service_sandbox_type == sandbox::mojom::Sandbox::kPdfConversion;\n  if (!need_gdi)\n    return;\n\n#if defined(COMPONENT_BUILD)\n  HMODULE module = ::GetModuleHandleA(\"pdfium.dll\");\n  DCHECK(module);\n#else\n  HMODULE module = CURRENT_MODULE();\n#endif  // defined(COMPONENT_BUILD)\n\n  // Need to patch GetFontData() for font loading to work correctly.\n  // TODO(crbug.com/pdfium/11): Can be removed once PDFium switches to use Skia.\n  static base::NoDestructor<base::win::IATPatchFunction> patch_get_font_data;\n  patch_get_font_data->PatchFromModule(\n      module, \"gdi32.dll\", \"GetFontData\",\n      reinterpret_cast<void*>(GetFontDataPatch));\n  g_original_get_font_data = reinterpret_cast<GetFontDataPtr>(\n      patch_get_font_data->original_function());\n#endif  // BUILDFLAG(IS_WIN)\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Patches the GetFontData function for specific Windows utility processes requiring GDI.","ghc_query":"patch getfontdata function windows utility process gdi"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\edge_wallet\\core\\browser\\wallet_checkout_trigger_funnel_manager.cc:325-354","function":"WalletCheckoutTriggerFunnelManager::SendXPayTelemetry","codesnippet":"{\n  if (!edge_xpay_telemetry_) {\n    return;\n  }\n\n  refresh_cache_ = true;\n\n  std::vector<edge_xpay::EdgeXpayTelemetry::TelemetryEntry> entries;\n\n  for (auto& record : records_) {\n    if (record.flag == FunnelRecordFlag::TOMBLE) {\n      if (record.filter != TriggerFilter::PLACE_HOLDER) {\n        edge_xpay::EdgeXpayTelemetry::TelemetryEntry entry;\n\n        entry.time_stamp = base::Time::Now();\n        entry.event_name = kWalletCheckoutTriggerFunnelEvent;\n        entry.correlation_id =\n            base::Uuid::GenerateRandomV4().AsLowercaseString();\n        base::JSONWriter::Write(std::move(record.ToBaseValue(true)),\n                                &entry.data);\n        entries.emplace_back(std::move(entry));\n      }\n\n      record.flag = FunnelRecordFlag::EMPTY;\n    }\n  }\n\n  if (!entries.empty()) {\n    edge_xpay_telemetry_->SendXpayTelemetry(kXPayScenario, entries);\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Sends telemetry data for specific records if conditions are met.","ghc_query":"send telemetry data record condition met"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\download\\offline_item_utils.cc:242-343","function":"OfflineItemUtils::GetFailStateMessage","codesnippet":"{\n  int string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS;\n\n  switch (fail_state) {\n    case FailState::FILE_ACCESS_DENIED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_ACCESS_DENIED;\n      break;\n    case FailState::FILE_NO_SPACE:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_DISK_FULL;\n      break;\n    case FailState::FILE_NAME_TOO_LONG:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_PATH_TOO_LONG;\n      break;\n    case FailState::FILE_TOO_LARGE:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_FILE_TOO_LARGE;\n      break;\n    case FailState::FILE_VIRUS_INFECTED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_VIRUS;\n      break;\n    case FailState::FILE_TRANSIENT_ERROR:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_TEMPORARY_PROBLEM;\n      break;\n    case FailState::FILE_BLOCKED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_BLOCKED;\n      break;\n    case FailState::FILE_SECURITY_CHECK_FAILED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_SECURITY_CHECK_FAILED;\n      break;\n    case FailState::FILE_TOO_SHORT:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_FILE_TOO_SHORT;\n      break;\n    case FailState::FILE_SAME_AS_SOURCE:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_FILE_SAME_AS_SOURCE;\n      break;\n    case FailState::NETWORK_INVALID_REQUEST:\n      [[fallthrough]];\n    case FailState::NETWORK_FAILED:\n      [[fallthrough]];\n    case FailState::NETWORK_INSTABILITY:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_NETWORK_ERROR;\n      break;\n    case FailState::NETWORK_TIMEOUT:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_NETWORK_TIMEOUT;\n      break;\n    case FailState::NETWORK_DISCONNECTED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_NETWORK_DISCONNECTED;\n      break;\n    case FailState::NETWORK_SERVER_DOWN:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_SERVER_DOWN;\n      break;\n    case FailState::SERVER_FAILED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_SERVER_PROBLEM;\n      break;\n    case FailState::SERVER_BAD_CONTENT:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_NO_FILE;\n      break;\n    case FailState::USER_CANCELED:\n      string_id = IDS_DOWNLOAD_STATUS_CANCELLED;\n      break;\n    case FailState::USER_SHUTDOWN:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_SHUTDOWN;\n      break;\n    case FailState::CRASH:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_CRASH;\n      break;\n    case FailState::SERVER_UNAUTHORIZED:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_UNAUTHORIZED;\n      break;\n    case FailState::SERVER_CERT_PROBLEM:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_SERVER_CERT_PROBLEM;\n      break;\n    case FailState::SERVER_FORBIDDEN:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_FORBIDDEN;\n      break;\n    case FailState::SERVER_UNREACHABLE:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_UNREACHABLE;\n      break;\n    case FailState::SERVER_CONTENT_LENGTH_MISMATCH:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_CONTENT_LENGTH_MISMATCH;\n      break;\n    case FailState::FILE_BLOCKED_BY_APPLICATION_GUARD:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS_FILE_BLOCKED_BY_APPLICATION_GUARD;\n      break;\n\n    case FailState::NO_FAILURE:\n      // We reach here if the received bytes is zero. Ideally, we should have a\n      // separate FailState outside of download interrupt reasons, and pass the\n      // bytes info to every function that invokes this.\n      [[fallthrough]];\n    case FailState::CANNOT_DOWNLOAD:\n      [[fallthrough]];\n    case FailState::SERVER_NO_RANGE:\n      [[fallthrough]];\n    case FailState::SERVER_CROSS_ORIGIN_REDIRECT:\n      [[fallthrough]];\n    case FailState::FILE_FAILED:\n      [[fallthrough]];\n    case FailState::FILE_HASH_MISMATCH:\n      string_id = IDS_DOWNLOAD_INTERRUPTED_STATUS;\n  }\n\n  return l10n_util::GetStringUTF16(string_id);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Returns a localized string describing the download interruption reason based on the failure state.","ghc_query":"localized string download interruption reason failure state"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\search_engines\\enterprise\\search_aggregator_policy_handler.cc:120-181","function":"SearchAggregatorPolicyHandler::CheckPolicySettings","codesnippet":"{\n  if (!IsPolicyEnabled() || !policies.Get(policy_name())) {\n    return true;\n  }\n\n  if (!SimpleSchemaValidatingPolicyHandler::CheckPolicySettings(policies,\n                                                                errors)) {\n    return false;\n  }\n\n  const base::Value::Dict& search_aggregator =\n      policies.GetValue(policy_name(), base::Value::Type::DICT)->GetDict();\n\n  // Shortcut validation.\n  const std::string& shortcut = *search_aggregator.FindString(kShortcut);\n  if (search_engine_fields_validators::ShortcutIsEmpty(policy_name(), shortcut,\n                                                       errors) ||\n      search_engine_fields_validators::ShortcutHasWhitespace(\n          policy_name(), shortcut, errors) ||\n      search_engine_fields_validators::ShortcutStartsWithAtSymbol(\n          policy_name(), shortcut, errors) ||\n      search_engine_fields_validators::\n          ShortcutEqualsDefaultSearchProviderKeyword(policy_name(), shortcut,\n                                                     policies, errors)) {\n    return false;\n  }\n\n  // Name validation.\n  if (search_engine_fields_validators::NameIsEmpty(\n          policy_name(), *search_aggregator.FindString(kName), errors)) {\n    return false;\n  }\n\n  // Search URL validation.\n  const std::string& search_url = *search_aggregator.FindString(kSearchUrl);\n  if (search_engine_fields_validators::UrlIsEmpty(policy_name(), search_url,\n                                                  errors) ||\n      UrlIsNotHttps(policy_name(), search_url, errors) ||\n      search_engine_fields_validators::ReplacementStringIsMissingFromUrl(\n          policy_name(), search_url, errors)) {\n    return false;\n  }\n\n  // Suggest URL validation.\n  const std::string& suggest_url = *search_aggregator.FindString(kSuggestUrl);\n  if (search_engine_fields_validators::UrlIsEmpty(policy_name(), suggest_url,\n                                                  errors) ||\n      UrlIsNotHttps(policy_name(), suggest_url, errors)) {\n    return false;\n  }\n\n  // UrlIsEmpty is not used here because icon_url is optional and so there is no\n  // need to record an error if it is empty.\n  const std::string* icon_url = search_aggregator.FindString(kIconUrl);\n  if (icon_url && !icon_url->empty() &&\n      UrlIsNotHttps(policy_name(), *icon_url, errors)) {\n    return false;\n  }\n\n  return true;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Validates search aggregator policy settings for correctness and compliance.","ghc_query":"validate search aggregator policy setting correctness compliance"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\send_tab_to_self\\send_tab_to_self_mobile_upsell_view.cc:88-136","function":"SendTabToSelfMobileUpsellView::Init","codesnippet":"{\n  SetShowCloseButton(true);\n  DialogDelegate::SetButtons(static_cast<int>(ui::mojom::DialogButton::kNone));\n\n  SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical, gfx::Insets(),\n      ChromeLayoutProvider::Get()->GetDistanceMetric(\n          views::DISTANCE_UNRELATED_CONTROL_VERTICAL)));\n\n  auto* image_view = AddChildView(std::make_unique<views::ImageView>());\n  image_view->SetImage(ui::ImageModel::FromResourceId(\n      IDR_EDGE_SEND_TAB_TO_SELF_MOBILE_UPSELL_QRCODE));\n  image_view->SetHorizontalAlignment(views::ImageView::Alignment::kCenter);\n  image_view->GetViewAccessibility().SetName(\n      l10n_util::GetStringUTF16(IDS_SEND_TAB_MOBILE_UPSELL_QRCODE_A11Y_NAME));\n\n  AddChildView(std::make_unique<views::Separator>());\n\n  auto* title_label = AddChildView(std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_SEND_TAB_MOBILE_UPSELL_HEADER_TEXT)));\n  title_label->SetFontList(title_label->font_list().Derive(\n      3, gfx::Font::FontStyle::NORMAL, gfx::Font::Weight::SEMIBOLD));\n  title_label->SetMultiLine(true);\n  title_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n\n  auto* description_label = AddChildView(std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_SEND_TAB_MOBILE_UPSELL_DESCRIPTION_TEXT)));\n  description_label->SetFontList(description_label->font_list().Derive(\n      2, gfx::Font::FontStyle::NORMAL, gfx::Font::Weight::NORMAL));\n  description_label->SetMultiLine(true);\n  description_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n\n  auto* privacy_link = AddChildView(std::make_unique<views::Link>(\n      l10n_util::GetStringUTF16(IDS_PRIVACY_LINK_TEXT)));\n  privacy_link->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  privacy_link->SetCallback(base::BindRepeating(\n      &SendTabToSelfMobileUpsellView::LinkClicked, base::Unretained(this)));\n  privacy_link->GetViewAccessibility().SetRole(ax::mojom::Role::kButton);\n\n  AddChildView(std::make_unique<views::Separator>());\n\n  cancel_button_ = AddChildView(std::make_unique<views::MdTextButton>(\n      base::BindRepeating(&SendTabToSelfMobileUpsellView::CancelButtonClicked,\n                          base::Unretained(this)),\n      l10n_util::GetStringUTF16(IDS_GOT_IT_BUTTON_TEXT)));\n  cancel_button_->SetStyle(ui::ButtonStyle::kProminent);\n  cancel_button_->GetViewAccessibility().SetRole(ax::mojom::Role::kButton);\n\n  set_fixed_width(320);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates a dialog with a QR code, descriptive text, a privacy link, and a prominent cancel button.","ghc_query":"create dialog qr code descriptive text privacy link cancel button"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\policy\\reporting\\user_session_activity\\user_session_activity_reporter.cc:129-159","function":"UserSessionActivityReporter::ActiveUserChanged","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  CHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  // Handle logins. Otherwise, if the session is inactive and the device is\n  // locked, it means we are unlocking the device in a multi-user session and we\n  // should just return and let OnUnlocked() start the session.\n  if (!IsSessionActive()) {\n    if (!is_device_locked_) {\n      OnSessionStart(SessionStartEvent_Reason_LOGIN, active_user);\n    }\n    return;\n  }\n\n  // If user A locks device in a multi-user session and user B unlocks the\n  // device, both OnUnlocked() and ActiveUserChanged() are called but we only\n  // want OnUnlocked() to handle it. If ActiveUserChanged() is called first, the\n  // above if-statement will return since the session is not active. If\n  // OnUnlocked() is called first, the session will start and `session_user_`\n  // will be set to the current active user. Then when ActiveUserChanged() is\n  // called, the below if-statement will return.\n  if (active_user == session_user_) {\n    return;\n  }\n\n  // We are switching users in multi-user mode.\n  // End session for the current user and start the session for the\n  // next user.\n  OnSessionEnd(SessionEndEvent_Reason_MULTI_USER_SWITCH, session_user_);\n  OnSessionStart(SessionStartEvent_Reason_MULTI_USER_SWITCH, active_user);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Manages user session transitions in a multi-user environment.","ghc_query":"user session transition manage multi-user environment"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\password_manager\\core\\browser\\credential_manager_pending_prevent_silent_access_task.cc:40-62","function":"CredentialManagerPendingPreventSilentAccessTask::\n    OnGetPasswordStoreResultsFrom","codesnippet":"{\n  for (const auto& form : results) {\n    if (form->match_type == PasswordForm::MatchType::kGrouped ||\n        form->blocked_by_user) {\n      continue;\n    }\n    if (!form->skip_zero_click) {\n      form->skip_zero_click = true;\n#if MICROSOFT_EDGE_BUILD\n      if (!form->blocked_by_user)\n#endif\n      {\n        store->UpdateLogin(*form);\n      }\n    }\n  }\n  pending_requests_--;\n  if (!pending_requests_) {\n    delegate_->DoneRequiringUserMediation();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates login forms to skip zero-click if not blocked by the user and decrements pending requests.","ghc_query":"update login form skip zero-click block user decrement pending request"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\web_applications\\commands\\launch_web_app_command.cc:62-211","function":"LaunchWebAppCommand::StartWithLock","codesnippet":"{\n  lock_ = std::move(lock);\n\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  bool is_preinstalled_app_launch = false;\n#if BUILDFLAG(ENABLE_PWA_WIN10_PACKAGE)\n  // Skip install check for preinstalled apps as they're installed outside of\n  // the browser and get registered with browser on launch.\n  is_preinstalled_app_launch =\n      params_.command_line.HasSwitch(edge::appxpack::kIdentityProxyFallbackUrl);\n#endif  // BUILDFLAG(ENABLE_PWA_WIN10_PACKAGE)\n  if (!lock_->registrar().IsInstallState(\n          params_.app_id,\n          {web_app::proto::InstallState::SUGGESTED_FROM_ANOTHER_DEVICE,\n           web_app::proto::InstallState::INSTALLED_WITH_OS_INTEGRATION,\n           web_app::proto::InstallState::INSTALLED_WITHOUT_OS_INTEGRATION}) &&\n      !is_preinstalled_app_launch) {\n#else\n  if (!lock_->registrar().IsInRegistrar(params_.app_id)) {\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    GetMutableDebugValue().Set(\"error\", \"not_installed\");\n    CompleteAndSelfDestruct(CommandResult::kFailure, nullptr, nullptr,\n                            apps::LaunchContainer::kLaunchContainerNone);\n    return;\n  }\n\n#if !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  const WebApp* current_app = lock_->registrar().GetAppById(params_.app_id);\n  CHECK(current_app);\n\n  bool is_standalone_launch =\n      params_.container == apps::LaunchContainer::kLaunchContainerWindow ||\n      (launch_setting_ ==\n           LaunchWebAppWindowSetting::kOverrideWithWebAppConfig &&\n       current_app->user_display_mode() != mojom::UserDisplayMode::kBrowser);\n#else\n  const WebApp* current_app = lock_->registrar().GetAppById(params_.app_id);\n  CHECK(current_app || is_preinstalled_app_launch);\n  // Preinstalled apps which are not registred with the browser yet default to\n  // standalone user display mode.\n  mojom::UserDisplayMode app_user_display_mode =\n      mojom::UserDisplayMode::kStandalone;\n  if (current_app) {\n    app_user_display_mode = current_app->user_display_mode();\n  }\n  bool is_standalone_launch =\n      params_.container == apps::LaunchContainer::kLaunchContainerWindow ||\n      (launch_setting_ ==\n           LaunchWebAppWindowSetting::kOverrideWithWebAppConfig &&\n       app_user_display_mode != mojom::UserDisplayMode::kBrowser);\n#endif  // !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n\n  GetMutableDebugValue().Set(\"is_standalone_launch\", is_standalone_launch);\n  if (is_standalone_launch) {\n    // Launching an app in a standalone windows requires OS integration, and the\n    // only way this is supported in tests is to use the\n    // OsIntegrationTestOverride functionality.\n    CHECK_OS_INTEGRATION_ALLOWED();\n  }\n\n  bool needs_os_integration_sync = false;\n\n  // Upgrade to fully installed if needed.\n  if (is_standalone_launch &&\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      !is_preinstalled_app_launch &&\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      lock_->registrar().GetInstallState(params_.app_id) !=\n          proto::INSTALLED_WITH_OS_INTEGRATION) {\n    ScopedRegistryUpdate update = lock_->sync_bridge().BeginUpdate();\n    update->UpdateApp(params_.app_id)\n        ->SetInstallState(proto::INSTALLED_WITH_OS_INTEGRATION);\n    needs_os_integration_sync = true;\n  }\n\n  std::optional<proto::os_state::WebAppOsIntegration> os_integration =\n      lock_->registrar().GetAppCurrentOsIntegrationState(params_.app_id);\n#if EXCLUDED_FROM_EDGE\n  CHECK(os_integration);\n#else\n  CHECK(is_preinstalled_app_launch || os_integration);\n  needs_os_integration_sync = !is_preinstalled_app_launch &&\n                                   !os_integration->has_shortcut() &&\n                                   is_standalone_launch;\n#endif  // EXCLUDED_FROM_EDGE\n  GetMutableDebugValue().Set(\"needs_os_integration_sync\",\n                             needs_os_integration_sync);\n\n  base::ConcurrentClosures completion;\n\n  if (needs_os_integration_sync) {\n    // TODO(crbug.com/339451551): Remove adding to desktop on linux after the\n    // OsIntegrationTestOverride can use the xdg install command to detect\n    // install.\n    SynchronizeOsOptions options;\n#if BUILDFLAG(IS_LINUX)\n    options.add_shortcut_to_desktop = true;\n#endif\n    lock_->os_integration_manager().Synchronize(\n        params_.app_id,\n        base::BindOnce(&LaunchWebAppCommand::OnOsIntegrationSynchronized,\n                       weak_factory_.GetWeakPtr())\n            .Then(completion.CreateClosure()),\n        options);\n  }\n\n  // Note: In tests this can synchronously call FirstRunServiceCompleted and\n  // self-destruct. So take the weak pointer first.\n  base::WeakPtr<LaunchWebAppCommand> weak_ptr = weak_factory_.GetWeakPtr();\n  provider_->ui_manager().WaitForFirstRunService(\n      *profile_, base::BindOnce(&LaunchWebAppCommand::FirstRunServiceCompleted,\n                                weak_factory_.GetWeakPtr())\n                     .Then(completion.CreateClosure()));\n\n  std::move(completion)\n      .Done(base::BindOnce(&LaunchWebAppCommand::DoLaunch, weak_ptr));\n}\n\nvoid LaunchWebAppCommand::FirstRunServiceCompleted(bool success) {\n  GetMutableDebugValue().Set(\"first_run_success\", success);\n  if (!success) {\n    CompleteAndSelfDestruct(CommandResult::kFailure, nullptr, nullptr,\n                            apps::LaunchContainer::kLaunchContainerNone);\n    return;\n  }\n}\n\nvoid LaunchWebAppCommand::OnOsIntegrationSynchronized() {\n  GetMutableDebugValue().Set(\"os_integration_synchronized\", true);\n}\n\nvoid LaunchWebAppCommand::DoLaunch() {\n  provider_->ui_manager().LaunchWebApp(\n      std::move(params_), launch_setting_, *profile_,\n      base::BindOnce(&LaunchWebAppCommand::OnAppLaunched,\n                     weak_factory_.GetWeakPtr()),\n      *lock_);\n}\n\nvoid LaunchWebAppCommand::OnAppLaunched(\n    base::WeakPtr<Browser> browser,\n    base::WeakPtr<content::WebContents> web_contents,\n    apps::LaunchContainer container,\n    base::Value debug_value) {\n  GetMutableDebugValue().Set(\"launch_web_app_debug_value\",\n                             std::move(debug_value));\n  CompleteAndSelfDestruct(CommandResult::kSuccess, std::move(browser),\n                          std::move(web_contents), container);\n}\n\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Launches a web application, ensuring necessary installation and OS integration checks are performed.","ghc_query":"launch web application ensure install os integration check"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\endpoint_fetcher\\endpoint_fetcher.cc:244-306","function":"EndpointFetcher::PerformRequest","codesnippet":"{\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->method = GetHttpMethodString(request_params_.http_method());\n  resource_request->url = request_params_.url();\n  resource_request->credentials_mode = GetCredentialsMode();\n  if (GetSetSiteForCookies()) {\n    resource_request->site_for_cookies =\n        net::SiteForCookies::FromUrl(request_params_.url());\n  }\n\n  if (request_params_.http_method() == HttpMethod::kPost) {\n    resource_request->headers.SetHeader(kContentTypeKey,\n                                        request_params_.content_type());\n  }\n  for (const auto& header : request_params_.headers()) {\n    resource_request->headers.SetHeader(header.key, header.value);\n  }\n  for (const auto& cors_exempt_headers :\n       request_params_.cors_exempt_headers()) {\n    resource_request->cors_exempt_headers.SetHeaderIfMissing(\n        cors_exempt_headers.key, cors_exempt_headers.value);\n  }\n  switch (request_params_.auth_type()) {\n    case OAUTH:\n      resource_request->headers.SetHeader(\n          kDeveloperKey, GaiaUrls::GetInstance()->oauth2_chrome_client_id());\n      resource_request->headers.SetHeader(\n          net::HttpRequestHeaders::kAuthorization,\n          base::StringPrintf(\"Bearer %s\", key));\n      break;\n    case CHROME_API_KEY: {\n      google_apis::AddDefaultAPIKeyToRequest(*resource_request, channel_);\n      break;\n    }\n    default:\n      break;\n  }\n  // TODO(crbug.com/40641804) Make simple_url_loader_ local variable passed to\n  // callback\n  simple_url_loader_ = network::SimpleURLLoader::Create(\n      std::move(resource_request), request_params_.annotation_tag());\n\n  if (request_params_.http_method() == HttpMethod::kPost) {\n    simple_url_loader_->AttachStringForUpload(\n        request_params_.post_data().value(), request_params_.content_type());\n  }\n  if (!GetUploadProgressCallback().is_null()) {\n    simple_url_loader_->SetOnUploadProgressCallback(\n        GetUploadProgressCallback());\n  }\n  simple_url_loader_->SetRetryOptions(GetMaxRetries(),\n                                      network::SimpleURLLoader::RETRY_ON_5XX);\n  simple_url_loader_->SetTimeoutDuration(request_params_.timeout());\n  simple_url_loader_->SetAllowHttpErrorResults(true);\n  network::SimpleURLLoader::BodyAsStringCallbackDeprecated\n      body_as_string_callback = base::BindOnce(\n          &EndpointFetcher::OnResponseFetched, weak_ptr_factory_.GetWeakPtr(),\n          std::move(endpoint_fetcher_callback));\n  simple_url_loader_->DownloadToString(\n      url_loader_factory_.get(), std::move(body_as_string_callback),\n      network::SimpleURLLoader::kMaxBoundedStringDownloadSize);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and configures a network request using specified parameters and initiates its download.","ghc_query":"create configure network request parameter download initiate"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\sync_sessions\\synced_session.cc:208-233","function":"SyncColorToTabGroupColor","codesnippet":"{\n  switch (sync_color) {\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_UNSPECIFIED:\n      return tab_groups::TabGroupColorId::kGrey;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_GREY:\n      return tab_groups::TabGroupColorId::kGrey;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_BLUE:\n      return tab_groups::TabGroupColorId::kBlue;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_RED:\n      return tab_groups::TabGroupColorId::kRed;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_YELLOW:\n      return tab_groups::TabGroupColorId::kYellow;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_GREEN:\n      return tab_groups::TabGroupColorId::kGreen;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_PINK:\n      return tab_groups::TabGroupColorId::kPink;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_PURPLE:\n      return tab_groups::TabGroupColorId::kPurple;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_CYAN:\n      return tab_groups::TabGroupColorId::kCyan;\n    case sync_pb::SessionTabGroupVisualData::TAB_GROUP_COLOR_ORANGE:\n      return tab_groups::TabGroupColorId::kOrange;\n  }\n\n  NOTREACHED() << \"No known conversion for the supplied color.\";\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Maps sync color values to corresponding tab group color IDs.","ghc_query":"sync color value map tab group id"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\performance_manager\\execution_context_priority\\override_vote_aggregator.cc:88-114","function":"OverrideVoteAggregator::OnVoteInvalidated","codesnippet":"{\n  // The VoteData for this execution context is guaranteed to exist.\n  auto it = GetVoteData(execution_context);\n  VoteData& vote_data = it->second;\n\n  // Remember the previous chosen vote before removing the vote for this\n  // |voter_id|.\n  const Vote old_chosen_vote = vote_data.GetChosenVote();\n\n  vote_data.RemoveVote(GetVoterType(voter_id));\n\n  // In case the last vote for |execution_context| was invalidated, the upstream\n  // vote must also be invalidated.\n  if (!vote_data.HasChosenVote()) {\n    channel_.InvalidateVote(execution_context);\n\n    // Clean up the VoteData for |execution_context| since it is empty.\n    vote_data_map_.erase(it);\n    return;\n  }\n\n  // If the top vote changed, the upstream vote must also be changed.\n  const Vote new_chosen_vote = vote_data.GetChosenVote();\n  if (old_chosen_vote != new_chosen_vote)\n    channel_.ChangeVote(execution_context, new_chosen_vote);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates or invalidates the vote for a given execution context based on changes in voter data.","ghc_query":"vote update invalidate execution context voter data change"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_themes\\ai_themes\\edge_ai_themes_handler.cc:210-247","function":"EdgeAiThemesHandler::DownloadImageAndExtractColors","codesnippet":"{\n  net::NetworkTrafficAnnotationTag kTrafficAnnotation =\n      net::DefineNetworkTrafficAnnotation(\"edge_ai_themes_image_fetcher\",\n                                          R\"(\n      semantics {\n        sender: \"Edge AI Themes\"\n        description:\n          \"This request Fetches the image from an image url.\"\n        trigger:\n          \"When the user creates an ai theme using prompt.\"\n        data:\n          \"URL of the image to be fetched.\"\n        destination: OTHER\n        internal {\n          contacts {\n            email: \"edgethemesenggteam@microsoft.com\"\n          }\n        }\n        user_data {\n          type: NONE\n        }\n        last_reviewed: \"2025-02-12\"\n      }\n      policy {\n        cookies_allowed: NO\n        setting:\n          \"This feature cannot be disabled by settings.\"\n        policy_exception_justification: \"Not implemented\"\n      })\");\n\n  image_fetcher_->FetchImage(\n      image_url,\n      base::BindOnce(&EdgeAiThemesHandler::OnImageDownloaded,\n                     weak_ptr_factory_.GetWeakPtr(), std::move(callback),\n                     image_url),\n      image_fetcher::ImageFetcherParams(kTrafficAnnotation, \"EdgeAiThemes\"));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Fetches an image from a specified URL for AI theme creation.","ghc_query":"fetch image url ai theme creation"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\storage_monitor\\storage_monitor_linux.cc:99-163","function":"GetDeviceInfo","codesnippet":"{\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n  DCHECK(!device_path.empty());\n\n  std::unique_ptr<StorageInfo> storage_info;\n\n  device::ScopedUdevPtr udev_obj(device::udev_new());\n  if (!udev_obj.get())\n    return storage_info;\n\n  struct stat device_stat;\n  if (stat(device_path.value().c_str(), &device_stat) < 0)\n    return storage_info;\n\n  char device_type;\n  if (S_ISCHR(device_stat.st_mode))\n    device_type = 'c';\n  else if (S_ISBLK(device_stat.st_mode))\n    device_type = 'b';\n  else\n    return storage_info;  // Not a supported type.\n\n  device::ScopedUdevDevicePtr device(\n      device::udev_device_new_from_devnum(udev_obj.get(), device_type,\n                                          device_stat.st_rdev));\n  if (!device.get())\n    return storage_info;\n\n  std::u16string volume_label = base::UTF8ToUTF16(\n      device::UdevDeviceGetPropertyValue(device.get(), kLabel));\n  std::u16string vendor_name = base::UTF8ToUTF16(\n      device::UdevDeviceGetPropertyValue(device.get(), kVendor));\n  std::u16string model_name = base::UTF8ToUTF16(\n      device::UdevDeviceGetPropertyValue(device.get(), kModel));\n\n  std::string unique_id = MakeDeviceUniqueId(device.get());\n  const char* value =\n      device::udev_device_get_sysattr_value(device.get(), kRemovableSysAttr);\n  if (!value) {\n    // |parent_device| is owned by |device| and does not need to be cleaned\n    // up.\n    struct udev_device* parent_device =\n        device::udev_device_get_parent_with_subsystem_devtype(\n            device.get(),\n            kBlockSubsystemKey,\n            kDiskDeviceTypeKey);\n    value = device::udev_device_get_sysattr_value(parent_device,\n                                                  kRemovableSysAttr);\n  }\n  const bool is_removable = (value && atoi(value) == 1);\n\n  StorageInfo::Type type = StorageInfo::FIXED_MASS_STORAGE;\n  if (is_removable) {\n    type = MediaStorageUtil::HasDcim(mount_point)\n               ? StorageInfo::REMOVABLE_MASS_STORAGE_WITH_DCIM\n               : StorageInfo::REMOVABLE_MASS_STORAGE_NO_DCIM;\n  }\n\n  storage_info = std::make_unique<StorageInfo>(\n      StorageInfo::MakeDeviceId(type, unique_id), mount_point.value(),\n      volume_label, vendor_name, model_name,\n      GetDeviceStorageSize(device_path, device.get()));\n  return storage_info;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Retrieves and returns storage device information.","ghc_query":"storage device information retrieve return data"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\metrics\\call_stacks\\stack_sampling_recorder.cc:68-109","function":"StackSamplingRecorder::WriteFileHelper","codesnippet":"{\n  // Build up the protobuf we want to write before locking the file, to\n  // minimize the time spent holding the lock.\n  auto process_thread_count_map = GetSuccessfullyCollectedCounts();\n  stack_sampled_metrics_status::StackSampledMetricsStatus status;\n\n  for (const auto& [process, thread_count_map] : process_thread_count_map) {\n    auto& thread_count_map_proto =\n        (*status.mutable_process_type_to_thread_count_map())[process];\n    thread_count_map_proto.mutable_thread_type_to_success_count()->insert(\n        thread_count_map.begin(), thread_count_map.end());\n  }\n\n  // Don't use the open flags that truncate the file; we can't truncate until\n  // the lock succeeds.\n  base::File file(file_path_,\n                  base::File::FLAG_OPEN_ALWAYS | base::File::FLAG_WRITE);\n\n  if (!file.IsValid()) {\n    LOG(ERROR) << \"Failed to open \" << file_path_ << \": \"\n               << base::File::ErrorToString(file.error_details());\n    return;\n  }\n\n  // Use flock instead of File::Lock; File::Lock doesn't allow\n  // block-until-locked.\n  if (HANDLE_EINTR(flock(file.GetPlatformFile(), LOCK_EX)) != 0) {\n    PLOG(ERROR) << \"Unable to lock \" << file_path_ << \": \";\n    return;\n  }\n\n  // We don't need to unlock the file explicitly; it will always unlock when\n  // we destruct |file|.\n  if (!file.SetLength(0)) {\n    LOG(ERROR) << \"Unable to truncate \" << file_path_;\n    return;\n  }\n\n  if (!status.SerializeToFileDescriptor(file.GetPlatformFile())) {\n    LOG(ERROR) << \"Unable to write to \" << file_path_;\n    return;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Writes collected thread count metrics to a file with locking.","ghc_query":"write thread count metrics file lock"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\segmentation_platform\\internal\\selection\\segment_result_provider.cc:150-216","function":"SegmentResultProviderImpl::OnGotModelScore","codesnippet":"{\n  if (db_result && db_result->rank.has_value()) {\n    PostResultCallback(std::move(request_state), std::move(db_result));\n    return;\n  }\n\n  // If previously the `fallback_action` was server model, that means\n  // that the server model will be running this time, and if that fails to\n  // provide the result, the fallback to this would be eithier getting score for\n  // default model from database or executing default models based on\n  // `ignore_db_scores`.\n  if (fallback_action == FallbackAction::kExecuteServerModel) {\n    FallbackAction new_fallback_action =\n        request_state->options->ignore_db_scores\n            ? FallbackAction::kExecuteDefaultModel\n            : FallbackAction::kGetResultFromDatabaseForDefaultModel;\n    auto db_score_callback =\n        base::BindOnce(&SegmentResultProviderImpl::OnGotModelScore,\n                       weak_ptr_factory_.GetWeakPtr(), new_fallback_action);\n    VLOG(1) << __func__ << \": segment=\"\n            << SegmentId_Name(request_state->options->segment_id)\n            << \" failed to get score from database, executing server model.\";\n    ExecuteModelAndGetScore(std::move(request_state),\n                            ModelSource::SERVER_MODEL_SOURCE,\n                            std::move(db_score_callback));\n    return;\n  }\n\n  // Handling default models.\n  ModelProvider* default_model =\n      GetModelProvider(execution_service_, request_state->options->segment_id,\n                       ModelSource::DEFAULT_MODEL_SOURCE);\n  if (!default_model || !default_model->ModelAvailable()) {\n    VLOG(1) << __func__ << \": segment=\"\n            << SegmentId_Name(request_state->options->segment_id)\n            << \" default provider not available\";\n    // Make sure the metrics record state of database model failure when client\n    // did not provide a default model.\n    PostResultCallback(std::move(request_state),\n                       std::make_unique<SegmentResult>(db_result->state));\n    return;\n  }\n\n  if (fallback_action ==\n      FallbackAction::kGetResultFromDatabaseForDefaultModel) {\n    auto db_score_callback = base::BindOnce(\n        &SegmentResultProviderImpl::OnGotModelScore,\n        weak_ptr_factory_.GetWeakPtr(), FallbackAction::kExecuteDefaultModel);\n    VLOG(1) << __func__ << \": segment=\"\n            << SegmentId_Name(request_state->options->segment_id)\n            << \" failed to get score from executing server model, getting \"\n               \"score from default model from db.\";\n    GetCachedModelScore(std::move(request_state),\n                        ModelSource::DEFAULT_MODEL_SOURCE,\n                        std::move(db_score_callback));\n    return;\n  }\n  VLOG(1) << __func__\n          << \": segment=\" << SegmentId_Name(request_state->options->segment_id)\n          << \" failed to get database model score, trying default model.\";\n  ExecuteModelAndGetScore(\n      std::move(request_state), ModelSource::DEFAULT_MODEL_SOURCE,\n      base::BindOnce(&SegmentResultProviderImpl::PostResultCallback,\n                     weak_ptr_factory_.GetWeakPtr()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines and executes the appropriate model based on fallback actions and database results.","ghc_query":"determine execute appropriate model fallback action database result"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_visual_companion\\thumbnail_video_capturer.cc:48-84","function":"ThumbnailVideoCapturer::Start","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  if (video_capturer_ || !web_contents_) {\n    return;\n  }\n\n  content::RenderWidgetHostView* const source_view =\n      web_contents_->GetPrimaryMainFrame()\n          ->GetRenderViewHost()\n          ->GetWidget()\n          ->GetView();\n  if (!source_view) {\n    return;\n  }\n\n  current_concurrent_capture_count_ = 0;\n  const gfx::Size source_size = source_view->GetViewBounds().size();\n  const gfx::Size target_size = gfx::Size(resolution_, resolution_);\n  const float width_ratio =\n      static_cast<float>(target_size.width()) / source_size.width();\n  const float height_ratio =\n      static_cast<float>(target_size.height()) / source_size.height();\n  const float scale_factor = std::min(width_ratio, height_ratio);\n  const gfx::Size scaled_size =\n      gfx::ScaleToCeiledSize(source_size, scale_factor);\n\n  constexpr int kMaxFrameRate = 2;\n  last_screenshot_crc_ = 0;\n  video_capturer_ = source_view->CreateVideoCapturer();\n  video_capturer_->SetResolutionConstraints(scaled_size, scaled_size, false);\n  video_capturer_->SetAutoThrottlingEnabled(false);\n  video_capturer_->SetMinSizeChangePeriod(base::TimeDelta());\n  video_capturer_->SetFormat(media::PIXEL_FORMAT_ARGB);\n  video_capturer_->SetMinCapturePeriod(base::Seconds(1) / kMaxFrameRate);\n  video_capturer_->Start(this, viz::mojom::BufferFormatPreference::kDefault);\n  last_url_ = url;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and starts a video capturer for a web content view with specified resolution constraints.","ghc_query":"video capturer initialize start web content view resolution constraint"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\reporting\\util\\file.cc:107-131","function":"AppendLine","codesnippet":"{\n  base::File file(file_path,\n                  base::File::FLAG_OPEN_ALWAYS | base::File::FLAG_APPEND);\n  if (!file.IsValid()) {\n    base::UmaHistogramEnumeration(reporting::kUmaDataLossErrorReason,\n                                  DataLossErrorReason::FAILED_TO_OPEN_FILE,\n                                  DataLossErrorReason::MAX_VALUE);\n    return Status(error::NOT_FOUND,\n                  base::StrCat({\"Could not open health data file \",\n                                file_path.MaybeAsASCII()}));\n  }\n\n  const std::string line = base::StrCat({data, \"\\n\"});\n  const int write_count = UNSAFE_TODO(file.Write(0, line.data(), line.size()));\n  if (write_count < 0 || static_cast<size_t>(write_count) < line.size()) {\n    base::UmaHistogramEnumeration(reporting::kUmaDataLossErrorReason,\n                                  DataLossErrorReason::FAILED_TO_WRITE_FILE,\n                                  DataLossErrorReason::MAX_VALUE);\n    return Status(error::DATA_LOSS,\n                  base::StrCat({\"Failed to write health data file \",\n                                file_path.MaybeAsASCII(), \" write count=\",\n                                base::NumberToString(write_count)}));\n  }\n  return Status::StatusOK();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Appends data to a file and logs errors if the operation fails.","ghc_query":"append data file log error operation fail"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\history_clusters\\core\\history_clusters_service.cc:100-142","function":"HistoryClustersService::HistoryClustersService","codesnippet":"{\n  if (prefs && is_journeys_feature_flag_enabled_) {\n    // Log whether the user has Journeys enabled if they are eligible for it.\n    base::UmaHistogramBoolean(\n        \"History.Clusters.JourneysEligibleAndEnabledAtSessionStart\",\n        prefs->GetBoolean(prefs::kVisible));\n  }\n\n  if (!is_journeys_feature_flag_enabled_) {\n    return;\n  }\n\n  // The remaining pieces are only needed for Journeys, so don't instantiate\n  // them if Journeys is not enabled.\n\n  if (history_service_) {\n    history_service_observation_.Observe(history_service);\n  }\n\n  context_clusterer_observer_ =\n      std::make_unique<ContextClustererHistoryServiceObserver>(\n          history_service, template_url_service, optimization_guide_decider,\n          engagement_score_provider);\n\n  backend_ = FileClusteringBackend::CreateIfEnabled();\n  if (!backend_) {\n    backend_ = std::make_unique<OnDeviceClusteringBackend>(\n        engagement_score_provider, optimization_guide_decider);\n  }\n\n  LoadCachesFromPrefs();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and configures components related to the Journeys feature if it is enabled.","ghc_query":"journey journeys feature initialize configure component enable"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\dom_distiller\\content\\browser\\edge_dom_distiller_viewer_source.cc:547-583","function":"DomDistillerViewerSource::RequestViewerHandle::GetReadingViewTriggerSource","codesnippet":"{\n  ReadingViewTelemetryHelper::ReadingViewTriggerSource trigger_source =\n      ReadingViewTelemetryHelper::ReadingViewTriggerSource::kUnknown;\n  if (original_page_data_) {\n    // if |original_page_data_| exists, use the trigger source from it.\n    trigger_source = original_page_data_->GetReadingViewTriggerSource();\n  } else {\n    // This is straight navigation. The trigger source can be figured from\n    // |navigation_handle|.\n    ui::PageTransition page_transition = navigation_handle->GetPageTransition();\n    if (PageTransitionGetQualifier(page_transition) &\n        ui::PageTransition::PAGE_TRANSITION_FROM_ADDRESS_BAR) {\n      trigger_source =\n          ReadingViewTelemetryHelper::ReadingViewTriggerSource::kAddressBar;\n    } else if (PageTransitionGetQualifier(page_transition) &\n               ui::PageTransition::PAGE_TRANSITION_FORWARD_BACK) {\n      // This is currently not working correctly. forward and back\n      // navigations have |PAGE_TRANSITION_FROM_ADDRESS_BAR| PageTransition.\n      // instead for unknown reason. Investigate needed here.\n      // https://microsoft.visualstudio.com/Edge/_workitems/edit/31817721\n      trigger_source = ReadingViewTelemetryHelper::ReadingViewTriggerSource::\n          kForwardBackNavigation;\n    } else if (ui::PageTransitionCoreTypeIs(\n                   page_transition,\n                   ui::PageTransition::PAGE_TRANSITION_RELOAD)) {\n      trigger_source =\n          ReadingViewTelemetryHelper::ReadingViewTriggerSource::kReload;\n    } else if (ui::PageTransitionCoreTypeIs(\n                   page_transition,\n                   ui::PageTransition::PAGE_TRANSITION_AUTO_BOOKMARK)) {\n      trigger_source =\n          ReadingViewTelemetryHelper::ReadingViewTriggerSource::kBookmark;\n    }\n  }\n  return trigger_source;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Determines the reading view trigger source based on page data or navigation handle.","ghc_query":"reading view trigger source determine page data navigation handle"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\installer\\util\\registry_entry.cc:84-107","function":"RegistryEntry::StatusInRegistryUnderRoot","codesnippet":"{\n  base::win::RegKey key(root, key_path_.c_str(), KEY_QUERY_VALUE);\n  bool found = false;\n  bool correct_value = false;\n  if (is_string_) {\n    std::wstring read_value;\n    found = key.ReadValue(name_.c_str(), &read_value) == ERROR_SUCCESS;\n    if (found) {\n      correct_value =\n          read_value.size() == value_.size() &&\n          ::CompareString(\n              LOCALE_USER_DEFAULT, NORM_IGNORECASE, read_value.data(),\n              base::saturated_cast<int>(read_value.size()), value_.data(),\n              base::saturated_cast<int>(value_.size())) == CSTR_EQUAL;\n    }\n  } else {\n    DWORD read_value;\n    found = key.ReadValueDW(name_.c_str(), &read_value) == ERROR_SUCCESS;\n    if (found)\n      correct_value = read_value == int_value_;\n  }\n  return found ? (correct_value ? SAME_VALUE : DIFFERENT_VALUE)\n               : DOES_NOT_EXIST;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Checks if a registry key value matches a specified value and returns the comparison result.","ghc_query":"registry key value check compare match return result"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\optimization_guide\\core\\prediction_model_store.cc:294-332","function":"PredictionModelStore::LoadAndVerifyModelInBackgroundThread","codesnippet":"{\n  auto model_info = ParseModelInfoFromFile(\n      base_model_dir.Append(GetBaseFileNameForModelInfo()));\n  if (!model_info) {\n    return nullptr;\n  }\n  DCHECK_EQ(optimization_target, model_info->optimization_target());\n  // Make sure the model file, the full modelinfo file and all additional\n  // files still exist.\n  auto file_paths_to_check = GetModelFilePaths(*model_info, base_model_dir);\n  if (!CheckAllPathsExist(file_paths_to_check)) {\n    return nullptr;\n  }\n  std::unique_ptr<proto::PredictionModel> model =\n      std::make_unique<proto::PredictionModel>();\n  *model->mutable_model_info() = *model_info;\n#if !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  model->mutable_model()->set_download_url(\n      FilePathToString(base_model_dir.Append(GetBaseFileNameForModels())));\n#else\n  model->mutable_model()->set_download_url(\n      FilePathToString(base_model_dir.Append(\n          GetBaseFileNameForModels(model_info->optimization_target()))));\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n\n  // Convert the additional files to absolute paths.\n  model->mutable_model_info()->clear_additional_files();\n  for (const auto& additional_file : model_info->additional_files()) {\n    auto additional_filepath = StringToFilePath(additional_file.file_path());\n    if (!additional_filepath->IsAbsolute()) {\n      additional_filepath = base_model_dir.Append(*additional_filepath);\n    }\n    model->mutable_model_info()->add_additional_files()->set_file_path(\n        FilePathToString(*additional_filepath));\n  }\n  return model;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Creates and returns a prediction model with verified file paths and model information.","ghc_query":"create return prediction model verify file path information"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\arc\\screen_capture\\arc_screen_capture_session.cc:369-416","function":"ArcScreenCaptureSession::OnAnimationStep","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  CompositorAnimationObserver::ResetIfActive();\n  if (texture_queue_.size() >= kQueueSizeToForceUpdate) {\n    DVLOG(3) << \"AnimationStep callback forcing update due to texture queue \"\n                \"size \"\n             << texture_queue_.size();\n    notifier_->ForceUpdate();\n  }\n  if (texture_queue_.size() >= kQueueSizeToDropFrames) {\n    DVLOG(3) << \"AnimationStep callback dropping frame due to texture queue \"\n                \"size \"\n             << texture_queue_.size();\n    return;\n  }\n\n  ui::Layer* layer = display_root_window_->layer();\n  if (!layer) {\n    LOG(ERROR) << \"Unable to find layer for the desktop window\";\n    return;\n  }\n\n  // TODO(kylechar): Ideally this would add `BlitRequest` to `request` so\n  // readback happens directly into the final texture rather than making\n  // an extra copy in CopyDesktopTextureToGpuBuffer().\n  std::unique_ptr<viz::CopyOutputRequest> request =\n      std::make_unique<viz::CopyOutputRequest>(\n          viz::CopyOutputRequest::ResultFormat::RGBA,\n          viz::CopyOutputRequest::ResultDestination::kNativeTextures,\n          base::BindOnce(&ArcScreenCaptureSession::OnDesktopCaptured,\n                         weak_ptr_factory_.GetWeakPtr()));\n  // Clip the requested area to the desktop area. See b/118675936.\n  gfx::Size desktop_size = display_root_window_->bounds().size();\n  request->set_area(gfx::Rect(desktop_size));\n\n  // Unconditionally set the scaling ratio, even if the two sizes are identical.\n  // What may be identical here may not be identical further down when the scale\n  // is transformed for the surface. Note that desktop_size is is not in\n  // physical pixels, and a scale factor is applied to adjust to them.\n  request->SetScaleRatio(\n      gfx::Vector2d(desktop_size.width(), desktop_size.height()),\n      gfx::Vector2d(size_.width(), size_.height()));\n\n  // Ensure we get the result size we want, and not +/- one pixel due to\n  // clamping or rounding.\n  request->set_result_selection(gfx::Rect(size_));\n\n  layer->RequestCopyOfOutput(std::move(request));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Captures and processes a desktop window's texture for animation updates.","ghc_query":"capture process desktop window texture animation update"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\account_manager\\account_apps_availability.cc:291-317","function":"AccountAppsAvailability::OnRefreshTokenUpdatedForAccount","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  if (!IsInitialized()) {\n    // Using base::Unretained(this) is fine because `initialization_callbacks_`\n    // is owned by this.\n    initialization_callbacks_.push_back(base::BindOnce(\n        &AccountAppsAvailability::OnRefreshTokenUpdatedForAccount,\n        base::Unretained(this), account_info));\n    return;\n  }\n\n  std::optional<bool> current_status =\n      IsAccountAvailableInArc(prefs_, account_info.gaia);\n  // - If `current_status.has_value()` is `false` - this account is not in prefs\n  // yet. This happens when account is just added and\n  // `SetIsAccountAvailableInArc()` wasn't called yet.\n  // - If `current_status.value()` is `false` - this account is not available in\n  // ARC. In this case we don't want to notify the observers.\n  if (!current_status.has_value() || !current_status.value())\n    return;\n\n  FindAccountByGaiaId(\n      account_info.gaia,\n      base::BindOnce(&AccountAppsAvailability::MaybeNotifyObservers,\n                     weak_factory_.GetWeakPtr(),\n                     /*is_available_in_arc=*/true));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles account initialization and notifies observers if the account is available in ARC.","ghc_query":"account initialization arc observer notify available"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\password_manager\\core\\browser\\logins_edge_extended_table.cc:231-262","function":"LoginsEdgeExtendedTable::PasswordsResetContinuousImportSource","codesnippet":"{\n  DCHECK(db_);\n  base::TimeTicks start_time = base::TimeTicks::Now();\n  int updated_count = 0;\n  sql::Statement s(\n      db_->GetCachedStatement(SQL_FROM_HERE,\n                              \"UPDATE logins_edge_extended SET source = ? \"\n                              \"WHERE source = ?\"));\n  s.BindInt(0,\n            static_cast<int>(edge_continuous_migration::SourceOfData::ANAHEIM));\n  s.BindInt(\n      1,\n      static_cast<int>(\n          edge_continuous_migration::SourceOfData::CONTINUOUS_IMPORT_CHROME));\n  if (!s.Run()) {\n    TRACE_EVENT2(\n        \"password_manager\",\n        \"LoginsEdgeExtendedTable::PasswordsResetContinuousImportSource\",\n        \"error_code\", db_->GetErrorCode(), \"error_message\",\n        db_->GetErrorMessage());\n    LogError(LoginsEdgeExtendedTableError::kBulkUpdateFailed);\n    return false;\n  } else {\n    updated_count = db_->GetLastChangeCount();\n    base::UmaHistogramCounts10000(\n        \"Microsoft.ContinuousMigration.SourceReset.Count.Passwords\",\n        updated_count);\n    base::UmaHistogramTimes(\n        \"Microsoft.ContinuousMigration.SourceReset.Perf.Passwords\",\n        base::TimeTicks::Now() - start_time);\n    return true;\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Updates the source field in the logins_edge_extended table and logs the operation's result.","ghc_query":"update source field logins_edge_extended table log operation result"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\holding_space\\holding_space_persistence_delegate.cc:97-137","function":"HoldingSpacePersistenceDelegate::OnHoldingSpaceItemUpdated","codesnippet":"{\n  if (is_restoring_persistence()) {\n    return;\n  }\n\n  // Only finalized items are persisted.\n  if (!item->progress().IsComplete()) {\n    return;\n  }\n\n  // Attempt to find the finalized `item` in persistent storage.\n  ScopedListPrefUpdate update(profile()->GetPrefs(), kPersistencePath);\n  base::Value::List& list = update.Get();\n  auto item_it = std::ranges::find(\n      list, item->id(), [](const base::Value& persisted_item) {\n        return HoldingSpaceItem::DeserializeId(persisted_item.GetDict());\n      });\n\n  // If the finalized `item` already exists in persistent storage, update it.\n  if (item_it != list.end()) {\n    *item_it = base::Value(item->Serialize());\n    return;\n  }\n\n  // If the finalized `item` did not previously exist in persistent storage,\n  // insert it at the appropriate index.\n  item_it = list.begin();\n  for (const auto& candidate_item : model()->items()) {\n    if (candidate_item.get() == item) {\n      list.Insert(item_it, base::Value(item->Serialize()));\n      return;\n    }\n    if (candidate_item->progress().IsComplete()) {\n      ++item_it;\n    }\n  }\n\n  // The finalized `item` should exist in the model and be handled above.\n  NOTREACHED();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Persists finalized items to storage if not already present.","ghc_query":"persist finalize item storage check exist present"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\updater\\external_constants_builder.cc:246-295","function":"ExternalConstantsBuilder::Modify","codesnippet":"{\n  scoped_refptr<ExternalConstantsOverrider> verifier =\n      ExternalConstantsOverrider::FromDefaultJSONFile(\n          CreateDefaultExternalConstants());\n  if (!verifier) {\n    return Overwrite();\n  }\n\n  if (!overrides_.contains(kDevOverrideKeyUrl)) {\n    SetUpdateURL(StringVectorFromGURLVector(verifier->UpdateURL()));\n  }\n  if (!overrides_.contains(kDevOverrideKeyCrashUploadUrl)) {\n    SetCrashUploadURL(verifier->CrashUploadURL().possibly_invalid_spec());\n  }\n  if (!overrides_.contains(kDevOverrideKeyDeviceManagementUrl)) {\n    SetDeviceManagementURL(\n        verifier->DeviceManagementURL().possibly_invalid_spec());\n  }\n  if (!overrides_.contains(kDevOverrideKeyAppLogoUrl)) {\n    SetAppLogoURL(verifier->AppLogoURL().possibly_invalid_spec());\n  }\n  if (!overrides_.contains(kDevOverrideKeyUseCUP)) {\n    SetUseCUP(verifier->UseCUP());\n  }\n  if (!overrides_.contains(kDevOverrideKeyInitialDelay)) {\n    SetInitialDelay(verifier->InitialDelay());\n  }\n  if (!overrides_.contains(kDevOverrideKeyServerKeepAliveSeconds)) {\n    SetServerKeepAliveTime(verifier->ServerKeepAliveTime());\n  }\n  if (!overrides_.contains(kDevOverrideKeyCrxVerifierFormat)) {\n    SetCrxVerifierFormat(verifier->CrxVerifierFormat());\n  }\n  if (!overrides_.contains(kDevOverrideKeyDictPolicies)) {\n    SetDictPolicies(verifier->DictPolicies());\n  }\n  if (!overrides_.contains(kDevOverrideKeyOverinstallTimeout)) {\n    SetOverinstallTimeout(verifier->OverinstallTimeout());\n  }\n  if (!overrides_.contains(kDevOverrideKeyIdleCheckPeriodSeconds)) {\n    SetIdleCheckPeriod(verifier->IdleCheckPeriod());\n  }\n  if (!overrides_.contains(kDevOverrideKeyManagedDevice)) {\n    SetMachineManaged(verifier->IsMachineManaged());\n  }\n  if (!overrides_.contains(kDevOverrideKeyCecaConnectionTimeout)) {\n    SetCecaConnectionTimeout(verifier->CecaConnectionTimeout());\n  }\n\n  return Overwrite();\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Applies default configuration values if not overridden.","ghc_query":"default configuration value apply override"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\desks_storage\\core\\desk_sync_bridge.cc:298-325","function":"DeskSyncBridge::GetEntryByUUID","codesnippet":"{\n  if (!IsReady()) {\n    LOG(WARNING) << \"Unable to get entry by UUID: Not Ready\";\n    return GetEntryByUuidResult(GetEntryByUuidStatus::kFailure, nullptr);\n  }\n\n  if (!uuid.is_valid()) {\n    LOG(WARNING) << \"Unable to get entry by UUID: Invalid UUID\";\n    return GetEntryByUuidResult(GetEntryByUuidStatus::kInvalidUuid, nullptr);\n  }\n\n  auto it = desk_template_entries_.find(uuid);\n  if (it == desk_template_entries_.end()) {\n    std::unique_ptr<DeskTemplate> policy_entry =\n        GetAdminDeskTemplateByUUID(uuid);\n\n    if (policy_entry) {\n      return GetEntryByUuidResult(GetEntryByUuidStatus::kOk,\n                                  std::move(policy_entry));\n    } else {\n      LOG(WARNING) << \"Unable to get entry by UUID: Entry not found\";\n      return GetEntryByUuidResult(GetEntryByUuidStatus::kNotFound, nullptr);\n    }\n  } else {\n    return GetEntryByUuidResult(GetEntryByUuidStatus::kOk,\n                                it->second.get()->Clone());\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Retrieves a desk template entry by UUID, handling readiness and validity checks.","ghc_query":"desk template entry retrieve uuid ready valid check"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\policy\\chrome_policy_conversions_client.cc:118-180","function":"ChromePolicyConversionsClient::GetExtensionPolicies","codesnippet":"{\n  Value::List policies;\n\n#if defined(EXCLUDED_FROM_EDGE)\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n\n  const bool for_signin_screen =\n      policy_domain == POLICY_DOMAIN_SIGNIN_EXTENSIONS;\n#if BUILDFLAG(IS_CHROMEOS)\n  Profile* extension_profile = for_signin_screen\n                                   ? ash::ProfileHelper::GetSigninProfile()\n                                   : profile_.get();\n#else   // BUILDFLAG(IS_CHROMEOS)\n  Profile* extension_profile = profile_;\n#endif  // BUILDFLAG(IS_CHROMEOS)\n\n  const extensions::ExtensionRegistry* registry =\n      extensions::ExtensionRegistry::Get(extension_profile);\n  if (!registry) {\n    LOG_POLICY(ERROR, POLICY_PROCESSING)\n        << \"Cannot dump extension policies, no extension registry\";\n    return policies;\n  }\n  auto* schema_registry_service =\n      extension_profile->GetOriginalProfile()->GetPolicySchemaRegistryService();\n  if (!schema_registry_service || !schema_registry_service->registry()) {\n    LOG_POLICY(ERROR, POLICY_PROCESSING)\n        << \"Cannot dump extension policies, no schema registry service\";\n    return policies;\n  }\n  const scoped_refptr<SchemaMap> schema_map =\n      schema_registry_service->registry()->schema_map();\n  const extensions::ExtensionSet extension_set =\n      registry->GenerateInstalledExtensionsSet();\n  for (const auto& extension : extension_set) {\n    // Skip this extension if it's not an enterprise extension.\n    if (!extension->manifest()->FindPath(\n            extensions::manifest_keys::kStorageManagedSchema)) {\n      continue;\n    }\n\n    PolicyNamespace policy_namespace =\n        PolicyNamespace(policy_domain, extension->id());\n    PolicyErrorMap empty_error_map;\n    Value::Dict extension_policies =\n        GetPolicyValues(extension_profile->GetProfilePolicyConnector()\n                            ->policy_service()\n                            ->GetPolicies(policy_namespace),\n                        &empty_error_map, PoliciesSet(), PoliciesSet(),\n                        ObsoletePoliciesSet(),\n                        GetKnownPolicies(schema_map, policy_namespace));\n    Value::Dict extension_policies_data;\n    extension_policies_data.Set(policy::kNameKey, extension->name());\n    extension_policies_data.Set(policy::kIdKey, extension->id());\n    extension_policies_data.Set(\"forSigninScreen\", for_signin_screen);\n    extension_policies_data.Set(policy::kPoliciesKey,\n                                std::move(extension_policies));\n    policies.Append(std::move(extension_policies_data));\n  }\n#endif\n#endif  // defined(EXCLUDED_FROM_EDGE)\n  return policies;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates a list of policies for installed enterprise extensions.","ghc_query":"enterprise extension policy list generate installed"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\signin\\public\\identity_manager\\identity_manager_builder.cc:101-204","function":"BuildIdentityManagerInitParameters","codesnippet":"{\n  std::unique_ptr<AccountTrackerService> account_tracker_service =\n      std::move(params->account_tracker_service);\n  if (!account_tracker_service) {\n    account_tracker_service =\n        BuildAccountTrackerService(params->pref_service, params->profile_path);\n  }\n\n  std::unique_ptr<ProfileOAuth2TokenService> token_service =\n      std::move(params->token_service);\n  if (!token_service) {\n    token_service = BuildProfileOAuth2TokenService(\n        params->pref_service, account_tracker_service.get(),\n        params->network_connection_tracker, params->account_consistency,\n#if BUILDFLAG(IS_CHROMEOS)\n        params->account_manager_facade, params->is_regular_profile,\n#endif  // BUILDFLAG(IS_CHROMEOS)\n#if BUILDFLAG(ENABLE_DICE_SUPPORT)\n        params->delete_signin_cookies_on_exit, params->token_web_data,\n#if BUILDFLAG(ENABLE_BOUND_SESSION_CREDENTIALS)\n        params->unexportable_key_service,\n#endif  // BUILDFLAG(ENABLE_BOUND_SESSION_CREDENTIALS)\n#endif  // BUILDFLAG(ENABLE_DICE_SUPPORT)\n#if BUILDFLAG(IS_IOS)\n        std::move(params->device_accounts_provider),\n#endif\n#if BUILDFLAG(IS_WIN)\n        params->reauth_callback,\n#endif\n        params->signin_client);\n  }\n\n  auto gaia_cookie_manager_service = std::make_unique<GaiaCookieManagerService>(\n      account_tracker_service.get(), token_service.get(),\n      params->signin_client);\n\n  std::unique_ptr<PrimaryAccountManager> primary_account_manager =\n      BuildPrimaryAccountManager(params->signin_client,\n                                 account_tracker_service.get(),\n                                 token_service.get());\n\n  IdentityManager::InitParameters init_params;\n\n  init_params.primary_account_mutator =\n      std::make_unique<PrimaryAccountMutatorImpl>(\n          account_tracker_service.get(), primary_account_manager.get(),\n          params->pref_service, params->signin_client);\n\n  init_params.accounts_mutator =\n      BuildAccountsMutator(params->pref_service, account_tracker_service.get(),\n                           token_service.get(), primary_account_manager.get());\n\n  init_params.accounts_cookie_mutator =\n      std::make_unique<AccountsCookieMutatorImpl>(\n          params->signin_client, token_service.get(),\n          gaia_cookie_manager_service.get(), account_tracker_service.get());\n\n  init_params.diagnostics_provider = std::make_unique<DiagnosticsProviderImpl>(\n      token_service.get(), gaia_cookie_manager_service.get());\n\n  std::unique_ptr<AccountCapabilitiesFetcherFactory>\n      account_capabilities_fetcher_factory;\n#if BUILDFLAG(IS_ANDROID)\n  account_capabilities_fetcher_factory =\n      std::make_unique<AccountCapabilitiesFetcherFactoryAndroid>();\n#else\n  // Default to server-based lookups if platform-specific capabilities fetcher\n  // is not defined.\n  if (params->account_capabilities_fetcher_factory) {\n    account_capabilities_fetcher_factory =\n        std::move(params->account_capabilities_fetcher_factory);\n  } else {\n    account_capabilities_fetcher_factory =\n        std::make_unique<AccountCapabilitiesFetcherFactoryGaia>(\n            token_service.get(), params->signin_client);\n  }\n#endif  // BULIDFLAG(IS_ANDROID)\n\n  init_params.account_fetcher_service = BuildAccountFetcherService(\n      params->signin_client, token_service.get(), account_tracker_service.get(),\n      std::move(params->image_decoder),\n      std::move(account_capabilities_fetcher_factory));\n\n#if BUILDFLAG(IS_IOS) || BUILDFLAG(IS_ANDROID)\n  init_params.device_accounts_synchronizer =\n      std::make_unique<DeviceAccountsSynchronizerImpl>(\n          token_service->GetDelegate());\n#endif\n\n  init_params.account_tracker_service = std::move(account_tracker_service);\n  init_params.gaia_cookie_manager_service =\n      std::move(gaia_cookie_manager_service);\n  init_params.primary_account_manager = std::move(primary_account_manager);\n  init_params.token_service = std::move(token_service);\n  init_params.account_consistency = params->account_consistency;\n  init_params.signin_client = params->signin_client;\n#if BUILDFLAG(IS_CHROMEOS)\n  init_params.account_manager_facade = params->account_manager_facade;\n#endif\n  init_params.require_sync_consent_for_scope_verification =\n      params->require_sync_consent_for_scope_verification;\n\n  return init_params;\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Initializes and returns identity manager parameters with account and token services.","ghc_query":"identity manager parameters initialize account token service"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\metrics\\usage_scenario\\chrome_responsiveness_calculator_delegate.cc:103-133","function":"ChromeResponsivenessCalculatorDelegate::OnResponsivenessEmitted","codesnippet":"{\n  CHECK(interval_scenario_params_);\n  base::UmaHistogramCustomCounts(\n      base::StrCat({\"Browser.MainThreadsCongestion\",\n                    interval_scenario_params_->histogram_suffix}),\n      num_congested_slices, min, exclusive_max, buckets);\n\n  if (IsChromeUsedInScenario(interval_scenario_params_->scenario)) {\n    base::UmaHistogramCustomCounts(\"Browser.MainThreadsCongestion.Used\",\n                                   num_congested_slices, min, exclusive_max,\n                                   buckets);\n  }\n  if (extensions_with_content_scripts_in_interval_.has_value()) {\n    base::UmaHistogramCustomCounts(\n        base::StrCat(\n            {\"Browser.MainThreadsCongestion.ExtensionContentScripts.\",\n             GetSuffixForExtensionCount(\n                 extensions_with_content_scripts_in_interval_.value())}),\n        num_congested_slices, min, exclusive_max, buckets);\n  }\n#if BUILDFLAG(IS_CHROMEOS)\n  if (IsLowMemory()) {\n    base::UmaHistogramCustomCounts(\"Browser.MainThreadsCongestion.LowMemory\",\n                                   num_congested_slices, min, exclusive_max,\n                                   buckets);\n  }\n#endif  // BUILDFLAG(IS_CHROMEOS)\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Logs congestion metrics for browser main threads under various scenarios.","ghc_query":"congestion metrics log browser main thread performance scenario"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\views\\autofill\\edge_popup\\popup_main_view_v2.cc:590-722","function":"PopupMainViewV2::CreateChildViews","codesnippet":"{\n  // Null all pointers prior to deleting the children views to avoid temporarily\n  // dangling pointers that might be picked up by dangle detection builds.\n  scroll_view_ = nullptr;\n  row_views_.clear();\n  body_container_ = nullptr;\n  footer_view_ = nullptr;\n  header_view_ = nullptr;\n\n  RemoveAllChildViews();\n  SetBackground(edge_props_.CreateThemedBackground());\n\n  // `content_view` wraps the full content of the popup and provides vertical\n  // padding.\n  raw_ptr<views::BoxLayoutView> content_view =\n      AddChildView(views::Builder<views::BoxLayoutView>()\n                       .SetOrientation(views::BoxLayout::Orientation::kVertical)\n                       .SetInsideBorderInsets(gfx::Insets::VH(0, 0))\n                       .Build());\n\n  const std::vector<Suggestion> suggestions = controller_->GetSuggestions();\n  if (suggestions.empty()) {\n    return;\n  }\n  const std::set<autofill::SuggestionType> suggestion_types_set =\n      ExtractSuggestionTypesPresent(suggestions);\n\n  // Create and add header with dismiss button.\n  if (!IsPureDataList(suggestion_types_set)) {\n    header_view_ =\n        content_view->AddChildView(std::make_unique<EdgePopupHeaderView>(\n            controller_, suggestion_types_set));\n  } else {\n    header_view_ = nullptr;\n  }\n\n  // Create rows from suggestions\n  row_views_.reserve(suggestions.size());\n  // Add the body rows, if there are any.\n  gfx::Insets popup_body_container_insets =\n      GetLayoutInsets(EDGE_AUTOFILL_POPUP_V2_CONTAINER_INSETS);\n  if (suggestions.size() > kMaxSuggestionsWithoutScroll &&\n      !IsFooterSuggestionType(suggestions[kMaxSuggestionsWithoutScroll].type)) {\n    // Remove the inset if scroll bar is visible.\n    popup_body_container_insets =\n        GetLayoutInsets(EDGE_AUTOFILL_POPUP_V2_CONTAINER_WITH_SCROLL_INSETS);\n  }\n\n  auto body_container =\n      views::Builder<views::BoxLayoutView>()\n          .SetOrientation(views::BoxLayout::Orientation::kVertical)\n          .SetInsideBorderInsets(popup_body_container_insets)\n          .Build();\n  size_t line_no;\n  for (line_no = 0u; line_no < suggestions.size(); line_no++) {\n    if (IsFooterSuggestionType(suggestions[line_no].type) ||\n        suggestions[line_no].type ==\n            SuggestionType::kWebauthnSignInWithAnotherDevice) {\n      break;\n    }\n    std::unique_ptr<EdgePopupRowView> new_row =\n        CreatePopupRowView(*this, controller_, line_no, suggestion_types_set);\n    // CreatePopupRowView may return nullptr in case the suggestion on this line\n    // is not supported for Popup V2. We should NOT fill row_views vector with\n    // null pointers.\n    if (new_row != nullptr) {\n      raw_ptr<EdgePopupRowView> row_view =\n          body_container->AddChildView(std::move(new_row));\n      row_views_.push_back(row_view);\n    }\n\n    auto datalist_separator_view =\n        CreateDatalistSeparatorIfNeeded(line_no, suggestions);\n    if (datalist_separator_view) {\n      body_container->AddChildView(std::move(datalist_separator_view));\n    }\n  }\n\n  auto scroll_view = std::make_unique<views::ScrollView>();\n  scroll_view->SetHorizontalScrollBarMode(\n      views::ScrollView::ScrollBarMode::kHiddenButEnabled);\n  scroll_view->SetBorder(\n      views::CreateEmptyBorder(gfx::Insets::TLBR(0, 1, 0, 1)));\n  body_container_ = scroll_view->SetContents(std::move(body_container));\n  scroll_view->SetDrawOverflowIndicator(false);\n  scroll_view->ClipHeightTo(0, kPopupScrollBarClipHeight);\n  scroll_view->SetHideBackground(edge_props_.use_acrylic());\n  scroll_view_ = content_view->AddChildView(std::move(scroll_view));\n  auto vertical_scroll = std::make_unique<views::ScrollBarViews>(\n      views::ScrollBar::Orientation::kVertical, true, true);\n  scroll_view_->SetVerticalScrollBar(std::move(vertical_scroll));\n  content_view->SetFlexForView(scroll_view_, 1);\n\n  // Create separator\n  std::unique_ptr<views::Separator> separator_view =\n      views::Builder<views::Separator>()\n          .SetBorder(views::CreateEmptyBorder(gfx::Insets::TLBR(4, 0, 0, 0)))\n          .Build();\n  if (line_no < suggestions.size()) {\n    separator_view->SetColorId(ui::kColorEdgePopupSeparator);\n  } else {\n    separator_view->SetColorId(edge_props_.border_color_id());\n  }\n  content_view->AddChildView(std::move(separator_view));\n\n  // Create footer\n  footer_view_ =\n      AddChildView(views::Builder<views::BoxLayoutView>()\n                       .SetOrientation(views::BoxLayout::Orientation::kVertical)\n                       .SetInsideBorderInsets(gfx::Insets::VH(0, 0))\n                       .Build());\n  while (line_no < suggestions.size()) {\n    // For selection to look consistent, need a container for the footer similar\n    // to the one for suggestion rows. The right inset of this container should\n    // match the left one.\n    const gfx::Insets footer_container_insets =\n        (line_no < suggestions.size() - 1)\n            ? GetLayoutInsets(EDGE_AUTOFILL_POPUP_V2_FOOTER_CONTAINER_INSETS)\n            : GetLayoutInsets(\n                  EDGE_AUTOFILL_POPUP_V2_LAST_FOOTER_CONTAINER_INSETS);\n    auto footer_container =\n        views::Builder<views::BoxLayoutView>()\n            .SetOrientation(views::BoxLayout::Orientation::kVertical)\n            .SetInsideBorderInsets(footer_container_insets)\n            .Build();\n    raw_ptr<EdgePopupRowView> row_view = footer_container->AddChildView(\n        CreatePopupRowView(*this, controller_, line_no, suggestion_types_set));\n    footer_view_->AddChildView(std::move(footer_container));\n\n    row_views_.push_back(row_view);\n    line_no++;\n  }\n  content_view->AddChildView(footer_view_);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Constructs and displays a popup with header, body, and footer views based on suggestion data.","ghc_query":"popup construct display header body footer view suggestion data"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\services\\edge_continuity\\continuity_file_writer.cc:165-238","function":"ContinuityFileWriter::AsyncWrite","codesnippet":"{\n  if (state_ != FileWriterState::Ready) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  if (file_payload.buffer().length() == 0) {\n    std::move(callback).Run(true);\n    return;\n  }\n\n  if (file_payload.slice_size() != file_payload.buffer().length()) {\n    LOG(ERROR) << \"file_payload.slice_size() != file_payload.buffer().length()\";\n    std::move(callback).Run(false);\n    return;\n  }\n  if (file_payload.file_size() != file_size_) {\n    LOG(ERROR) << \"file_payload.file_size() != file_size_\";\n    std::move(callback).Run(false);\n    return;\n  }\n\n  // Drop the message if the file_offset is less than written_size_\n  if (file_payload.file_offset() < written_size_) {\n    LOG(ERROR) << \"message.file_offset() < written_size_\";\n    std::move(callback).Run(false);\n    return;\n  }\n\n  // Push message to cache_messages_queue_\n  // We may not receive file_slices in order, so we need to cache the messages\n  auto task =\n      std::make_unique<MessageWriteTask>(file_payload, std::move(callback));\n  if (cache_messages_queue_.size() <= PARALLEL_REQUEST_NUM_MAX) {\n    cache_messages_queue_.push(std::move(task));\n  }\n\n  // try to consume and write the message to file\n  while (!cache_messages_queue_.empty()) {\n    if (cache_messages_queue_.top()->file_payload.file_offset() ==\n        written_size_) {\n      auto span = base::as_byte_span(\n          cache_messages_queue_.top()->file_payload.buffer());\n      int r = owned_file_.WriteAtCurrentPos(span).value_or(0);\n      if (r > 0) {\n        written_size_ += r;\n        if (written_size_ == file_size_) {\n          state_ = FileWriterState::Finished;\n        }\n        if (cache_messages_queue_.top()->callback) {\n          std::move(cache_messages_queue_.top()->callback).Run(true);\n        }\n\n      } else {\n        state_ = FileWriterState::Failed;\n        if (cache_messages_queue_.top()->callback) {\n          std::move(cache_messages_queue_.top()->callback).Run(false);\n        }\n      }\n      cache_messages_queue_.pop();\n    } else {\n      break;\n    }\n  }\n\n  if (written_size_ == file_size_) {\n    owned_file_.Flush();\n    owned_file_.Unlock();\n    // Lock file with shared mode to allow malware scanning\n    owned_file_.Lock(base::File::LockMode::kShared);\n  } else {\n    PendMoreFileSlice();\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles file writing operations with validation, caching, and completion checks.","ghc_query":"file write operation validation cache completion check"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\navigation_interception\\intercept_navigation_delegate.cc:140-176","function":"InterceptNavigationDelegate::MaybeCreateAndAdd","codesnippet":"{\n  // Navigations in a subframe or non-primary frame tree should not be\n  // intercepted. As examples of a non-primary frame tree, a navigation\n  // occurring in a Portal element or an unactivated prerendering page should\n  // not launch an app.\n  // TODO(bokan): This is a bit of a stopgap approach since we won't run\n  // throttles again when the prerender is activated which means links that are\n  // prerendered will avoid launching an app intent that a regular navigation\n  // would have. Longer term we'll want prerender activation to check for app\n  // intents, or have this throttle cancel the prerender if an intent would\n  // have been launched (without launching the intent). It's also not clear\n  // what the right behavior for <portal> elements is.\n  // https://crbug.com/1227659.\n  if (!registry.GetNavigationHandle().IsInPrimaryMainFrame()) {\n    return;\n  }\n\n  InterceptNavigationDelegate* intercept_navigation_delegate =\n      InterceptNavigationDelegate::Get(\n          registry.GetNavigationHandle().GetWebContents());\n\n  if (!intercept_navigation_delegate) {\n    registry.AddThrottle(std::make_unique<InterceptNavigationThrottle>(\n        registry, base::BindRepeating(&AllowNavigationToProceed), mode,\n        base::DoNothing()));\n  } else {\n  registry.AddThrottle(std::make_unique<InterceptNavigationThrottle>(\n      registry,\n      base::BindRepeating(&InterceptNavigationDelegate::ShouldIgnoreNavigation,\n                          base::Unretained(intercept_navigation_delegate)),\n      mode,\n      base::BindRepeating(\n          &InterceptNavigationDelegate::RequestFinishPendingShouldIgnoreCheck,\n          base::Unretained(intercept_navigation_delegate))));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Intercepts and potentially modifies navigation behavior based on frame context and delegate presence.","ghc_query":"navigation intercept modify behavior frame context delegate"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\privacy\\page_data_provider_privacy_interest_groups.cc:91-196","function":"PrivacyInterestGroupsPageDataProvider::BuildInterestGroupTable","codesnippet":"{\n  table_utils::Table table;\n  bool has_content = interest_groups_table_row_->info.has_value();\n  table.WithAriaLabel(\n      GetResourceString(IDS_SETTINGS_PRIVACY_INTEREST_GROUP_TITLE));\n  table.WithHeader(\n      table_utils::Row()\n          .AppendCell(table_utils::Cell(table_utils::CellType::Text)\n                          .WithText(GetResourceString(\n                              IDS_SETTINGS_PRIVACY_INTEREST_GROUP_TITLE)))\n          .AppendCell(\n              table_utils::Cell(table_utils::CellType::Button)\n                  .AppendButton(\n                      \"\",\n                      GetResourceString(\n                          IDS_SETTINGS_PRIVACY_INTEREST_GROUP_DELETE_ALL_BUTTON),\n                      mojom::Appearance::Default,\n                      mojom::FormControlIds::InterestGroupsDeleteAllButton,\n                      mojom::ButtonType::ActionButton,\n                      mojom::ActionType::InterestGroups, /* info= */ \"\", \"\",\n                      /*passThrough*/ std::nullopt,\n                      GetResourceString(\n                          IDS_SETTINGS_PRIVACY_INTEREST_GROUP_DELETE_ALL_BUTTON_ACC_TEXT)))  // added own action type.\n  );\n\n  if (!display_entries_.empty()) {\n    for (auto& entry : display_entries_) {\n      if (!entry.is_dict()) {\n        continue;\n      }\n      const auto& dictionary = entry.GetDict();\n\n      const std::string* owner = dictionary.FindString(\"owner\");\n      if (!owner) {\n        continue;\n      }\n\n      table_utils::Row ownerRow(\"owner-row\", *owner);\n      if (interest_groups_expanded_.at(*owner)) {\n        table.AppendRow(\n            ownerRow\n                .AppendCell(table_utils::Cell(table_utils::CellType::Text)\n                                .WithText(*owner))\n                .AppendCell(\n                    table_utils::Cell(table_utils::CellType::Button)\n                        .AppendButton(\n                            \"upArrowIcon\", \"\", mojom::Appearance::Subtle,\n                            mojom::FormControlIds::AdSelectionVisibilityToggle,\n                            mojom::ButtonType::ActionButton,\n                            mojom::ActionType::Command, /* info= */ \"\", \"\",\n                            *owner)));\n      } else {\n        table.AppendRow(\n            ownerRow\n                .AppendCell(table_utils::Cell(table_utils::CellType::Text)\n                                .WithText(*owner))\n                .AppendCell(\n                    table_utils::Cell(table_utils::CellType::Button)\n                        .AppendButton(\n                            \"downArrowIcon\", \"\", mojom::Appearance::Subtle,\n                            mojom::FormControlIds::AdSelectionVisibilityToggle,\n                            mojom::ButtonType::ActionButton,\n                            mojom::ActionType::Command, /* info= */ \"\", \"\",\n                            *owner)));\n      }\n      // onclick needs to change the action and re render the page, with the\n      // children now showing and then the parent showing a different icon. Need\n      // a list of showing parents?\n      const base::Value::List* interestGroups =\n          dictionary.FindList(\"interestGroups\");\n      if (interestGroups && interest_groups_expanded_.at(*owner)) {\n        for (const auto& iGroup : *interestGroups) {\n          if (iGroup.is_string()) {\n            table_utils::Row row(\"interest-groups-subrow\", iGroup.GetString());\n            row.AppendCell(table_utils::Cell(table_utils::CellType::Text)\n                               .WithText(iGroup.GetString()));\n            std::string pass_through = *owner + \" \" + iGroup.GetString();\n            row.AppendCell(\n                table_utils::Cell(table_utils::CellType::Button)\n                    .AppendButton(\n                        \"deleteIcon\", \"\", mojom::Appearance::Subtle,\n                        mojom::FormControlIds::InterestGroupsDeleteButton,\n                        mojom::ButtonType::ActionButton,\n                        mojom::ActionType::InterestGroups, /* info= */ *owner,\n                        iGroup.GetString(), pass_through));\n            table.AppendRow(row);\n          }\n        }\n      }\n    }\n  } else {\n    table.AppendRow(\n        table_utils::Row(\"no-interest-groups\", \"\")\n            .AppendCell(\n                table_utils::Cell(table_utils::CellType::Text)\n                    .WithText(\n                        \"\",\n                        GetResourceString(\n                            IDS_SETTINGS_PRIVACY_INTEREST_GROUP_NO_GROUPS))));\n  }\n  interest_groups_table_row_->info = table.ToString();\n\n  // avoid emitting before table is loaded on first load + causes crash.\n  if (has_content) {\n    EmitPageDataChangedToAllWebUI(base::Value(static_cast<int>(id())));\n  }\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Generates and updates a table displaying interest groups with options to expand, collapse, and delete entries.","ghc_query":"interest group table display generate update expand collapse delete entries"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ui\\ash\\system_web_apps\\system_web_app_ui_utils.cc:179-227","function":"LaunchSystemWebAppAsync","codesnippet":"{\n  DCHECK(profile);\n  // Terminal should be launched with crostini::LaunchTerminal*.\n  DCHECK(type != SystemWebAppType::TERMINAL);\n  // Callback is only supported when launching with an URL.\n  DCHECK(!callback || params.url.has_value());\n\n  // TODO(crbug.com/40723875): Implement a confirmation dialog when\n  // changing to a different profile.\n  Profile* profile_for_launch = GetProfileForSystemWebAppLaunch(profile);\n  if (profile_for_launch == nullptr) {\n    // We can't find a suitable profile to launch. Complain about this so we\n    // can identify the call site, and ask them to pick the right profile.\n    // Note that this is fatal in developer builds.\n    DUMP_WILL_BE_NOTREACHED()\n        << \"LaunchSystemWebAppAsync is called on a profile that can't launch \"\n           \"system web apps. The launch request is ignored. Please check the \"\n           \"profile you are using is correct.\";\n\n    // Early return if we can't find a profile to launch.\n    return;\n  }\n\n  if (type == SystemWebAppType::PERSONALIZATION &&\n      profile_for_launch == profile) {\n    scalable_iph::ScalableIph* scalable_iph =\n        ScalableIphFactory::GetForBrowserContext(profile_for_launch);\n    if (scalable_iph) {\n      scalable_iph->RecordEvent(\n          scalable_iph::ScalableIph::Event::kOpenPersonalizationApp);\n    }\n  }\n\n  SystemWebAppManager* manager = SystemWebAppManager::Get(profile_for_launch);\n  if (!manager) {\n    return;\n  }\n\n  // Wait for all SWAs to be registered before continuing.\n  manager->on_apps_synchronized().Post(\n      FROM_HERE,\n      base::BindOnce(&LaunchSystemWebAppAsyncContinue, profile_for_launch, type,\n                     params, std::move(window_info),\n                     callback.has_value() ? std::move(callback.value())\n                                          : base::DoNothing()));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Asynchronously launches a system web app if a suitable profile is found.","ghc_query":"system web app launch async profile suitable"},{"filePath":"D:\\project\\chromium-src-snapshot\\chrome\\browser\\ash\\arc\\tts\\arc_tts_service.cc:83-117","function":"ArcTtsService::OnTtsEvent","codesnippet":"{\n  if (!tts_controller_) {\n    // GetInstance() returns a base::Singleton<> object which always outlives\n    // |this| object.\n    tts_controller_ = content::TtsController::GetInstance();\n    if (!tts_controller_) {\n      LOG(WARNING) << \"TtsController is not available.\";\n      return;\n    }\n  }\n\n  content::TtsEventType chrome_event_type;\n  switch (event_type) {\n    case mojom::TtsEventType::START:\n      chrome_event_type = content::TTS_EVENT_START;\n      break;\n    case mojom::TtsEventType::END:\n      chrome_event_type = content::TTS_EVENT_END;\n      break;\n    case mojom::TtsEventType::INTERRUPTED:\n      chrome_event_type = content::TTS_EVENT_INTERRUPTED;\n      break;\n    case mojom::TtsEventType::ERROR:\n      chrome_event_type = content::TTS_EVENT_ERROR;\n      break;\n    case mojom::TtsEventType::WORD:\n      chrome_event_type = content::TTS_EVENT_WORD;\n      TtsPlatformImplChromeOs::GetInstance()->ReceivedWordEvent();\n  }\n  tts_controller_->OnTtsEvent(id, chrome_event_type, char_index, length,\n                              error_msg);\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Handles text-to-speech events by mapping and forwarding them to the TTS controller.","ghc_query":"text-to-speech tts controller event handle forward map"},{"filePath":"D:\\project\\chromium-src-snapshot\\components\\desks_storage\\core\\fake_desk_sync_bridge.cc:76-112","function":"FakeDeskSyncBridge::AddOrUpdateEntry","codesnippet":"{\n  if (!IsReady()) {\n    // This sync bridge has not finished initializing. Do not save the new entry\n    // yet.\n    std::move(callback).Run(AddOrUpdateEntryStatus::kFailure,\n                            std::move(new_entry));\n    return;\n  }\n\n  if (!new_entry) {\n    std::move(callback).Run(AddOrUpdateEntryStatus::kInvalidArgument,\n                            std::move(new_entry));\n    return;\n  }\n\n  base::Uuid uuid = new_entry->uuid();\n  if (!uuid.is_valid()) {\n    std::move(callback).Run(AddOrUpdateEntryStatus::kInvalidArgument,\n                            std::move(new_entry));\n    return;\n  }\n  std::vector<raw_ptr<const ash::DeskTemplate, VectorExperimental>>\n      added_or_updated;\n  // When a user creates a desk template locally, the desk template has `kUser`\n  // as its source. Only user desk templates should be saved to Sync.\n  DCHECK_EQ(ash::DeskTemplateSource::kUser, new_entry->source());\n  auto entry = new_entry->Clone();\n\n  entry->set_template_name(\n      base::CollapseWhitespace(new_entry->template_name(), true));\n\n  desk_template_entries_[uuid] = std::move(entry);\n  added_or_updated.push_back(GetUserEntryByUUID(uuid));\n  NotifyRemoteDeskTemplateAddedOrUpdated(added_or_updated);\n  std::move(callback).Run(AddOrUpdateEntryStatus::kOk, std::move(new_entry));\n}","filepos":-1,"pos":-1,"timecost":0,"filemrr":0,"summary":"Adds or updates a desk template entry if valid and initialized.","ghc_query":"desk template entry add update validate initialize"}];
        
        
        // Create table
        const tableContainer = document.getElementById('table-container');
        let tableHTML = '<table><thead><tr><th>File Path</th><th>Function</th><th>Summarize by GPT-4o</th><!--th>GHC Query</th--><th>Code Snippet</th></tr></thead><tbody>';
        dataset.forEach(item => {
            tableHTML += `<tr>
                <td title="${item.filePath}"><div class="cell-content">${item.filePath}</div></td>
                <td title="${item.function}"><div class="cell-content">${item.function}</div></td>
                <td title="Click to expand"><div class="cell-content">${item.summary}</div></td>
                <!--td title="${item.ghc_query || ''}"><div class="cell-content">${item.ghc_query || ''}</div></td-->
                <td title="Click to expand" class="code-snippet-cell"><div class="cell-content">${item.codesnippet}</div></td>
            </tr>`;
        });
        tableHTML += '</tbody></table>';
        tableContainer.innerHTML = tableHTML;

        // Add click event listener to table cells
        document.querySelectorAll('#table-container td').forEach(cell => {
            const cellContent = cell.querySelector('.cell-content');
            // Add expand indicator if content is truncated
            if (cellContent.scrollHeight > cellContent.clientHeight) {
                cell.setAttribute('title', 'Click to expand/collapse');
                cell.style.position = 'relative';
            }
            
            cell.addEventListener('click', () => {
                cellContent.classList.toggle('expanded');
            });
        });

        // Extract labels (simplified file paths) and position values
        const labels = dataset.map((item, index) => `Item ${index + 1}`);
        const posValues = dataset.map(item => item.pos);
        const fileposValues = dataset.map(item => item.filepos);
        const timecostValues = dataset.map(item => item.timecost); // Extract timecost values
        const filemrrValues = dataset.map(item => item.filemrr); // Extract filemrr values

        // Calculate percentage of pos >= 0
        const fileCount = fileposValues.filter(filepos => filepos >= 0).length;
        const posCount = posValues.filter(pos => pos >= 0).length;
        const totalCount = posValues.length;
        const fileRate = totalCount > 0 ? (fileCount / totalCount * 100).toFixed(2) : 0;
        const posRate = totalCount > 0 ? (posCount / totalCount * 100).toFixed(2) : 0;
        
        // Update the success rate display
        document.getElementById('success-rate').textContent = `file:${fileRate}%, line:${posRate}% (dataset size: ${totalCount})`;
        
        // Create position chart
        const ctxPos = document.getElementById('posChart').getContext('2d');
        new Chart(ctxPos, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'File && line hit',
                    data: posValues,
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: posValues.map(pos => pos < 0 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 1)'),
                    pointBorderColor: posValues.map(pos => pos < 0 ? 'rgb(255, 99, 132)' : 'rgb(54, 162, 235)'),
                    pointRadius: 2,
                    tension: 0.1
                }, {
                    label: 'File hit',
                    data: fileposValues,
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(255, 159, 64, 1)',
                    pointBorderColor: 'rgb(255, 159, 64)',
                    pointRadius: 2,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return dataset[index].filePath;
                            },
                            afterTitle: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return 'Query: ' + dataset[index].query;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Pos'
                        }
                    },
                    x: {
                        display: false
                    }
                }
            }
        });


        // Create timecost chart
        const timeCtx = document.getElementById('timeCostChart').getContext('2d');
        const timeCostValues = dataset.map(item => item.timecost);
        
        new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Time Cost (ms)',
                    data: timeCostValues,
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                    pointBorderColor: 'rgba(75, 192, 192, 1)',
                    pointRadius: 2,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return dataset[index].filePath;
                            },
                            afterTitle: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return 'Query: ' + dataset[index].query;
                            },
                            afterLabel: function(tooltipItem) {
                                const index = tooltipItem.dataIndex;
                                return 'Time cost: ' + dataset[index].timecost + ' ms';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Time (ms)'
                        }
                    },
                    x: {
                        display: false  // Hide x-axis completely
                    }
                }
            }
        });

        // Create FileMRR histogram
        const ctxFileMrr = document.getElementById('fileMrrHistogram').getContext('2d');
        const fileMrrValues = dataset.map(item => item.filemrr);
        
        // Define bins for histogram (0.0 to 1.0, step 0.01)
        const bins = Array.from({length: 101}, (_, i) => i / 100);
        const mrrLabels = bins.slice(0, -1).map((bin, i) => `${bin.toFixed(2)}-${bins[i+1].toFixed(2)}`);
        
        // Count values in each bin
        const counts = Array(bins.length - 1).fill(0);
        fileMrrValues.forEach(value => {
            if (value >= 0 && value <= 1) {
                const binIndex = Math.min(Math.floor(value * 100), 99);
                counts[binIndex]++;
            }
        });
        
        new Chart(ctxFileMrr, {
            type: 'bar',
            data: {
                labels: mrrLabels,
                datasets: [{
                    label: 'File MRR',
                    data: counts,
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    borderColor: 'rgba(153, 102, 255, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(tooltipItem) {
                                return tooltipItem.formattedValue + ' items';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Count'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'FileMRR Range'
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
