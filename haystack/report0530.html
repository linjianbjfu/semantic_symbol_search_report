<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dataset Position Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='60%' x='50%' dominant-baseline='middle' text-anchor='middle' font-size='120'>âš¡</text></svg>">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .chart-container {
            width: 800px;
            height: 500px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 0.85rem; /* Smaller font size */
            table-layout: fixed; /* For better control of column widths */
        }
        /* Column width specifications */
        table th:nth-child(1), table td:nth-child(1) { width: 25%; } /* File Path column */
        table th:nth-child(2), table td:nth-child(2) { width: 20%; } /* Function column - narrower */
        table th:nth-child(3), table td:nth-child(3) { width: 20%; } /* Summarize by GPT-4o column - narrower */
        table th:nth-child(4), table td:nth-child(4) { width: 35%; } /* Code Snippet column */
        @media (max-width: 768px) {
            table {
                font-size: 0.75rem; /* Even smaller on mobile */
            }
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px; /* Slightly smaller padding */
            text-align: left;
            max-width: 200px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease-out;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9; /* Light gray for even rows */
        }
        tr:nth-child(odd) {
            background-color: #ffffff; /* White for odd rows */
        }
        tr:hover {
            background-color: #f0f7ff; /* Light blue hover effect */
        }
        td .cell-content {
            max-height: 3em; /* Approximately two lines of text */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        th {
            background-color: #eaeaea; /* Slightly darker header */
            max-height: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
            font-weight: bold;
        }
        td .cell-content.expanded {
            white-space: pre-wrap;
            max-height: none;
            -webkit-line-clamp: unset;
            line-clamp: unset;
            color: #0066cc; /* Blue color for expanded content */
            background-color: rgba(0, 102, 204, 0.05); /* Very light blue background */
        }
        .code-snippet-cell {
            font-family: Consolas, 'Courier New', Courier, monospace;
            font-size: 0.8rem; /* Smaller font for code */
        }
        .stats-container {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f7ff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stats-value {
            font-weight: bold;
            color: #0066cc;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Semantic search benchmark</h1>

    <div class="stats-container">
        <p>Haystack symbol match success rate <span id="success-rate" class="stats-value">0%</span></p>
    </div>

    <div class="chart-container">
        <canvas id="posChart"></canvas>
    </div>

    <div class="chart-container">
        <h2>File Distribution</h2>
        <canvas id="fileMrrHistogram"></canvas>
    </div>

    <div class="chart-container">
        <h2>Time Cost Analysis</h2>
        <canvas id="timeCostChart"></canvas>
    </div>

    <h2>Dataset</h2>
    <div id="table-container"></div>

    <script>
        // Dataset
        const dataset = [{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_auth\\wam\\wam_edge_signin_window_helper.cc:164-203","function":"WAMEdgeSignInWindowHelperImpl::FocusOnBrowserWithActiveSignIn","codesnippet":"{\n  if (edge_signin_ux_weak_ptr_opt_.has_value()) {\n    return FocusOnSigninUX();\n  }\n\n  if (!browser_parent_hwnd_) {\n    DLOG(WARNING) << \"browser_parent_hwnd_ not available for \"\n                     \"FocusOnBrowserWithActiveSignIn()\";\n    return false;\n  }\n\n  auto exit_fn = base::MakeScopeExit([&] { FallbackRefocus(); });\n\n  HWND account_panel_handle =\n      account_settings_pane_helper_.GetAccountSettingsPaneHandle(redo_search);\n\n  // No AccountSettingsPane found or more than one ASP found. Fallback to bad\n  // focus method. This can happen because the focus loss message on the browser\n  // can fire before the ASP is created.\n  if (!account_panel_handle)\n    return false;\n\n  // Focus operations performed below will return 0 on failure.\n  const bool did_focus =\n      SetForegroundWindow(account_panel_handle) != 0 &&\n      SetWindowPos(browser_parent_hwnd_, account_panel_handle, 0, 0, 0, 0,\n                   SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE) != 0;\n\n  // If either focus op fail, use the fallback refocus (exit func).\n  if (!did_focus) {\n    DLOG(WARNING) << \"SetForegroundWindow or SetWindowPos failed in \"\n                     \"FocusOnBrowserWithActiveSignIn(), falling back to \"\n                     \"FallbackRefocus()\";\n    return false;\n  }\n\n  // We focused the ASP so we don't need to run FallbackRefocus().\n  exit_fn.Dismiss();\n  return true;\n}","pos":0,"query":"FocusOnBrowserWithActiveSignIn","filepos":0,"timecost":1718.5237,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\sampling_metrics_provider.cc:189-321","function":"SamplingMetricsProvider::EmitMetrics","codesnippet":"{\n  // Total number of PWAs, including backgrounded, separated by tabbed vs\n  // standalone.\n  int standalone_pwas_count = 0;\n  int tabbed_pwas_count = 0;\n\n  // Whether the foreground window has a PWA as its foreground tab, separated by\n  // tabbed vs standalone.\n  bool standalone_pwas_in_active_use = false;\n  bool tabbed_pwas_in_active_use = false;\n\n  // Number of tabbed PWAs, split by most common configurations.\n  int tabbed_pwas_user_display_mode_browser_count = 0;\n  int tabbed_pwas_user_display_mode_browser_installed_by_user_count = 0;\n\n  int tabbed_pwas_display_mode_standalone_count = 0;\n  int tabbed_pwas_display_mode_standalone_installed_by_user_count = 0;\n\n  IdSet emitted_ukm_ids;\n  for (BrowserWindowInterface* browser : GetAllBrowserWindowInterfaces()) {\n    if (!AreWebAppsEnabled(browser->GetProfile())) {\n      continue;\n    }\n    // If this is a standalone app window.\n    if (browser->GetAppBrowserController()) {\n      // A browser may be being closed due to empty tabs. See\n      // https://crbug.com/378020140.\n      if (!browser->GetActiveTabInterface()) {\n        continue;\n      }\n\n      ++standalone_pwas_count;\n\n      // TODO(https://crbug.com/358404364): This function does not work on macOS\n      // for app windows.\n      if (browser->IsActive()) {\n        standalone_pwas_in_active_use = true;\n      }\n\n      MaybeEmitUkmMetricsForTab(browser->GetActiveTabInterface(),\n                                emitted_ukm_ids);\n    }\n\n    // If this is a PWA-tab in a normal browser window.\n    if (browser->GetType() == BrowserWindowInterface::Type::TYPE_NORMAL) {\n      auto* provider =\n          web_app::WebAppProvider::GetForWebApps(browser->GetProfile());\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      if (!provider) {\n        LOG(WARNING)\n            << \"WebAppProvider is not available for emitting UKM metrics.\";\n        return;\n      }\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      auto& registrar = provider->registrar_unsafe();\n\n      for (tabs::TabInterface* tab : browser->GetAllTabInterfaces()) {\n        auto* web_app_helper =\n            web_app::WebAppTabHelper::FromWebContents(tab->GetContents());\n        std::optional<webapps::AppId> app_id = web_app_helper->app_id();\n        if (app_id) {\n          ++tabbed_pwas_count;\n          if (tab->IsActivated() && browser->IsActive()) {\n            tabbed_pwas_in_active_use = true;\n          }\n\n          std::optional<mojom::UserDisplayMode> user_display_mode =\n              registrar.GetAppUserDisplayMode(*app_id);\n          bool installed_by_user = registrar.WasInstalledByUser(*app_id);\n          if (user_display_mode == mojom::UserDisplayMode::kBrowser) {\n            ++tabbed_pwas_user_display_mode_browser_count;\n            if (installed_by_user) {\n              ++tabbed_pwas_user_display_mode_browser_installed_by_user_count;\n            }\n          }\n\n          if (user_display_mode == mojom::UserDisplayMode::kStandalone) {\n            ++tabbed_pwas_display_mode_standalone_count;\n            if (installed_by_user) {\n              ++tabbed_pwas_display_mode_standalone_installed_by_user_count;\n            }\n          }\n          MaybeEmitUkmMetricsForTab(tab, emitted_ukm_ids);\n        } else {\n          // If the tab does not have an app id, it might be promotable.\n          auto* app_banner_manager =\n              webapps::AppBannerManager::FromWebContents(tab->GetContents());\n          if (app_banner_manager) {\n            std::optional<webapps::WebAppBannerData> banner_data =\n                app_banner_manager->GetCurrentWebAppBannerData();\n            webapps::InstallableWebAppCheckResult installable =\n                app_banner_manager->GetInstallableWebAppCheckResult();\n\n            if (banner_data &&\n                installable ==\n                    webapps::InstallableWebAppCheckResult::kYes_Promotable) {\n              MaybeEmitUkmMetricsForPromotable(tab, *banner_data,\n                                               emitted_ukm_ids);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  int pwas_count = standalone_pwas_count + tabbed_pwas_count;\n  bool pwas_in_active_use =\n      standalone_pwas_in_active_use || tabbed_pwas_in_active_use;\n  UMA_HISTOGRAM_COUNTS_100(\"WebApp.Engagement2.Count\", pwas_count);\n  UMA_HISTOGRAM_BOOLEAN(\"WebApp.Engagement2.Active\", pwas_in_active_use);\n\n  UMA_HISTOGRAM_COUNTS_100(\"WebApp.Engagement2.Standalone.Count\",\n                           standalone_pwas_count);\n  UMA_HISTOGRAM_COUNTS_100(\"WebApp.Engagement2.Tabbed.Count\",\n                           tabbed_pwas_count);\n  UMA_HISTOGRAM_BOOLEAN(\"WebApp.Engagement2.Standalone.Active\",\n                        standalone_pwas_in_active_use);\n  UMA_HISTOGRAM_BOOLEAN(\"WebApp.Engagement2.Tabbed.Active\",\n                        tabbed_pwas_in_active_use);\n\n  UMA_HISTOGRAM_COUNTS_100(\n      \"WebApp.Engagement2.Tabbed.UserDisplayModeBrowser.Count\",\n      tabbed_pwas_user_display_mode_browser_count);\n  UMA_HISTOGRAM_COUNTS_100(\n      \"WebApp.Engagement2.Tabbed.UserDisplayModeBrowserInstalledByUser.Count\",\n      tabbed_pwas_user_display_mode_browser_installed_by_user_count);\n  UMA_HISTOGRAM_COUNTS_100(\n      \"WebApp.Engagement2.Tabbed.UserDisplayModeStandalone.Count\",\n      tabbed_pwas_display_mode_standalone_count);\n  UMA_HISTOGRAM_COUNTS_100(\n      \"WebApp.Engagement2.Tabbed.UserDisplayModeStandaloneInstalledByUser.\"\n      \"Count\",\n      tabbed_pwas_display_mode_standalone_installed_by_user_count);\n}","pos":-1,"query":"Collects and logs PWA usage metrics.","filepos":-1,"timecost":801.4600000000003,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\signin\\bound_session_credentials\\bound_session_registration_fetcher_impl.cc:183-246","function":"BoundSessionRegistrationFetcherImpl::StartFetchingRegistration","codesnippet":"{\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"device_bound_session_register\",\n                                          R\"(\n        semantics {\n          sender: \"Chrome - Google authentication API\"\n          description:\n            \"This request is used to rotate bound Google authentication \"\n            \"cookies.\"\n          trigger:\n            \"This request is triggered in a bound session when the bound Google\"\n            \" authentication cookies are soon to expire.\"\n          user_data {\n            type: ACCESS_TOKEN\n          }\n          data: \"Request includes cookies and a signed token proving that a\"\n                \" request comes from the same device as was registered before.\"\n          destination: GOOGLE_OWNED_SERVICE\n          internal {\n            contacts {\n                email: \"chrome-signin-team@google.com\"\n            }\n          }\n          last_reviewed: \"2024-05-30\"\n        }\n        policy {\n          cookies_allowed: YES\n          cookies_store: \"user\"\n          setting:\n             \"This feature cannot be disabled in settings, but this request \"\n             \"won't be made unless the user signs in to google.com.\"\n          chrome_policy: {\n            BoundSessionCredentialsEnabled {\n              BoundSessionCredentialsEnabled: false\n            }\n          }\n        })\");\n\n  auto request = std::make_unique<network::ResourceRequest>();\n  request->url = registration_params_.registration_endpoint();\n  request->method = \"POST\";\n  request->site_for_cookies = net::SiteForCookies::FromUrl(\n      registration_params_.registration_endpoint());\n  request->trusted_params = network::ResourceRequest::TrustedParams();\n  request->trusted_params->isolation_info =\n      net::IsolationInfo::CreateForInternalRequest(\n          url::Origin::Create(registration_params_.registration_endpoint()));\n\n  std::string content_type = \"application/jwt\";\n\n  url_loader_ = CreateSimpleURLLoaderWithVariationsHeaderUnknownSignedIn(\n      std::move(request),\n      is_off_the_record_profile_ ? variations::InIncognito::kYes\n                                 : variations::InIncognito::kNo,\n      traffic_annotation);\n  url_loader_->AttachStringForUpload(registration_token, content_type);\n  url_loader_->SetRetryOptions(\n      3, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);\n  url_loader_->DownloadToString(\n      url_loader_factory_.get(),\n      base::BindOnce(&BoundSessionRegistrationFetcherImpl::OnURLLoaderComplete,\n                     base::Unretained(this)),\n      10 * 1024);\n}","pos":-1,"query":"registerDeviceBoundSession","filepos":158,"timecost":1194.4924,"filemrr":0.5},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\thumbnails\\thumbnail_scheduler_impl.cc:62-173","function":"ThumbnailSchedulerImpl::Schedule","codesnippet":"{\n  // Scheduling is run after each tab priority change. So, at most one\n  // tab may be scheduled, at most one tab may be descheduled, or both.\n  TabNode* scheduled_tab = nullptr;\n  TabNode* descheduled_tab = nullptr;\n\n  // First, move the tab node to the correct list and update the\n  // capturing counts.\n\n  if (tab_node->next()) {\n    tab_node->RemoveFromList();\n  }\n  if (tab_node->is_capturing) {\n    switch (old_data.priority) {\n      case TabCapturePriority::kNone:\n        NOTREACHED();\n      case TabCapturePriority::kLow:\n        lo_prio_capture_count_ -= 1;\n        break;\n      case TabCapturePriority::kHigh:\n        hi_prio_capture_count_ -= 1;\n        break;\n    }\n  }\n\n  switch (tab_node->data.priority) {\n    case TabCapturePriority::kNone:\n      descheduled_tab = tab_node;\n      break;\n    case TabCapturePriority::kLow:\n      if (tab_node->is_capturing) {\n        lo_prio_capturing_.Append(tab_node);\n        lo_prio_capture_count_ += 1;\n      } else {\n        lo_prio_waiting_.Append(tab_node);\n      }\n      break;\n    case TabCapturePriority::kHigh:\n      if (tab_node->is_capturing) {\n        hi_prio_capturing_.Append(tab_node);\n        hi_prio_capture_count_ += 1;\n      } else {\n        hi_prio_waiting_.Append(tab_node);\n      }\n      break;\n  }\n\n  // First schedule a high priority tab if any are waiting, subject to\n  // the maximum. Note that at most one may be schedulable. Prior to\n  // this scheduling update, all possible high priority tabs were\n  // scheduled. The only conditions leading to scheduling a new one are:\n  //\n  // 1. |tab| was newly prioritized and less than |max_total_captures_|\n  //    tabs are capturing, or\n  //\n  // 2. |tab| was deprioritized and other tabs are waiting in\n  //    |high_priority_wait_queue_|.\n  //\n  // So pick one tab from |high_priority_wait_queue_| and schedule it.\n  // In case (1) this is guaranteed to be |tab|.\n\n  if (hi_prio_capture_count_ < max_total_captures_ &&\n      !hi_prio_waiting_.empty()) {\n    scheduled_tab = hi_prio_waiting_.head()->value();\n    scheduled_tab->RemoveFromList();\n    hi_prio_capturing_.Append(scheduled_tab);\n    hi_prio_capture_count_ += 1;\n  }\n\n  const int lo_prio_quota = std::min(\n      max_low_priority_captures_, max_total_captures_ - hi_prio_capture_count_);\n\n  // A high priority tab may have been deprioritized, so the low\n  // priority quota may be off by one.\n  DCHECK_LE(lo_prio_capture_count_, lo_prio_quota + 1);\n\n  // A new high priority capture may preempt an existing low priority one. This\n  // happens in two cases:\n  //\n  // 1. |tab| was set to high priority when at the max total captures, or\n  //\n  // 2. |tab| was changed from high to low priority while capturing and\n  // there are other high priority tabs waiting.\n  //\n  // In this case, deschedule any low priority tab. Otherwise, schedule\n  // a new one if below the quota. Note the latter cannot happen if a\n  // high priority tab was scheduled above.\n  if (lo_prio_capture_count_ > lo_prio_quota) {\n    DCHECK_EQ(descheduled_tab, nullptr);\n    descheduled_tab = lo_prio_capturing_.tail()->value();\n    descheduled_tab->RemoveFromList();\n    lo_prio_waiting_.Append(descheduled_tab);\n    lo_prio_capture_count_ -= 1;\n  } else if (lo_prio_capture_count_ < lo_prio_quota &&\n             !lo_prio_waiting_.empty()) {\n    DCHECK_EQ(scheduled_tab, nullptr);\n    scheduled_tab = lo_prio_waiting_.head()->value();\n    scheduled_tab->RemoveFromList();\n    lo_prio_capturing_.Append(scheduled_tab);\n    lo_prio_capture_count_ += 1;\n  }\n\n  if (descheduled_tab) {\n    descheduled_tab->capturer->SetCapturePermittedByScheduler(false);\n    descheduled_tab->is_capturing = false;\n  }\n\n  if (scheduled_tab) {\n    scheduled_tab->capturer->SetCapturePermittedByScheduler(true);\n    scheduled_tab->is_capturing = true;\n  }\n}","pos":-1,"query":"Tab capture scheduling and prioritization","filepos":-1,"timecost":965.8973000000001,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\emulator\\device_emulator_message_handler.cc:240-283","function":"DeviceEmulatorMessageHandler::HandleRequestBluetoothInfo","codesnippet":"{\n  AllowJavascript();\n  // Get a list containing paths of the devices which are connected to\n  // the main adapter.\n  std::vector<dbus::ObjectPath> paths =\n      fake_bluetooth_device_client_->GetDevicesForAdapter(\n          dbus::ObjectPath(bluez::FakeBluetoothAdapterClient::kAdapterPath));\n\n  // Get each device's properties.\n  base::Value::List devices;\n  for (const dbus::ObjectPath& path : paths) {\n    devices.Append(GetDeviceInfo(path));\n  }\n\n  base::Value predefined_devices =\n      fake_bluetooth_device_client_->GetBluetoothDevicesAsDictionaries();\n\n  base::Value::List pairing_method_options;\n  pairing_method_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingMethodNone);\n  pairing_method_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingMethodPinCode);\n  pairing_method_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingMethodPassKey);\n\n  base::Value::List pairing_action_options;\n  pairing_action_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingActionDisplay);\n  pairing_action_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingActionRequest);\n  pairing_action_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingActionConfirmation);\n  pairing_action_options.Append(\n      bluez::FakeBluetoothDeviceClient::kPairingActionFail);\n\n  base::Value::Dict info;\n  info.Set(\"predefined_devices\", std::move(predefined_devices));\n  info.Set(\"devices\", std::move(devices));\n  info.Set(\"pairing_method_options\", std::move(pairing_method_options));\n  info.Set(\"pairing_action_options\", std::move(pairing_action_options));\n\n  // Send the list of devices to the view.\n  FireWebUIListener(\"bluetooth-info-updated\", info);\n}","pos":-1,"query":"updateBluetoothInfoUI","filepos":-1,"timecost":1120.4305000000004,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\fileapi\\external_file_resolver.cc:61-99","function":"unknown","codesnippet":"{\n    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n    if (!g_browser_process->profile_manager()->IsValidProfile(profile_id)) {\n      ReplyResult(net::ERR_FAILED);\n      return;\n    }\n    Profile* const profile = reinterpret_cast<Profile*>(profile_id);\n    content::StoragePartition* const storage =\n        profile->GetDefaultStoragePartition();\n    DCHECK(storage);\n\n    scoped_refptr<storage::FileSystemContext> context =\n        storage->GetFileSystemContext();\n    DCHECK(context.get());\n\n    // Obtain the absolute path in the file system.\n    const base::FilePath virtual_path = ExternalFileURLToVirtualPath(url);\n\n    // Obtain the file system URL.\n    isolated_file_system_ =\n        file_manager::util::CreateIsolatedURLFromVirtualPath(\n            *context, url::Origin(), virtual_path);\n\n    // Check if the obtained path providing external file URL or not.\n    if (!isolated_file_system_.url.is_valid()) {\n      ReplyResult(net::ERR_INVALID_URL);\n      return;\n    }\n\n    if (!IsExternalFileURLType(isolated_file_system_.url.type())) {\n      ReplyResult(net::ERR_FAILED);\n      return;\n    }\n\n    file_system_context_ = std::move(context);\n    extensions::app_file_handler_util::GetMimeTypeForLocalPath(\n        profile, isolated_file_system_.url.path(),\n        base::BindOnce(&URLHelper::OnGotMimeTypeOnUIThread,\n                       base::Unretained(this), std::move(lifetime)));\n  }","pos":-1,"query":"Validate profile and process file URL","filepos":-1,"timecost":1028.0866000000005,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\edge_user_settings_protector.cc:93-123","function":"EdgeUserSettingsProtector::LogTelemetryOnExtensionInstalled","codesnippet":"{\n  // Trigger usage if the extension is modifying Ntp/Search/Homepage\n  const URLOverrides::URLOverrideMap& overrides =\n      URLOverrides::GetChromeURLOverrides(extension);\n  const SettingsOverrides* settings = SettingsOverrides::Get(extension);\n  if ((overrides.find(chrome::kChromeUINewTabHost) != overrides.end()) ||\n      (settings && (settings->search_engine || settings->homepage))) {\n    base::FeatureList::TriggerUsage(\n        features::edge::kSettingsTakeoverPolicyProviderTrigger);\n  }\n\n  if (CanExtensionModifySearch(settings)) {\n    return base::RecordAction(base::UserMetricsAction(\n        \"Microsoft.Extensions.SearchExtension_Installed\"));\n  }\n\n  if (CanExtensionModifyNtp(overrides)) {\n    return base::RecordAction(\n        base::UserMetricsAction(\"Microsoft.Extensions.NTPExtension_Installed\"));\n  }\n\n  if (CanExtensionModifyHomepage(settings)) {\n    return base::RecordAction(base::UserMetricsAction(\n        \"Microsoft.Extensions.HomepageExtension_Installed\"));\n  }\n\n  if (CanExtensionModifyStartupPages(settings)) {\n    return base::RecordAction(base::UserMetricsAction(\n        \"Microsoft.Extensions.StartupPageExtension_Installed\"));\n  }\n}","pos":-1,"query":"Log extension modification actions","filepos":-1,"timecost":817.5716999999995,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\search\\ranking\\ranker_manager.cc:34-117","function":"RankerManager::RankerManager","codesnippet":"{\n  // Score normalization parameters:\n  ScoreNormalizer::Params score_normalizer_params;\n  // Change this version number when changing the number of bins below.\n  score_normalizer_params.version = 1;\n  // The maximum number of buckets the score normalizer discretizes result\n  // scores into.\n  score_normalizer_params.max_bins = 5;\n\n  // Result ranking parameters.\n  FtrlOptimizer::Params ftrl_result_params;\n  ftrl_result_params.alpha = 0.1;\n  ftrl_result_params.gamma = 0.1;\n  ftrl_result_params.num_experts = 2u;\n\n  MrfuCache::Params mrfu_result_params;\n  mrfu_result_params.half_life = 30.0f;\n  mrfu_result_params.boost_factor = 2.5f;\n  mrfu_result_params.max_items = 200u;\n\n  // Category ranking parameters.\n  FtrlOptimizer::Params ftrl_category_params;\n  ftrl_category_params.alpha = 0.1;\n  ftrl_category_params.gamma = 0.1;\n  ftrl_category_params.num_experts = 2u;\n\n  MrfuCache::Params mrfu_category_params;\n  mrfu_category_params.half_life = 20.0f;\n  mrfu_category_params.boost_factor = 7.0f;\n  mrfu_category_params.max_items = 20u;\n\n  const auto state_dir = RankerStateDirectory(profile);\n\n  // 1. Result pre-processing. These filter or modify search results but don't\n  // change their scores.\n  AddRanker(std::make_unique<QueryHighlighter>());\n  AddRanker(std::make_unique<ContinueRanker>());\n  AddRanker(std::make_unique<FilteringRanker>());\n  AddRanker(std::make_unique<RemovedResultsRanker>(profile));\n\n  // 2. Score normalization, a precursor to other ranking.\n  AddRanker(std::make_unique<ScoreNormalizingRanker>(\n      score_normalizer_params,\n      ash::PersistentProto<ScoreNormalizerProto>(\n          state_dir.AppendASCII(\"score_norm.pb\"), kStandardWriteDelay)));\n\n  // 3. Ranking for results.\n  // 3a. Most-frequently-recently-used (MRFU) ranking.\n  auto mrfu_ranker = std::make_unique<MrfuResultRanker>(\n      mrfu_result_params,\n      ash::PersistentProto<MrfuCacheProto>(\n          state_dir.AppendASCII(\"mrfu_results.pb\"), kStandardWriteDelay));\n  AddRanker(std::move(mrfu_ranker));\n\n  // 3b. Ensembling between MRFU and normalized score ranking.\n  auto ftrl_ranker = std::make_unique<FtrlRanker>(\n      FtrlRanker::RankingKind::kResults, ftrl_result_params,\n      ash::PersistentProto<FtrlOptimizerProto>(\n          state_dir.AppendASCII(\"ftrl_results.pb\"), kStandardWriteDelay));\n  ftrl_ranker->AddExpert(std::make_unique<ResultScoringShim>(\n      ResultScoringShim::ScoringMember::kNormalizedRelevance));\n  ftrl_ranker->AddExpert(std::make_unique<ResultScoringShim>(\n      ResultScoringShim::ScoringMember::kMrfuResultScore));\n  AddRanker(std::move(ftrl_ranker));\n\n  // 4. Ranking for categories\n  AddRanker(std::make_unique<MrfuCategoryRanker>(\n      mrfu_category_params,\n      ash::PersistentProto<MrfuCacheProto>(\n          state_dir.AppendASCII(\"mrfu_categories.pb\"), kStandardWriteDelay)));\n\n  // TODO(b/274921356): Temporarily comment out the `KeywordRanker` construction\n  // to avoid any possible crashes. Re-enable it when we make sure this problem\n  // has been fixed.\n  //\n  // if (search_features::IsLauncherKeywordExtractionScoringEnabled()) {\n  //   AddRanker(std::make_unique<KeywordRanker>());\n  // }\n\n  // 5. Result post-processing.\n  // Nb. the best match ranker relies on score normalization, and the answer\n  // ranker relies on the best match ranker.\n  AddRanker(std::make_unique<BestMatchRanker>());\n  AddRanker(std::make_unique<AnswerRanker>());\n}","pos":-1,"query":"Configure and add ranking algorithms","filepos":2,"timecost":1710.4012999999995,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\extension_gcm_app_handler.cc:106-142","function":"ExtensionGCMAppHandler::OnExtensionUnloaded","codesnippet":"{\n  if (!IsGCMPermissionEnabled(extension))\n    return;\n\n  if (reason == UnloadedExtensionReason::UPDATE &&\n      !GetGCMDriver()->app_handlers().empty()) {\n    // When the extension is being updated, it will be first unloaded and then\n    // loaded again by ExtensionService::AddExtension. If the app handler for\n    // this extension is the only handler, removing it and adding it again will\n    // cause the GCM service being stopped and restarted unnecessarily. To work\n    // around this, we add a dummy app handler to guard against it. This dummy\n    // app handler will be removed once the extension loading logic is done.\n    //\n    // Note that this dummy app handler is added when there is at least one\n    // handler. This is because there might be a built-in app handler, like\n    // GCMAccountMapper, which is automatically added and removed by\n    // GCMDriverDesktop.\n    //\n    // Also note that the GCM message routing will not be interrupted during\n    // the update process since unloading and reloading extension are done in\n    // the single function ExtensionService::AddExtension.\n    AddDummyAppHandler();\n\n    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&ExtensionGCMAppHandler::RemoveDummyAppHandler,\n                       weak_factory_.GetWeakPtr()));\n  }\n\n  // When the extension is being uninstalled, it will be unloaded first. We\n  // should not remove the app handler in this case and it will be handled\n  // in OnExtensionUninstalled.\n  if (reason != UnloadedExtensionReason::UNINSTALL)\n    RemoveAppHandler(extension->id());\n}","pos":-1,"query":"Manage GCM app handlers during extension updates","filepos":52,"timecost":755.0673999999999,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\privacy_budget\\identifiability_study_state.cc:248-292","function":"IdentifiabilityStudyState::UpdateSelectedOffsets","codesnippet":"{\n  std::set<OffsetType> newly_selected_offsets;\n  int newly_active_offset_count = 0;\n  base::RandomBitGenerator bit_generator;\n\n  while (newly_selected_offsets.size() + selected_offsets_.size() <\n             offsets_to_select &&\n         CanAddOneMoreActiveSurface()) {\n    auto offset_to_add = random_offset_generator_.Get(bit_generator);\n\n    // Probability of repeatedly hitting this condition is vanishingly small if\n    // the following assertion holds.\n    static_assert(kMaxSelectedSurfaceOffset >\n                      features::kMaxIdentifiabilityStudyExpectedSurfaceCount,\n                  \"\");\n    if (offset_to_add > kMaxSelectedSurfaceOffset)\n      continue;\n\n    // Collision with previously selected offset. Kept in check with use of\n    // a collision \"safe\" upperbound in GetCountOfOffsetsToSelect().\n    auto result = newly_selected_offsets.insert(offset_to_add);\n    if (!result.second || base::Contains(selected_offsets_, offset_to_add))\n      continue;\n\n    if (offset_to_add >= seen_surfaces_.size())\n      continue;\n\n    auto surface = seen_surfaces_[offset_to_add];\n\n    if (!active_surfaces_.TryAdd(surface, active_surface_budget_)) {\n      newly_selected_offsets.erase(offset_to_add);\n      // If this surface didn't fit, then continuing this loop may result in\n      // a perpetual loop where `active_surfaces_` is not saturated, but none of\n      // the seen surfaces fit the budget.\n      break;\n    }\n\n    ++newly_active_offset_count;\n  }\n\n  selected_offsets_.insert(newly_selected_offsets.begin(),\n                           newly_selected_offsets.end());\n  active_offset_count_ += newly_active_offset_count;\n  WriteSelectedOffsetsToPrefs();\n}","pos":-1,"query":"selectAndActivateOffsets","filepos":8,"timecost":1688.1355000000003,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_hub_apps\\standalone\\desktop_dock_helper_edgebar_win.cc:351-403","function":"DesktopDockHelperEdgebarWin::HandleTimerHide","codesnippet":"{\n  // The debounce period has expired.\n  if (!edge::hub_apps::features::IsEdgeBarAutoHideIntoTheRightFringeEnabled()) {\n    KillTimer(hwnd, TIMER_HIDE);\n    return;\n  }\n\n  if (current_appbar_width_ <= kMinAutoHideWidth) {\n    KillTimer(hwnd, TIMER_HIDE);\n    return;\n  }\n  const bool auto_hide_toggled = g_browser_process &&\n                                 g_browser_process->local_state() &&\n                                 g_browser_process->local_state()->GetBoolean(\n                                     prefs::kAutoHideSidebarToTheRightFringe);\n  if (!auto_hide_toggled) {\n    KillTimer(hwnd, TIMER_HIDE);\n    return;\n  }\n\n  const bool is_menu_open =\n      edge::hub_apps::standalone::StandaloneSidebarManager::GetInstance()\n          ->GetMenuModelManager()\n          ->IsMenuOpen();\n  if (is_menu_open) {\n    // No needed to kill timer because we want the bar to be\n    // hidden when the menu is closed.\n    return;\n  }\n\n  Browser* browser =\n      edge::hub_apps::standalone::StandaloneSidebarManager::GetActiveBrowser();\n  if (browser) {\n    auto* side_pane =\n        browser->window() ? browser->window()->GetEdgeSidePane() : nullptr;\n    if (side_pane) {\n      const bool side_pane_is_showing = side_pane->IsSidePaneShowing() ||\n                                        side_pane->IsShorelineSearchVisible() ||\n                                        side_pane->IsSidePaneV1Showing();\n      if (side_pane_is_showing) {\n        return;\n      }\n    }\n  }\n\n  POINT pt;\n  GetCursorPos(&pt);\n  RECT rc;\n  GetWindowRect(hwnd, &rc);\n  if (!PtInRect(&rc, pt)) {\n    KillTimer(hwnd, TIMER_HIDE);\n    SetTimer(hwnd, TIMER_ANIMATE_HIDE, kSlidingAnimationIntervalMS, nullptr);\n  }\n}","pos":-1,"query":"Auto-hide sidebar timer management","filepos":9,"timecost":1200.8451999999997,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\mako\\mako_bubble_event_handler.cc:211-246","function":"unknown","codesnippet":"{\n    // Keeps resizing.\n    if (event_->type() == ui::EventType::kMouseDragged ||\n        event_->type() == ui::EventType::kTouchMoved) {\n      gfx::Vector2d resizing_unit =\n          MapResizingDirectionToVector(s.resizing_direction);\n      gfx::Vector2d pointer_delta = GetBoundsInScreen().OffsetFromOrigin() +\n                                    GetPointerPos() - s.original_pointer_pos;\n\n      int new_width = std::max(s.original_bounds_in_screen.width() +\n                                   pointer_delta.x() * resizing_unit.x(),\n                               kMinWidgetWidth);\n      int new_height = std::max(s.original_bounds_in_screen.height() +\n                                    pointer_delta.y() * resizing_unit.y(),\n                                kMinWidgetHeight);\n\n      int new_x = s.original_bounds_in_screen.x();\n      int new_y = s.original_bounds_in_screen.y();\n\n      if (resizing_unit.x() < 0) {\n        new_x -= new_width - s.original_bounds_in_screen.width();\n      }\n\n      if (resizing_unit.y() < 0) {\n        new_y -= new_height - s.original_bounds_in_screen.height();\n      }\n\n      SetWidgetBoundsConstrained(gfx::Rect(/*x=*/new_x, /*y=*/new_y,\n                                           /*width=*/new_width,\n                                           /*height=*/new_height));\n      MarkEventHandled();\n\n      return s;\n    }\n\n    return InitialState{};\n  }","pos":-1,"query":"resizeWidgetOnDragOrTouchEvent","filepos":231,"timecost":1606.4579999999987,"filemrr":0.8},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\fileapi\\diversion_backend_delegate.cc:267-306","function":"DiversionBackendDelegate::CopyFileLocal","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);\n\n  if (!src_url.is_valid() || !dest_url.is_valid()) {\n    std::move(callback).Run(base::File::FILE_ERROR_INVALID_URL);\n    return;\n  } else if (src_url == dest_url) {\n    std::move(callback).Run(base::File::FILE_OK);\n    return;\n  }\n\n  if (diversion_file_manager_->IsDiverting(dest_url)) {\n    // Passing a null DiversionFileManager::Callback deletes the diversion file.\n    diversion_file_manager_->FinishDiverting(dest_url,\n                                             DiversionFileManager::Callback());\n  }\n\n  if (diversion_file_manager_->IsDiverting(src_url)) {\n    diversion_file_manager_->FinishDiverting(\n        src_url,\n        base::BindOnce(&DiversionBackendDelegate::OnDiversionFinished,\n                       weak_ptr_factory_.GetWeakPtr(),\n                       OnDiversionFinishedCallSite::kCopyFileLocal,\n                       std::move(context), dest_url, std::move(callback)));\n    return;\n  } else if (ShouldDivert(src_url) == Policy::kDivertIsolated) {\n    std::move(callback).Run(base::File::FILE_ERROR_NOT_FOUND);\n    return;\n  }\n\n  storage::AsyncFileUtil* af_util = wrappee_->GetAsyncFileUtil(dest_url.type());\n  af_util->CopyFileLocal(std::move(context), src_url, dest_url,\n                         std::move(options), std::move(progress_callback),\n                         std::move(callback));\n}","pos":30,"query":"CopyFileWithDiversionHandling","filepos":11,"timecost":1286.825999999999,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_atomic_framework\\components\\container_component_base.cc:64-109","function":"ContainerComponentBase::OnActionReceived","codesnippet":"{\n  // See if we have a top level child handler for this action source.\n  if (components_.find(action_source_id) != components_.end()) {\n    auto* action_component =\n        static_cast<ActionComponentBase*>(components_[action_source_id].get());\n    action_component->ExecuteActionHandler(action_source_id, action_id);\n    return;\n  }\n\n  // See if we have a standalone component handler for this action source.\n  if (standalone_components_.find(action_source_id) !=\n      standalone_components_.end()) {\n    auto* action_component = static_cast<ActionComponentBase*>(\n        standalone_components_[action_source_id]);\n    action_component->ExecuteActionHandler(action_source_id, action_id);\n    return;\n  }\n\n  // See if any of the child components can handle this action source.\n  for (const auto& component : components_) {\n    auto* child_component_handler =\n        component.second->FindActionSourceHandler(action_source_id);\n    if (child_component_handler) {\n      auto* child_action_component =\n          static_cast<ActionComponentBase*>(child_component_handler);\n      child_action_component->ExecuteActionHandler(action_source_id, action_id);\n      return;\n    }\n  }\n\n  // See if any of the standalone components' children can handle this action\n  // source.\n  for (const auto& component : standalone_components_) {\n    auto* child_component_handler =\n        component.second->FindActionSourceHandler(action_source_id);\n    if (child_component_handler) {\n      auto* child_action_component =\n          static_cast<ActionComponentBase*>(child_component_handler);\n      child_action_component->ExecuteActionHandler(action_source_id, action_id);\n      return;\n    }\n  }\n\n  DCHECK(false) << \"Action source not found in the card. Card ID: \"\n                << this->GetId() << \" action_source_id: \" << action_source_id;\n}","pos":-1,"query":"executeActionHandlerForSource","filepos":-1,"timecost":1178.1579000000002,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\privacy\\page_data_provider_clear_browsing_data.cc:210-252","function":"ClearBrowsingDataPageDataProvider::BuildEdgeClearDataSection","codesnippet":"{\n  auto* section = CreateSection(cached_page_ptr_.get());\n  auto* header = CreateHeaderInSection(section);\n  RegisterSearchableString(section, &(header->title),\n                           IDS_SETTINGS_CLEAR_BROWSING_DATA_NAV_TITLE,\n                           nullptr /* row */);\n  header->type = mojom::HeaderType::Large;\n  auto parent_info = std::vector<std::pair<mojom::SettingsPageIds, int>>{\n      {mojom::SettingsPageIds::PrivacySearchServices,\n       IDS_SETTINGS_PRIVACY_SEARCH_SERVICES_TITLE}};\n  CreateParentInfoInHeader(header, parent_info);\n\n  // Build description with 'Manage your data' link\n  mojom::LinkedText* description = CreateDescriptionInHeader(header);\n  DCHECK(description);\n  RegisterSearchableString(section, &(description->templateString),\n                           IDS_SETTINGS_CLEAR_DATA_PROFILE_DESCRIPTION,\n                           nullptr /* row */);\n  auto links = CreateLinks(description->links, 1);\n  RegisterSearchableString(section, &(links[0]->text),\n                           IDS_SETTINGS_CLEAR_DATA_PRIVACY_LINK_TEXT,\n                           nullptr /* row */);\n  links[0]->url = GetResourceString(IDS_SETTINGS_CLEAR_DATA_PRIVACY_LINK);\n\n  // Build 'Choose what to clear' button row\n  auto* row = CreateRowInSection(section);\n  RegisterSearchableString(section, &(row->title),\n                           IDS_SETTINGS_CLEAR_DATA_TITLE, row);\n  row->type = mojom::RowType::Button;\n  auto* button = CreateButtonInRow(row);\n  button->id = mojom::FormControlIds::ClearBrowsingDataModal;\n  button->buttonType = mojom::ButtonType::DialogButton;\n  button->actionType = mojom::ActionType::Command;\n  RegisterSearchableString(section, &(button->text),\n                           IDS_SETTINGS_CHOOSE_WHAT_TO_CLEAR_BUTTON, row);\n\n  BuildClearBrowsingDataDialogInfo(button);\n\n  // Clear browsing data on close subpage link\n  BuildSubPageLinkRow(section, /*icon=*/\"\",\n                      mojom::FormControlIds::ClearOnExitRow,\n                      mojom::SettingsPageIds::ClearBrowsingDataOnClose,\n                      IDS_SETTINGS_CLEAR_BROWSING_DATA_ON_EXIT);\n}","pos":-1,"query":"buildClearBrowsingDataSection","filepos":0,"timecost":1147.342700000001,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\policy\\cloud\\user_policy_signin_service.cc:188-219","function":"UserPolicySigninService::ProhibitSignoutIfNeeded","codesnippet":"{\n// In Edge cloud policy we support signout after user registered.\n// Deliverable 30904913 list the detailed investigation for reason of cutting the\n// chromium code\n#if EXCLUDED_FROM_EDGE\n  if ((!policy_manager() || !policy_manager()->IsClientRegistered()) &&\n      !internal::g_force_prohibit_signout_for_tests) {\n    return;\n  }\n\n  DVLOG(1) << \"User is registered for policy - prohibiting signout\";\n  bool has_sync_account =\n      identity_manager()->HasPrimaryAccount(signin::ConsentLevel::kSync);\n\n  if (!enterprise_util::UserAcceptedAccountManagement(profile_) &&\n      has_sync_account) {\n    // Ensure user accepted management bit is set.\n    enterprise_util::SetUserAcceptedAccountManagement(profile_, true);\n  }\n\n#if DCHECK_IS_ON()\n  // Setting the user accepted management bit should be enough to prohibit\n  // signout.\n  // The user accepted management bit is set in the profile storage. If there\n  // is no profile storage, the bit will not be set.\n  if (enterprise_util::UserAcceptedAccountManagement(profile_)) {\n    auto* sigin_client = ChromeSigninClientFactory::GetForProfile(profile_);\n    DCHECK(sigin_client->IsRevokeSyncConsentAllowed());\n    DCHECK(!sigin_client->IsClearPrimaryAccountAllowed(has_sync_account));\n  }\n#endif\n#endif\n}","pos":-1,"query":"Prohibit user signout if registered","filepos":-1,"timecost":1029.7014999999992,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\tpcd\\support\\validity_service.cc:85-124","function":"ValidityService::UpdateTrialSettings","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (g_disabled_for_testing || enabled) {\n    return;\n  }\n\n  HostContentSettingsMap* settings_map =\n      HostContentSettingsMapFactory::GetForProfile(\n          web_contents()->GetBrowserContext());\n  CHECK(settings_map);\n\n  // Find the setting that permitted the cookie access for the pair.\n  content_settings::SettingInfo info;\n  bool setting_exists = CheckTrialContentSetting(url, first_party_url,\n                                                 trial_settings_type, &info);\n\n  // If a matching setting no longer exists, there is no need to update\n  // |settings_map|.\n  if (!setting_exists) {\n    return;\n  }\n\n  // Because the same token is used to enable the trial for the request origin\n  // under all top-level origins, only the primary_pattern is checked here. This\n  // means all settings created with the same token as the setting represented\n  // by |info| should be deleted.\n  auto matches = [&](const ContentSettingPatternSource& setting) -> bool {\n    return (setting.primary_pattern == info.primary_pattern);\n  };\n  settings_map->ClearSettingsForOneTypeWithPredicate(trial_settings_type,\n                                                     matches);\n\n  SyncTrialSettingsToNetworkService(\n      trial_settings_type,\n      settings_map->GetSettingsForOneType(trial_settings_type));\n}","pos":-1,"query":"clearTrialSettingsForUrl","filepos":-1,"timecost":1316.7477,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_desktop\\settings_menu.cc:57-169","function":"SettingsMenu::CreateMenuModel","codesnippet":"{\n  // Profiles.\n  menu_profiles_.clear();\n\n  menu_model_ = std::make_unique<ui::SimpleMenuModel>(this);\n  if (profile_manager_) {\n    std::vector<ProfileAttributesEntry*> profile_attributes =\n        profile_manager_->GetProfileAttributesStorage()\n            .GetAllProfilesAttributesSortedByNameWithCheck();\n\n    for (ProfileAttributesEntry* entry : profile_attributes) {\n      if (!entry || (signin_util::IsEdgeForceSigninEnabled() &&\n                     !entry->IsAuthenticated())) {\n        continue;\n      }\n\n      std::u16string user_email = entry->GetUserName();\n      std::u16string profile_name = entry->GetName();\n\n      if (!user_email.empty() || !profile_name.empty()) {\n        std::u16string menu_item_text =\n            user_email.empty() ? profile_name : user_email;\n        menu_profiles_.push_back(entry);\n        MaybeAddCheckItem(menu_model_.get(), menu_profiles_.size() - 1,\n                          menu_item_text);\n      }\n    }\n  }\n\n  menu_model_->AddSeparator(ui::NORMAL_SEPARATOR);\n  menu_model_->AddItemWithStringIdAndIcon(\n      IDC_WEB_WIDGET_MANAGE_PROFILE_SETTINGS,\n      IDS_WEB_WIDGET_MANAGE_PROFILE_SETTINGS,\n      ui::ImageModel::FromVectorIcon(kProfileIcon));\n\n  menu_model_->AddSeparator(ui::NORMAL_SEPARATOR);\n\n  if (features::edge::IsDesktopModeFloatingIconEnabled()) {\n    MaybeAddCheckItem(menu_model_.get(), IDC_WEB_WIDGET_TOGGLE_FLOATING_ICON,\n                      l10n_util::GetStringUTF16(\n                          features::edge::IsCopyPasteEnabled()\n                              ? IDS_WEB_WIDGET_TOGGLE_COPY_PASTE_ICON_MENU_ITEM\n                              : IDS_WEB_WIDGET_TOGGLE_FLOATING_ICON_MENU_ITEM));\n    menu_model_->AddSeparator(ui::NORMAL_SEPARATOR);\n  }\n\n  menu_model_->AddItemWithStringId(IDC_WEB_WIDGET_STATUS_TRAY_OPEN,\n                                   IDS_SEARCH_BAR_SETTINGS_MENU_OPEN_MENU_ITEM);\n\n  if (profile_manager_) {\n    Profile* current_profile = profile_manager_->GetProfile(account_path_);\n    if (current_profile) {\n      EdgeRewardsService* rewards_service =\n          EdgeRewardsServiceFactory::GetForProfile(current_profile);\n      if (rewards_service && rewards_service->IsRewardsUser()) {\n        menu_model_->AddItemWithStringIdAndIcon(\n            IDC_WEB_WIDGET_MENU_REWARDS,\n            IDS_WEB_WIDGET_REWARDS_BUTTON_ACCESSIBLE_NAME,\n            ui::ImageModel::FromVectorIcon(kRewardsMedalIcon));\n      }\n    }\n  }\n\n  menu_model_->AddSeparator(ui::NORMAL_SEPARATOR);\n\n  // Sub menu for About.\n  about_sub_menu_model_ = std::make_unique<ui::SimpleMenuModel>(this);\n  about_sub_menu_model_->AddItemWithStringId(\n      IDC_WEB_WIDGET_OPEN_TERMS_OF_USE,\n      IDS_WEB_WIDGET_OPEN_TERMS_OF_USE_MENU_ITEM);\n  about_sub_menu_model_->AddItemWithStringId(\n      IDC_WEB_WIDGET_OPEN_PRIVACY_STATEMENT,\n      IDS_WEB_WIDGET_OPEN_PRIVACY_STATEMENT_MENU_ITEM);\n  about_sub_menu_model_->AddItemWithStringId(\n      IDC_WEB_WIDGET_OPEN_ABOUT_OUR_ADS,\n      IDS_WEB_WIDGET_OPEN_ABOUT_OUR_ADS_MENU_ITEM);\n  // Add about sub menu item.\n  menu_model_->AddSubMenuWithStringIdAndIcon(\n      IDC_WEB_WIDGET_ABOUT, IDS_WEB_WIDGET_ABOUT_MENU_ITEM,\n      about_sub_menu_model_.get(),\n      ui::ImageModel::FromVectorIcon(kInformationIcon));\n  // Add feedback menu item.\n  menu_model_->AddItemWithStringIdAndIcon(\n      IDC_WEB_WIDGET_FEEDBACK, IDS_WEB_WIDGET_FEEDBACK_MENU_ITEM,\n      ui::ImageModel::FromVectorIcon(kSendFeedbackIcon));\n  MaybeAddCheckItem(\n      menu_model_.get(), IDC_WEB_WIDGET_ON_BY_DEFAULT,\n      l10n_util::GetStringUTF16(IDS_WEB_WIDGET_ON_BY_DEFAULT_MENU_ITEM));\n  // Need to add minor icon if autostartup is controlled by policy.\n  if (searchbar_app_->IsAutoStartControlledByPolicy()) {\n    std::optional<size_t> command_index =\n        menu_model_->GetIndexOfCommandId(IDC_WEB_WIDGET_ON_BY_DEFAULT);\n    if (command_index) {\n      menu_model_->SetEnabledAt(*command_index, false);\n      menu_model_->SetMinorIcon(\n          *command_index,\n          ui::ImageModel::FromVectorIcon(vector_icons::kBusinessIcon));\n    }\n  }\n\n  if (features::edge::IsDesktopModeSearchOnlyFreEnabled()) {\n    menu_model_->AddItemWithStringIdAndIcon(\n        IDC_WEB_WIDGET_SEARCH_ONLY_FRE_HELP,\n        IDS_WEB_WIDGET_SEARCH_ONLY_FRE_HELP_TOOLTIP,\n        ui::ImageModel::FromVectorIcon(kHelpSubmenuItemIcon));\n  }\n\n  menu_model_->AddSeparator(ui::NORMAL_SEPARATOR);\n  // Add close menu item. Share the same string as close menu item from floaty\n  // menu.\n  menu_model_->AddItemWithStringIdAndIcon(\n      IDC_WEB_WIDGET_CLOSE, IDS_SEARCH_BAR_CLOSE_FLOATY_MENU_ITEM,\n      ui::ImageModel::FromVectorIcon(vector_icons::kCloseIcon));\n}","pos":-1,"query":"Builds and configures profile menu.","filepos":-1,"timecost":1585.6046999999999,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\passwords\\password_generation_popup_controller_impl.cc:124-154","function":"PasswordGenerationPopupControllerImpl::PasswordGenerationPopupControllerImpl","codesnippet":"{\n  // There may not always be a ZoomController, e.g. in tests.\n  if (auto* zoom_controller =\n          zoom::ZoomController::FromWebContents(web_contents)) {\n    zoom_observation_.Observe(zoom_controller);\n  }\n\n  help_text_ = l10n_util::GetStringUTF16(\n      IDS_PASSWORD_GENERATION_PROMPT_GOOGLE_PASSWORD_MANAGER);\n}","pos":-1,"query":"observeZoomControllerAndSetHelpText","filepos":8,"timecost":1891.1942999999992,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\frame\\immersive_mode_win_caption_buttons.cc:388-426","function":"ImmersiveModeWinCaptionButtons::Layout","codesnippet":"{\n  // Layout Container\n  SetX(browser_view_->width() - width());\n  SetY(0);\n\n  // Layout caption buttons, mostly only the x values vary.\n  // In TeamSKU, button layout is [ Annotate | Fullscreen | Close ]\n  // In Desktop, button layout is [ Minimize | Fullscreen | Close ]\n  int button_height =\n      browser_view_->tab_strip_region_view()->GetMinimumSize().height() -\n      kMaximizedBottomMargin;\n  int button_width = WindowFrameUtil::kWindowsCaptionButtonWidth;\n  if (base::win::IsTeamSku()) {\n    close_caption_button_->SetBounds(width() - button_width, kMaximizedFrame,\n                                     button_width, button_height);\n    if (fullscreen_caption_button_) {\n      fullscreen_caption_button_->SetBounds(\n          close_caption_button_->x() - button_width, kMaximizedFrame,\n          button_width, button_height);\n    }\n    if (annotate_caption_button_) {\n      annotate_caption_button_->SetBounds(\n          fullscreen_caption_button_->x() - button_width, kMaximizedFrame,\n          button_width, button_height);\n    }\n  } else {\n    close_caption_button_->SetBounds(width() - button_width, kMaximizedFrame,\n                                     button_width, button_height);\n    if (fullscreen_caption_button_) {\n      fullscreen_caption_button_->SetBounds(\n          close_caption_button_->x() - button_width, kMaximizedFrame,\n          button_width, button_height);\n    }\n    if (minimize_caption_button_) {\n      minimize_caption_button_->SetBounds(\n          fullscreen_caption_button_->x() - button_width, kMaximizedFrame,\n          button_width, button_height);\n    }\n  }\n}","pos":24,"query":"layoutCaptionButtons","filepos":19,"timecost":1262.8175999999985,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\page_data_provider_accessibility.cc:38-100","function":"AccessibilityPageDataProvider::SetVisibilitySection","codesnippet":"{\n  // Create section\n  auto* section = CreateSection(cached_page_ptr_.get());\n\n  // Section Header\n  auto* header = CreateHeaderInSection(section);\n  RegisterSearchableString(section, &(header->title),\n                           IDS_SETTINGS_ACCESSIBILITY_VISIBILITY_HEADER,\n                           nullptr /* row */);\n\n  // Section Pointers\n  mojom::Row* rowPtr = nullptr;\n\n  // Section Row -- Show a high visibility outline on the focused object toggle\n  rowPtr = CreateToggleRowInSection(\n      section, mojom::FormControlIds::AccessibilityVisibilityShowOutline);\n  RegisterSearchableString(\n      section, &(rowPtr->title),\n      IDS_SETTINGS_ACCESSIBILITY_VISIBILITY_OUTLINE_TOGGLE_LABEL, rowPtr);\n  CreateManagedInfoInRow(\n      rowPtr, GetResourceString(IDS_SETTINGS_SEARCH_ENGINES_MANAGED));\n  UpdateManagedRow(rowPtr, prefs::kAccessibilityFocusHighlightEnabled,\n                   std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE});\n\n  PrefObserve(prefs::kAccessibilityFocusHighlightEnabled,\n              base::BindRepeating(\n                  &UpdateRow, rowPtr,\n                  std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n\n  // Section Row -- Page Zoom\n  // Duplicated in accessibility and appearance pages.\n  BuildZoomSelectRow(section, \"\" /*icon */);\n\n  // Page colors Section\n  // Duplicated in accessibility and appearance pages.\n  BuildColorsThemesSection(\n      section, mojom::SettingsPageIds::PageColorsSitesBlocklistAccessibility,\n      mojom::SettingsPageIds::Accessibility);\n\n  PageColorAccessibilityBlocklistPageDataProvider();\n\n  // Section Row -- Open caption preferences.\n  rowPtr = CreateActionButtonRowInSection(\n      section, mojom::FormControlIds::AccessibilityVisibilityCaption);\n  RegisterSearchableString(\n      section, &(rowPtr->title),\n      IDS_SETTINGS_ACCESSIBILITY_VISIBILITY_OPEN_CAPTION_PREFERENCE_LABEL,\n      rowPtr);\n\n  // Section Row -- Turn off custom scrollbars toggle.\n  rowPtr = CreateToggleRowInSection(\n      section, mojom::FormControlIds::AccessibilityVisibilityCustomScrollbar);\n  RegisterSearchableString(\n      section, &(rowPtr->title),\n      IDS_SETTINGS_PREFERS_DEFAULT_SCROLLBAR_STYLES_TOGGLE_LABEL, rowPtr);\n  RegisterSearchableString(\n      section, &(rowPtr->description),\n      IDS_SETTINGS_ACCESSIBILITY_VISIBILITY_SCROLLBAR_STYLES_TOGGLE_SUBLABEL,\n      rowPtr);\n  PrefObserve(prefs::kPrefersDefaultScrollbarStyles,\n              base::BindRepeating(\n                  &UpdateRow, rowPtr,\n                  std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n}","pos":-1,"query":"BuildAccessibilitySettingsSection","filepos":-1,"timecost":1037.017899999999,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_wallet\\express_checkout\\wallet_popup_row_content_view.cc:277-307","function":"WalletPopupRowContentView::GetCardIconView","codesnippet":"{\n  std::string icon_str(\n      autofill::ConvertIconToPrintableString(suggestion_.icon));\n  SkColor color = gfx::kGoogleGrey200;\n  if (color_provider_) {\n    color = color_provider_->GetColor(kColorEdgeAutofillItemPrimaryForeground);\n  }\n  auto icon_view = autofill::CreateVectorIconForCardNetworkV2(icon_str, color);\n  if (data_container && data_container->card_art_url.is_valid()) {\n    autofill::PersonalDataManager* personal_data_manager =\n        controller_->GetPersonalDataManager();\n\n    const gfx::Image* card_art_image =\n        personal_data_manager->payments_data_manager()\n            .GetCachedCardArtImageForUrl(data_container->card_art_url);\n\n    if (card_art_image && !card_art_image->IsEmpty()) {\n      const gfx::ImageSkia* image_skia = card_art_image->ToImageSkia();\n      if (image_skia && !image_skia->isNull()) {\n        auto resized_image = gfx::ImageSkiaOperations::CreateResizedImage(\n            *image_skia, skia::ImageOperations::ResizeMethod::RESIZE_BEST,\n            kPaymentIconSize);\n        icon_view = std::make_unique<views::ImageView>();\n        icon_view->SetImage(ui::ImageModel::FromImageSkia(resized_image));\n        icon_view->SetVerticalAlignment(\n            views::ImageViewBase::Alignment::kLeading);\n      }\n    }\n  }\n  return icon_view;\n}","pos":4,"query":"CreateCardNetworkIconView","filepos":4,"timecost":1206.8589999999967,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\performance_manager\\user_tuning\\battery_saver_mode_manager.cc:276-307","function":"unknown","codesnippet":"{\n    BatterySaverModeState state = performance_manager::user_tuning::prefs::\n        GetCurrentBatterySaverModeState(pref_change_registrar_.prefs());\n\n    bool previously_enabled = battery_saver_mode_enabled_;\n\n    battery_saver_mode_enabled_ = false;\n\n    if (!battery_saver_mode_disabled_for_session_) {\n      switch (state) {\n        case BatterySaverModeState::kEnabled:\n          battery_saver_mode_enabled_ = true;\n          break;\n        case BatterySaverModeState::kEnabledOnBattery:\n          battery_saver_mode_enabled_ = on_battery_power_;\n          break;\n        case BatterySaverModeState::kEnabledBelowThreshold:\n          battery_saver_mode_enabled_ =\n              on_battery_power_ && is_below_low_battery_threshold_;\n          break;\n        default:\n          battery_saver_mode_enabled_ = false;\n          break;\n      }\n    }\n\n    // Don't change throttling or notify observers if the mode didn't change.\n    if (previously_enabled == battery_saver_mode_enabled_) {\n      return;\n    }\n\n    manager_->NotifyOnBatterySaverActiveChanged(battery_saver_mode_enabled_);\n  }","pos":0,"query":"UpdateBatterySaverModeState","filepos":0,"timecost":839.0879000000023,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\settings\\settings_utils_linux.cc:106-158","function":"DetectAndStartProxyConfigUtil","codesnippet":"{\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n  std::unique_ptr<base::Environment> env(base::Environment::Create());\n\n  bool launched = false;\n  switch (base::nix::GetDesktopEnvironment(env.get())) {\n    case base::nix::DESKTOP_ENVIRONMENT_CINNAMON:\n      launched = StartProxyConfigUtil(kCinnamonProxyConfigCommand);\n      break;\n    case base::nix::DESKTOP_ENVIRONMENT_DEEPIN:\n      launched = StartProxyConfigUtil(kDeepinProxyConfigCommand);\n      break;\n    case base::nix::DESKTOP_ENVIRONMENT_GNOME:\n    case base::nix::DESKTOP_ENVIRONMENT_PANTHEON:\n    case base::nix::DESKTOP_ENVIRONMENT_UKUI:\n    case base::nix::DESKTOP_ENVIRONMENT_UNITY: {\n      launched = StartProxyConfigUtil(kGNOME2ProxyConfigCommand);\n      if (!launched) {\n        // We try this second, even though it's the newer way, because this\n        // command existed in older versions of GNOME, but it didn't do the\n        // same thing. The older command is gone though, so this should do\n        // the right thing. (Also some distributions have blurred the lines\n        // between GNOME 2 and 3, so we can't necessarily detect what the\n        // right thing is based on indications of which version we have.)\n        launched = StartProxyConfigUtil(kGNOME3ProxyConfigCommand);\n      }\n      break;\n    }\n\n    case base::nix::DESKTOP_ENVIRONMENT_KDE3:\n      launched = StartProxyConfigUtil(kKDE3ProxyConfigCommand);\n      break;\n\n    case base::nix::DESKTOP_ENVIRONMENT_KDE4:\n      launched = StartProxyConfigUtil(kKDE4ProxyConfigCommand);\n      break;\n\n    case base::nix::DESKTOP_ENVIRONMENT_KDE5:\n      launched = StartProxyConfigUtil(kKDE5ProxyConfigCommand);\n      break;\n\n    case base::nix::DESKTOP_ENVIRONMENT_KDE6:\n      launched = StartProxyConfigUtil(kKDE6ProxyConfigCommand);\n      break;\n\n    case base::nix::DESKTOP_ENVIRONMENT_XFCE:\n    case base::nix::DESKTOP_ENVIRONMENT_LXQT:\n    case base::nix::DESKTOP_ENVIRONMENT_OTHER:\n      break;\n  }\n\n  return launched;\n}","pos":-1,"query":"launchProxyConfigForDesktopEnvironment","filepos":0,"timecost":936.0986000000012,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\sync_file_system\\sync_status_code.cc:155-196","function":"SyncStatusCodeToFileError","codesnippet":"{\n  switch (status) {\n    case SYNC_STATUS_OK:\n      return base::File::FILE_OK;\n    case SYNC_FILE_ERROR_FAILED:\n      return base::File::FILE_ERROR_FAILED;\n    case SYNC_FILE_ERROR_IN_USE:\n      return base::File::FILE_ERROR_IN_USE;\n    case SYNC_FILE_ERROR_EXISTS:\n      return base::File::FILE_ERROR_EXISTS;\n    case SYNC_FILE_ERROR_NOT_FOUND:\n      return base::File::FILE_ERROR_NOT_FOUND;\n    case SYNC_FILE_ERROR_ACCESS_DENIED:\n      return base::File::FILE_ERROR_ACCESS_DENIED;\n    case SYNC_FILE_ERROR_TOO_MANY_OPENED:\n      return base::File::FILE_ERROR_TOO_MANY_OPENED;\n    case SYNC_FILE_ERROR_NO_MEMORY:\n      return base::File::FILE_ERROR_NO_MEMORY;\n    case SYNC_FILE_ERROR_NO_SPACE:\n      return base::File::FILE_ERROR_NO_SPACE;\n    case SYNC_FILE_ERROR_NOT_A_DIRECTORY:\n      return base::File::FILE_ERROR_NOT_A_DIRECTORY;\n    case SYNC_FILE_ERROR_INVALID_OPERATION:\n      return base::File::FILE_ERROR_INVALID_OPERATION;\n    case SYNC_FILE_ERROR_SECURITY:\n      return base::File::FILE_ERROR_SECURITY;\n    case SYNC_FILE_ERROR_ABORT:\n      return base::File::FILE_ERROR_ABORT;\n    case SYNC_FILE_ERROR_NOT_A_FILE:\n      return base::File::FILE_ERROR_NOT_A_FILE;\n    case SYNC_FILE_ERROR_NOT_EMPTY:\n      return base::File::FILE_ERROR_NOT_EMPTY;\n    case SYNC_FILE_ERROR_INVALID_URL:\n      return base::File::FILE_ERROR_INVALID_URL;\n    case SYNC_FILE_ERROR_IO:\n      return base::File::FILE_ERROR_IO;\n    default:\n      // Return the value as is, so that caller may be able to\n      // restore the information.\n      return static_cast<base::File::Error>(status);\n  }\n}","pos":-1,"query":"mapSyncStatusToFileError","filepos":131,"timecost":1602.1523000000016,"filemrr":0.5},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_consumer\\consumer_push_service.cc:44-79","function":"ConsumerPushService::ConsumerPushService","codesnippet":"{\n  if (profile) {\n    push_service_ =\n        edge::PushProfileServiceFactory::GetForBrowserContext(profile)\n            ->GetPushService();\n    DCHECK(pref_service_);\n#if !BUILDFLAG(IS_ANDROID)\n    hub_notification_store_ =\n        hub_utils::GetNotificationStoreForProfile(profile_);\n    if (!hub_notification_store_) {\n      VLOG(1) << \"[E-tree]: hub_notification_store_ is nullptr.\";\n    }\n\n    url_loader_factory_ = profile->GetDefaultStoragePartition()\n                              ->GetURLLoaderFactoryForBrowserProcess();\n#endif\n\n    identity_manager_ = IdentityManagerFactory::GetForProfile(profile_);\n    DCHECK(identity_manager_);\n    if (identity_manager_) {\n      identity_manager_->AddObserver(this);\n    }\n  }\n\n  if (pref_service_) {\n#if !BUILDFLAG(IS_ANDROID)\n    bool eTreeRegistered = pref_service_->GetBoolean(prefs::kETreeRegistered);\n    if (eTreeRegistered) {\n      Register(edge::wns::PushEventHandlerId::E_TREE);\n    }\n#endif\n  }\n}","pos":-1,"query":"Initialize services and register push event handler","filepos":-1,"timecost":1041.5169000000024,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\net\\dns_probe_service_factory.cc:279-314","function":"DnsProbeServiceImpl::EvaluateResults","codesnippet":"{\n  // If the current DNS config is working, assume the domain doesn't exist.\n  if (current_config_result == DnsProbeRunner::CORRECT)\n    return error_page::DNS_PROBE_FINISHED_NXDOMAIN;\n\n  // If the current DNS config is unknown (e.g. on Android), but Google DNS is\n  // reachable, assume the domain doesn't exist.\n  if (current_config_result == DnsProbeRunner::UNKNOWN &&\n      google_config_result == DnsProbeRunner::CORRECT) {\n    return error_page::DNS_PROBE_FINISHED_NXDOMAIN;\n  }\n\n  // If the current DNS config is not working but Google DNS is, assume the DNS\n  // config is bad (or perhaps the DNS servers are down or broken). If the\n  // current DNS config is in secure mode, return an error indicating that this\n  // is a secure DNS config issue.\n  if (google_config_result == DnsProbeRunner::CORRECT) {\n    return (current_config_secure_dns_mode_ == net::SecureDnsMode::kSecure)\n               ? error_page::DNS_PROBE_FINISHED_BAD_SECURE_CONFIG\n               : error_page::DNS_PROBE_FINISHED_BAD_CONFIG;\n  }\n\n  // If the current DNS config is not working and Google DNS is unreachable,\n  // assume the internet connection is down (note that current DNS may be a\n  // router on the LAN, so it may be reachable but returning errors.)\n  if (google_config_result == DnsProbeRunner::UNREACHABLE)\n    return error_page::DNS_PROBE_FINISHED_NO_INTERNET;\n\n  // Otherwise: the current DNS config is not working and Google DNS is\n  // responding but with errors or incorrect results.  This is an awkward case;\n  // an invasive captive portal or a restrictive firewall may be intercepting\n  // or rewriting DNS traffic, or the public server may itself be failing or\n  // down.\n  return error_page::DNS_PROBE_FINISHED_INCONCLUSIVE;\n}","pos":-1,"query":"determineDnsProbeErrorType","filepos":-1,"timecost":2824.1558000000005,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_smart_switch\\smart_switch_notification_view.cc:69-115","function":"SmartSwitchNotificationView::CreateAndShowSmartSwitchNotificationView","codesnippet":"{\n  auto* toolbar_button_provider =\n      BrowserView::GetBrowserViewForBrowser(browser.get())\n          ->toolbar_button_provider();\n  auto* anchor_view = toolbar_button_provider->GetAnchorView(std::nullopt);\n  if (!browser || !anchor_view) {\n    return;\n  }\n  auto popup = base::WrapUnique(new SmartSwitchNotificationView(\n      is_work_profile, browser.get(), anchor_view, undo_profile_image,\n      undo_profile_name, std::move(link_clicked_callback),\n      base::NullCallback()));\n\n  // The notification auto dismisses when a tab is moved out of a Browser. This\n  // button highlight might not work if we decide to allow the notification to\n  // continue showing on the new browser.\n  if (highlighted_button) {\n    popup->SetHighlightedButton(highlighted_button.get());\n  }\n\n  auto weak_ptr = popup->weak_ptr_factory_.GetWeakPtr();\n  auto* popup_ptr = popup.get();\n  views::Widget* bubble_widget =\n      views::BubbleDialogDelegateView::CreateBubble(std::move(popup));\n  *view = popup_ptr;\n  *primary_button = popup_ptr->accept_button_;\n  primary_button_callback =\n      base::BindRepeating(&SmartSwitchNotificationView::CloseButtonPressed,\n                          popup_ptr->weak_ptr_factory_.GetWeakPtr());\n  *secondary_button = popup_ptr->undo_button_;\n  secondary_button_callback = std::move(undo_button_callback);\n  bubble_widget->ShowInactive();\n\n  std::move(pop_up_shown).Run(weak_ptr);\n}","pos":258,"query":"showSmartSwitchNotificationPopup","filepos":1,"timecost":1190.6448000000019,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\arc\\accessibility\\arc_accessibility_helper_bridge.cc:244-290","function":"ArcAccessibilityHelperBridge::OnAction","codesnippet":"{\n  DCHECK(data.target_node_id);\n\n  ax::android::AXTreeSourceAndroid* tree_source =\n      tree_tracker_.GetFromTreeId(data.target_tree_id);\n  if (!tree_source)\n    return;\n\n  std::optional<int32_t> window_id = tree_source->window_id();\n  if (!window_id)\n    return;\n\n  const std::optional<ax::android::mojom::AccessibilityActionType> action =\n      ax::android::ConvertToAndroidAction(data.action);\n  if (!action.has_value())\n    return;\n\n  ax::android::mojom::AccessibilityActionDataPtr action_data =\n      ax::android::mojom::AccessibilityActionData::New();\n\n  action_data->node_id = data.target_node_id;\n  action_data->window_id = window_id.value();\n  action_data->action_type = action.value();\n  PopulateActionParameters(data, *action_data);\n\n  if (action ==\n      ax::android::mojom::AccessibilityActionType::GET_TEXT_LOCATION) {\n    action_data->start_index = data.start_index;\n    action_data->end_index = data.end_index;\n    if (!accessibility_helper_instance_.RefreshWithExtraData(\n            std::move(action_data),\n            base::BindOnce(\n                &ArcAccessibilityHelperBridge::OnGetTextLocationDataResult,\n                base::Unretained(this), data))) {\n      OnActionResult(data, false);\n    }\n    return;\n  }\n\n  if (!accessibility_helper_instance_.PerformAction(\n          std::move(action_data),\n          base::BindOnce(&ArcAccessibilityHelperBridge::OnActionResult,\n                         base::Unretained(this), data))) {\n    // TODO(b/146809329): This case should probably destroy all trees.\n    OnActionResult(data, false);\n  }\n}","pos":-1,"query":"PerformAccessibilityActionOnNode","filepos":55,"timecost":1230.630799999999,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\preloading\\prerender\\prerender_manager.cc:191-261","function":"PrerenderManager::StartPrerenderBookmark","codesnippet":"{\n  // Helpers to create content::PreloadingAttempt.\n  auto* preloading_data =\n      content::PreloadingData::GetOrCreateForWebContents(web_contents());\n  content::PreloadingURLMatchCallback same_url_matcher =\n      content::PreloadingData::GetSameURLMatcher(prerendering_url);\n\n  if (IsSearchUrl(*web_contents(), prerendering_url)) {\n    base::UmaHistogramBoolean(\n        internal::kHistogramPrerenderBookmarkBarIsPrerenderingSrpUrl, true);\n    return nullptr;\n  }\n\n  base::UmaHistogramBoolean(\n      internal::kHistogramPrerenderBookmarkBarIsPrerenderingSrpUrl, false);\n  // Create new PreloadingAttempt and pass all the values corresponding to\n  // this prerendering attempt for Prerender.\n  content::PreloadingAttempt* preloading_attempt =\n      preloading_data->AddPreloadingAttempt(\n          chrome_preloading_predictor::kMouseHoverOrMouseDownOnBookmarkBar,\n          content::PreloadingType::kPrerender, std::move(same_url_matcher),\n          web_contents()->GetPrimaryMainFrame()->GetPageUkmSourceId());\n\n  // BookmarkBar only allows https protocol.\n  // TODO(crbug.com/40259793): Add an enum metric to report the protocol scheme\n  // to decide if we should loosen this restriction for the http scheme.\n  if (!prerendering_url.SchemeIs(\"https\")) {\n    preloading_attempt->SetEligibility(\n        content::PreloadingEligibility::kHttpsOnly);\n    return nullptr;\n  }\n\n  if (bookmark_prerender_handle_) {\n    if (bookmark_prerender_handle_->GetInitialPrerenderingUrl() ==\n        prerendering_url) {\n      // In case a prerender is already present for the URL, prerendering is\n      // eligible but mark triggering outcome as a duplicate.\n      preloading_attempt->SetEligibility(\n          content::PreloadingEligibility::kEligible);\n\n      MarkPreloadingAttemptAsDuplicate(preloading_attempt);\n      return bookmark_prerender_handle_->GetWeakPtr();\n    }\n    bookmark_prerender_handle_.reset();\n  }\n\n  base::RepeatingCallback<void(content::NavigationHandle&)>\n      prerender_navigation_handle_callback =\n          base::BindRepeating(&AttachBookmarkBarNavigationHandleUserData);\n\n  bookmark_prerender_handle_ = web_contents()->StartPrerendering(\n      prerendering_url, content::PreloadingTriggerType::kEmbedder,\n      prerender_utils::kBookmarkBarMetricSuffix,\n      /*additional_headers=*/net::HttpRequestHeaders(),\n      /*no_vary_search_hint=*/std::nullopt,\n      ui::PageTransitionFromInt(ui::PAGE_TRANSITION_AUTO_BOOKMARK),\n      // Considering the characteristics of triggers (e.g., the duration from\n      // trigger to activation), warm-up is not enabled for now on this trigger.\n      // Please see crbug and its doc for more details.\n      /*should_warm_up_compositor=*/false,\n      /*should_prepare_paint_tree=*/false,\n      content::PreloadingHoldbackStatus::kUnspecified,\n      content::PreloadPipelineInfo::Create(\n          /*planned_max_preloading_type=*/content::PreloadingType::kPrerender),\n      preloading_attempt,\n      /*url_match_predicate=*/{},\n      std::move(prerender_navigation_handle_callback));\n\n  return bookmark_prerender_handle_ ? bookmark_prerender_handle_->GetWeakPtr()\n                                    : nullptr;\n}","pos":-1,"query":"Bookmark bar URL prerendering handler","filepos":-1,"timecost":677.0288,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\autofill\\payments\\bnpl_tos_dialog.cc:34-109","function":"BnplTosDialog::BnplTosDialog","codesnippet":"{\n  // Set the ownership of the delegate, not the View. The View is owned by the\n  // Widget as a child view.\n  // TODO(crbug.com/338254375): Remove the following line once this is the\n  // default state for widgets.\n  SetOwnershipOfNewWidget(views::Widget::InitParams::CLIENT_OWNS_WIDGET);\n  SetAcceptCallbackWithClose(\n      base::BindRepeating(&BnplTosDialog::OnAccepted, base::Unretained(this)));\n  SetCancelCallbackWithClose(\n      base::BindRepeating(&BnplTosDialog::OnCancelled, base::Unretained(this)));\n\n  ChromeLayoutProvider* chrome_layout_provider = ChromeLayoutProvider::Get();\n\n  SetModalType(ui::mojom::ModalType::kChild);\n  set_fixed_width(chrome_layout_provider->GetDistanceMetric(\n      views::DISTANCE_MODAL_DIALOG_PREFERRED_WIDTH));\n  set_margins(chrome_layout_provider->GetDialogInsetsForContentType(\n      views::DialogContentType::kControl, views::DialogContentType::kControl));\n  SetShowCloseButton(false);\n  SetButtonStyle(ui::mojom::DialogButton::kCancel, ui::ButtonStyle::kDefault);\n  SetButtonLabel(ui::mojom::DialogButton::kOk, controller_->GetOkButtonLabel());\n  SetButtonLabel(ui::mojom::DialogButton::kCancel,\n                 controller_->GetCancelButtonLabel());\n  SetLayoutManager(std::make_unique<BoxLayout>());\n\n  container_view_ = AddChildView(std::make_unique<views::View>());\n  container_view_->SetUseDefaultFillLayout(true);\n\n  content_view_ =\n      container_view_->AddChildView(std::make_unique<BoxLayoutView>());\n  content_view_->SetOrientation(BoxLayout::Orientation::kVertical);\n  content_view_->SetBetweenChildSpacing(\n      chrome_layout_provider->GetDistanceMetric(\n          views::DISTANCE_UNRELATED_CONTROL_VERTICAL));\n\n  content_view_->AddChildView(CreateTextWithIconView(\n      controller_->GetReviewText(), /*text_link_info=*/std::nullopt,\n      vector_icons::kChecklistIcon));\n\n  content_view_->AddChildView(CreateTextWithIconView(\n      controller_->GetApproveText(), /*text_link_info=*/std::nullopt,\n      vector_icons::kReceiptLongIcon));\n\n  TextWithLink link_text = controller_->GetLinkText();\n  TextLinkInfo link_info;\n  link_info.offset = link_text.offset;\n  link_info.callback = base::BindRepeating(link_opener_, link_text.url);\n  content_view_->AddChildView(CreateTextWithIconView(\n      link_text.text, std::move(link_info), vector_icons::kAddLinkIcon));\n\n  content_view_->AddChildView(std::make_unique<views::Separator>())\n      ->SetProperty(\n          views::kMarginsKey,\n          gfx::Insets().set_top(ChromeLayoutProvider::Get()->GetDistanceMetric(\n              DISTANCE_CONTENT_LIST_VERTICAL_MULTI)));\n\n  content_view_->AddChildView(CreateLegalMessageView(\n      controller_->GetLegalMessageLines(),\n      base::UTF8ToUTF16(controller_->GetAccountInfo().email),\n      GetProfileAvatar(controller_->GetAccountInfo()), link_opener_));\n\n  throbber_view_ =\n      container_view_->AddChildView(std::make_unique<BoxLayoutView>());\n  throbber_view_->SetVisible(false);\n  throbber_view_->SetMainAxisAlignment(\n      views::BoxLayout::MainAxisAlignment::kCenter);\n  throbber_view_->SetCrossAxisAlignment(BoxLayout::CrossAxisAlignment::kCenter);\n  throbber_ = throbber_view_->AddChildView(\n      std::make_unique<views::Throbber>(kDialogThrobberDiameter));\n  throbber_->SetProperty(views::kElementIdentifierKey,\n                         BnplTosDialog::kThrobberId);\n  throbber_->GetViewAccessibility().AnnouncePolitely(l10n_util::GetStringUTF16(\n      IDS_AUTOFILL_BNPL_PROGRESS_DIALOG_LOADING_MESSAGE));\n}","pos":0,"query":"Initialize BNPL Terms of Service dialog.","filepos":0,"timecost":996.3842999999979,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\signin\\managed_user_profile_notice_ui.cc:401-466","function":"ManagedUserProfileNoticeUI::UpdateBrowsingDataStringWithCounts","codesnippet":"{\n  int browsing_history_count = 0;\n  int bookmarks_count = 0;\n  int extensions_count = 0;\n\n  for (const auto& stat : stats) {\n    if (stat.category == profiles::kProfileStatisticsBrowsingHistory) {\n      browsing_history_count = stat.count;\n    } else if (stat.category == profiles::kProfileStatisticsBookmarks) {\n      bookmarks_count = stat.count;\n    }\n  }\n  auto* profile = Profile::FromWebUI(web_ui());\n  auto* registry = extensions::ExtensionRegistry::Get(profile);\n  extensions_count = registry->enabled_extensions().size() +\n                     registry->disabled_extensions().size() +\n                     registry->terminated_extensions().size() +\n                     registry->blocklisted_extensions().size() +\n                     registry->blocked_extensions().size();\n\n  std::vector<std::u16string> string_replacements;\n  if (bookmarks_count > 0) {\n    string_replacements.push_back(\n        l10n_util::GetPluralStringFUTF16(IDS_BOOKMARKS_COUNT, bookmarks_count));\n  }\n  if (extensions_count > 0) {\n    string_replacements.push_back(l10n_util::GetPluralStringFUTF16(\n        IDS_EXTENSIONS_COUNT, extensions_count));\n  }\n  if (browsing_history_count > 0) {\n    string_replacements.push_back(l10n_util::GetPluralStringFUTF16(\n        IDS_BROWSING_HISTORY_COUNT, browsing_history_count));\n  }\n\n  if (string_replacements.empty()) {\n    return;\n  }\n\n  base::Value::Dict update_data;\n  std::u16string browsing_data_string;\n  if (string_replacements.size() == 1) {\n    update_data.Set(\n        \"mergeBrowsingDataChoiceDetails\",\n        l10n_util::GetStringFUTF16(\n            IDS_ENTERPRISE_WELCOME_MERGE_BROWSING_DATA_WITH_ONE_COUNT_CHOICE_DETAILS,\n            string_replacements, nullptr));\n  }\n  if (string_replacements.size() == 2) {\n    update_data.Set(\n        \"mergeBrowsingDataChoiceDetails\",\n        l10n_util::GetStringFUTF16(\n            IDS_ENTERPRISE_WELCOME_MERGE_BROWSING_DATA_WITH_TWO_COUNTS_CHOICE_DETAILS,\n            string_replacements, nullptr));\n  }\n  if (string_replacements.size() == 3) {\n    update_data.Set(\n        \"mergeBrowsingDataChoiceDetails\",\n        l10n_util::GetStringFUTF16(\n            IDS_ENTERPRISE_WELCOME_MERGE_BROWSING_DATA_WITH_THREE_COUNTS_CHOICE_DETAILS,\n            string_replacements, nullptr));\n  }\n\n  content::WebUIDataSource::Update(\n      profile, chrome::kChromeUIManagedUserProfileNoticeHost,\n      std::move(update_data));\n}","pos":-1,"query":"UpdateProfileStatisticsSummary","filepos":-1,"timecost":1539.6673999999985,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\processes\\processes_api.cc:73-116","function":"GetProcessType","codesnippet":"{\n  switch (task_type) {\n    case task_manager::Task::BROWSER:\n      return api::processes::ProcessType::kBrowser;\n\n    case task_manager::Task::RENDERER:\n      return api::processes::ProcessType::kRenderer;\n\n    case task_manager::Task::EXTENSION:\n    case task_manager::Task::GUEST:\n      return api::processes::ProcessType::kExtension;\n\n    case task_manager::Task::PLUGIN:\n      return api::processes::ProcessType::kPlugin;\n\n    case task_manager::Task::NACL:\n      return api::processes::ProcessType::kNacl;\n\n    // TODO(crbug.com/40117341): Assign a different process type for each\n    //                                  worker type.\n    case task_manager::Task::DEDICATED_WORKER:\n    case task_manager::Task::SHARED_WORKER:\n      return api::processes::ProcessType::kWorker;\n\n    case task_manager::Task::SERVICE_WORKER:\n      return api::processes::ProcessType::kServiceWorker;\n\n    case task_manager::Task::UTILITY:\n      return api::processes::ProcessType::kUtility;\n\n    case task_manager::Task::GPU:\n      return api::processes::ProcessType::kGpu;\n\n    case task_manager::Task::UNKNOWN:\n    case task_manager::Task::ARC:\n    case task_manager::Task::CROSTINI:\n    case task_manager::Task::PLUGIN_VM:\n    case task_manager::Task::SANDBOX_HELPER:\n    case task_manager::Task::ZYGOTE:\n      return api::processes::ProcessType::kOther;\n  }\n\n  NOTREACHED() << \"Unknown task type.\";\n}","pos":-1,"query":"mapTaskTypeToProcessType","filepos":-1,"timecost":1594.1820000000007,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\media_preview\\camera_preview\\camera_coordinator.cc:110-155","function":"CameraCoordinator::OnVideoSourceChanged","codesnippet":"{\n  if (!selected_index.has_value()) {\n    return;\n  }\n\n  const auto& device_info = eligible_device_infos_.at(selected_index.value());\n  if (active_device_id_ == device_info.descriptor.device_id) {\n    return;\n  }\n\n  active_device_id_ = device_info.descriptor.device_id;\n  mojo::Remote<video_capture::mojom::VideoSource> video_source;\n  camera_mediator_.BindVideoSource(active_device_id_,\n                                   video_source.BindNewPipeAndPassReceiver());\n\n#if BUILDFLAG(ENABLE_VIDEO_EFFECTS)\n  if (base::FeatureList::IsEnabled(media::kCameraMicEffects) &&\n      browser_context_) {\n    if (blur_switch_view_controller_) {\n      blur_switch_view_controller_->BindVideoEffectsManager(active_device_id_);\n    }\n\n    // TODO: Consider moving this to `CameraMediator` when the code becomes more\n    // permanent.\n    mojo::PendingRemote<video_effects::mojom::VideoEffectsProcessor>\n        video_effects_processor;\n    mojo::PendingRemote<media::mojom::ReadonlyVideoEffectsManager>\n        readonly_video_effects_manager;\n\n    media_effects::BindVideoEffectsProcessor(\n        active_device_id_, browser_context_.get(),\n        video_effects_processor.InitWithNewPipeAndPassReceiver());\n    video_source->RegisterVideoEffectsProcessor(\n        std::move(video_effects_processor));\n\n    media_effects::BindReadonlyVideoEffectsManager(\n        active_device_id_, browser_context_.get(),\n        readonly_video_effects_manager.InitWithNewPipeAndPassReceiver());\n    video_source->RegisterReadonlyVideoEffectsManager(\n        std::move(readonly_video_effects_manager));\n  }\n#endif\n\n  video_stream_coordinator_->ConnectToDevice(device_info,\n                                             std::move(video_source));\n}","pos":-1,"query":"Switches active video capture device","filepos":-1,"timecost":877.7638999999981,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\media\\router\\media_router_feature.cc:131-179","function":"MediaRouterEnabled","codesnippet":"{\n#if MICROSOFT_EDGE_BUILD\n#if BUILDFLAG(EDGE_ANDROID_WEBVIEW_PRO_BUILD)\n  if (edge_android_webview::IsRunningInWebviewPro()) {\n    return false;\n  }\n#endif  // BUILDFLAG(EDGE_ANDROID_WEBVIEW_PRO_BUILD)\n#if BUILDFLAG(IS_WIN)\n  if (base::win::IsXboxSku())\n    return false;\n#endif\n  // On Edge WebView2, we do not support media router extension\n  // and block browser UI for casting, such as context menu item.\n  if (edge_webview2::IsEdgeWebViewProcess())\n    return false;\n#endif  // MICROSOFT_EDGE_BUILD\n\n#if !BUILDFLAG(IS_ANDROID)\n  if (!base::FeatureList::IsEnabled(kMediaRouter)) {\n    return false;\n  }\n#endif  // !BUILDFLAG(IS_ANDROID)\n#if BUILDFLAG(IS_CHROMEOS)\n  // TODO(crbug.com/1380828): Make the Media Router feature configurable via a\n  // policy for non-user profiles, i.e. sign-in and lock screen profiles.\n  if (!ash::IsUserBrowserContext(context)) {\n    return false;\n  }\n#endif  // BUILDFLAG(IS_CHROMEOS)\n\n  // If the Media Router was already enabled or disabled for |context|, then it\n  // must remain so.  The Media Router does not support dynamic\n  // enabling/disabling.\n  base::flat_map<content::BrowserContext*, bool>& pref_values =\n      GetStoredPrefValues();\n  auto const it = pref_values.find(context);\n  if (it != pref_values.end()) {\n    return it->second;\n  }\n\n  // Check the enterprise policy.\n  const PrefService::Preference* pref = GetMediaRouterPref(context);\n  if (pref->IsManaged() && !pref->IsDefaultValue()) {\n    CHECK(pref->GetValue()->is_bool());\n    bool allowed = pref->GetValue()->GetBool();\n    pref_values.insert(std::make_pair(context, allowed));\n    return allowed;\n  }\n  return true;\n}","pos":0,"query":"mediaRouterFeatureAvailabilityCheck","filepos":0,"timecost":655.3606,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\accessibility\\ax_main_node_annotator_controller.cc:77-118","function":"AXMainNodeAnnotatorController::OnActivationChanged","codesnippet":"{\n  const bool is_activated =\n      activated_ && profile_->GetPrefs()->GetBoolean(\n                        prefs::kAccessibilityMainNodeAnnotationsEnabled);\n\n  if (is_activated == IsEnabled()) {\n    return;  // No change in activation.\n  }\n\n  if (is_activated) {\n    if (!service_ready_) {\n      // Avoid repeated requests.\n      if (waiting_for_service_initialization_) {\n        return;\n      }\n      waiting_for_service_initialization_ = true;\n\n      if (ScreenAIInstallState::GetInstance()->get_state() !=\n              ScreenAIInstallState::State::kDownloaded &&\n          !component_ready_observer_.IsObserving()) {\n        // Start observing ScreenAIInstallState to report it to user.\n        component_ready_observer_.Observe(ScreenAIInstallState::GetInstance());\n      }\n\n      screen_ai::ScreenAIServiceRouterFactory::GetForBrowserContext(profile_)\n          ->GetServiceStateAsync(\n              ScreenAIServiceRouter::Service::kMainContentExtraction,\n              base::BindOnce(\n                  &AXMainNodeAnnotatorController::\n                      MainNodeExtractionServiceInitializationCallback,\n                  weak_ptr_factory_.GetWeakPtr()));\n      return;\n    }\n\n    // This will send the `kAnnotateMainNode` flag to all WebContents.\n    scoped_accessibility_mode_ =\n        content::BrowserAccessibilityState::GetInstance()\n            ->CreateScopedModeForBrowserContext(profile_,\n                                                ui::AXMode::kAnnotateMainNode);\n  } else {\n    scoped_accessibility_mode_.reset();\n  }\n}","pos":-1,"query":"Toggle main node annotation feature","filepos":-1,"timecost":1520.815999999999,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\ash\\arc\\arc_open_url_delegate_impl.cc:239-317","function":"ArcOpenUrlDelegateImpl::OpenWebAppFromArc","codesnippet":"{\n  DCHECK(url.is_valid() && url.SchemeIs(url::kHttpsScheme));\n\n  // Fetch the profile associated with ARC. This method should only be called\n  // for a |url| which was installed via ARC, and so we want the web app that is\n  // opened through here to be installed in the profile associated with ARC.\n  // |user| may be null if sign-in hasn't happened yet\n  const auto* user = user_manager::UserManager::Get()->GetPrimaryUser();\n  if (!user) {\n    return;\n  }\n\n  // `profile` may be null if sign-in has happened but the profile isn't loaded\n  // yet.\n  Profile* profile = ash::ProfileHelper::Get()->GetProfileByUser(user);\n  if (!profile) {\n    return;\n  }\n\n  std::optional<webapps::AppId> app_id =\n      web_app::FindInstalledAppWithUrlInScope(profile, url,\n                                              /*window_only=*/true);\n\n  if (!app_id) {\n    OpenUrlFromArc(url);\n    return;\n  }\n\n  int event_flags = apps::GetEventFlags(WindowOpenDisposition::NEW_WINDOW,\n                                        /*prefer_container=*/false);\n  apps::AppServiceProxy* proxy =\n      apps::AppServiceProxyFactory::GetForProfile(profile);\n\n  proxy->AppRegistryCache().ForOneApp(\n      *app_id, [&event_flags](const apps::AppUpdate& update) {\n        if (update.WindowMode() == apps::WindowMode::kBrowser) {\n          event_flags =\n              apps::GetEventFlags(WindowOpenDisposition::NEW_FOREGROUND_TAB,\n                                  /*prefer_container=*/false);\n        }\n      });\n\n  proxy->LaunchAppWithUrl(*app_id, event_flags, url,\n                          apps::LaunchSource::kFromArc);\n\n  ash::ApkWebAppService* apk_web_app_service =\n      ash::ApkWebAppService::Get(profile);\n  if (!apk_web_app_service ||\n      !apk_web_app_service->IsWebAppInstalledFromArc(app_id.value())) {\n    return;\n  }\n\n  ArcAppListPrefs* prefs = ArcAppListPrefs::Get(profile);\n  if (!prefs) {\n    return;\n  }\n\n  std::optional<std::string> package_name =\n      apk_web_app_service->GetPackageNameForWebApp(app_id.value());\n  if (!package_name.has_value()) {\n    return;\n  }\n\n  ChromeShelfController* chrome_shelf_controller =\n      ChromeShelfController::instance();\n  if (!chrome_shelf_controller) {\n    return;\n  }\n\n  auto* arc_tracker =\n      chrome_shelf_controller->app_service_app_window_controller()\n          ->app_service_arc_tracker();\n  if (!arc_tracker) {\n    return;\n  }\n\n  for (const auto& id : prefs->GetAppsForPackage(package_name.value())) {\n    arc_tracker->CloseWindows(id);\n  }\n}","pos":-1,"query":"Launch or close ARC web app windows","filepos":-1,"timecost":1049.6690000000017,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\arc\\input_overlay\\ui\\name_tag.cc:83-134","function":"NameTag::Init","codesnippet":"{\n  SetLayoutManager(\n      std::make_unique<views::BoxLayout>(\n          for_editing_list_ ? views::BoxLayout::Orientation::kHorizontal\n                            : views::BoxLayout::Orientation::kVertical,\n          gfx::Insets(),\n          /*between_child_spacing=*/for_editing_list_ ? 0 : kHeaderSpacing))\n      ->set_cross_axis_alignment(views::BoxLayout::CrossAxisAlignment::kStart);\n\n  auto title_label = ash::bubble_utils::CreateLabel(\n      ash::TypographyToken::kCrosButton2, u\"\", cros_tokens::kCrosSysOnSurface);\n  auto error_icon =\n      std::make_unique<views::ImageView>(ui::ImageModel::FromVectorIcon(\n          vector_icons::kErrorOutlineIcon, cros_tokens::kCrosSysError,\n          kErrorIconSize));\n\n  if (for_editing_list_) {\n    error_icon_ = AddChildView(std::move(error_icon));\n  } else {\n    title_label_ = AddChildView(std::move(title_label));\n  }\n\n  auto* sub_container = AddChildView(std::make_unique<views::View>());\n  sub_container\n      ->SetLayoutManager(std::make_unique<views::BoxLayout>(\n          for_editing_list_ ? views::BoxLayout::Orientation::kVertical\n                            : views::BoxLayout::Orientation::kHorizontal))\n      ->set_cross_axis_alignment(views::BoxLayout::CrossAxisAlignment::kStart);\n\n  if (for_editing_list_) {\n    title_label_ = sub_container->AddChildView(std::move(title_label));\n  } else {\n    error_icon_ = sub_container->AddChildView(std::move(error_icon));\n  }\n\n  title_label_->SetMultiLine(true);\n  title_label_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n\n  error_icon_->SetProperty(views::kMarginsKey,\n                           gfx::Insets::TLBR(0, 0, 0, kErrorIconSpacing));\n  // Set height to 20 to add extra internal padding for `error_icon_`.\n  error_icon_->SetPreferredSize(gfx::Size(kErrorIconSize, 20));\n  error_icon_->SetVerticalAlignment(views::ImageView::Alignment::kCenter);\n  error_icon_->SetVisible(false);\n\n  subtitle_label_ = sub_container->AddChildView(\n      ash::bubble_utils::CreateLabel(ash::TypographyToken::kCrosAnnotation2,\n                                     u\"\", cros_tokens::kCrosSysSecondary));\n  subtitle_label_->SetEnabledColor(cros_tokens::kCrosSysError);\n  subtitle_label_->SetMultiLine(true);\n  subtitle_label_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  subtitle_label_->SetVisible(false);\n}","pos":-1,"query":"Configure layout and initialize UI components","filepos":-1,"timecost":2035.6411000000007,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\cr_components\\most_visited\\most_visited_handler.cc:276-307","function":"MostVisitedHandler::OnURLsAvailable","codesnippet":"{\n  auto* template_url_service =\n      TemplateURLServiceFactory::GetForProfile(profile_);\n  auto result = most_visited::mojom::MostVisitedInfo::New();\n  std::vector<most_visited::mojom::MostVisitedTilePtr> tiles;\n  for (auto& tile : sections.at(ntp_tiles::SectionType::PERSONALIZED)) {\n    auto value = most_visited::mojom::MostVisitedTile::New();\n    if (tile.title.empty()) {\n      value->title = tile.url.spec();\n      value->title_direction = base::i18n::LEFT_TO_RIGHT;\n    } else {\n      value->title = base::UTF16ToUTF8(tile.title);\n      value->title_direction =\n          base::i18n::GetFirstStrongCharacterDirection(tile.title);\n    }\n    value->url = tile.url;\n    value->source = static_cast<int32_t>(tile.source);\n    value->title_source = static_cast<int32_t>(tile.title_source);\n    value->data_generation_time = tile.data_generation_time;\n    value->is_query_tile =\n        base::FeatureList::IsEnabled(history::kOrganicRepeatableQueries) &&\n        template_url_service &&\n        template_url_service->IsSearchResultsPageFromDefaultSearchProvider(\n            tile.url);\n    tiles.push_back(std::move(value));\n  }\n  result->tiles = std::move(tiles);\n  result->custom_links_enabled = most_visited_sites_->IsCustomLinksEnabled();\n  result->visible = most_visited_sites_->IsShortcutsVisible();\n  page_->SetMostVisitedInfo(std::move(result));\n}","pos":-1,"query":"GenerateMostVisitedTilesInfo","filepos":1,"timecost":2060.4658999999956,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\web_applications\\sub_apps_service_impl.cc:239-288","function":"SubAppsServiceImpl::Add","codesnippet":"{\n  WebAppProvider* provider = GetWebAppProvider(render_frame_host());\n  if (!provider->on_registry_ready().is_signaled()) {\n    provider->on_registry_ready().Post(\n        FROM_HERE,\n        base::BindOnce(&SubAppsServiceImpl::Add, weak_ptr_factory_.GetWeakPtr(),\n                       std::move(sub_apps_to_add), std::move(result_callback)));\n    return;\n  }\n\n  if (!CanAccessSubAppsApi(render_frame_host())) {\n    ReturnAllAddsAsFailed(sub_apps_to_add, std::move(result_callback));\n    return;\n  }\n\n  if (sub_apps_to_add.empty()) {\n    std::move(result_callback).Run({});\n    return;\n  }\n\n  // Check if origin is embargoed because of too many dismissals.\n  if (PermissionDecisionAutoBlockerFactory::GetForProfile(\n          Profile::FromBrowserContext(render_frame_host().GetBrowserContext()))\n          ->IsEmbargoed(render_frame_host().GetLastCommittedOrigin().GetURL(),\n                        ContentSettingsType::SUB_APP_INSTALLATION_PROMPTS)) {\n    ReturnAllAddsAsFailed(sub_apps_to_add, std::move(result_callback));\n    return;\n  }\n\n  ASSIGN_OR_RETURN(\n      (std::vector<SubAppInstallParams> add_options),\n      AddOptionsFromMojo(render_frame_host().GetLastCommittedOrigin(),\n                         sub_apps_to_add),\n      // Compromised renderer, bail immediately (this call deletes *this).\n      &SubAppsServiceImpl::ReportBadMessageAndDeleteThis, this);\n\n  CHECK(AreWebAppsUserInstallable(\n      Profile::FromBrowserContext(render_frame_host().GetBrowserContext())));\n\n  // Assign id to this add call\n  int add_call_id = next_add_call_id_++;\n  AddCallInfo& add_call_info = add_call_info_[add_call_id];\n  add_call_info.mojo_callback = std::move(result_callback);\n\n  auto parent_manifest_id = provider->registrar_unsafe()\n                                .GetAppById(*GetAppId(render_frame_host()))\n                                ->manifest_id();\n  CollectInstallData(add_call_id, std::move(add_options), parent_manifest_id);\n}","pos":186,"query":"Handle sub-app installation requests","filepos":54,"timecost":944.5002000000022,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\engagement\\history_aware_site_engagement_service.cc:43-118","function":"HistoryAwareSiteEngagementService::UpdateEngagementScores","codesnippet":"{\n  // The most in-the-past option in the Clear Browsing Dialog aside from \"all\n  // time\" is 4 weeks ago. Set the last updated date to 4 weeks ago for origins\n  // where we can't find a valid last visit date.\n  base::Time now = clock().Now();\n  base::Time four_weeks_ago = now - base::Days(28);\n\n  HostContentSettingsMap* settings_map =\n      HostContentSettingsMapFactory::GetForProfile(browser_context());\n\n  for (const auto& origin_to_count : remaining_origins) {\n    GURL origin = origin_to_count.first;\n    // It appears that the history service occasionally sends bad URLs to us.\n    // See crbug.com/612881.\n    if (!origin.is_valid())\n      continue;\n\n    int remaining = origin_to_count.second.first;\n    base::Time last_visit = origin_to_count.second.second;\n    int deleted = deleted_origins.count(origin);\n\n    // Do not update engagement scores if the deletion was an expiry, but the\n    // URL still has entries in history.\n    if ((expired && remaining != 0) || deleted == 0)\n      continue;\n\n    // Remove origins that have no urls left.\n    if (remaining == 0) {\n      settings_map->SetWebsiteSettingDefaultScope(\n          origin, GURL(), ContentSettingsType::SITE_ENGAGEMENT, base::Value());\n      continue;\n    }\n\n    // Remove engagement proportional to the urls expired from the origin's\n    // entire history.\n    double proportion_remaining =\n        static_cast<double>(remaining) / (remaining + deleted);\n    if (last_visit.is_null() || last_visit > now)\n      last_visit = four_weeks_ago;\n\n    // At this point, we are going to proportionally decay the origin's\n    // engagement, and reset its last visit date to the last visit to a URL\n    // under the origin in history. If this new last visit date is long enough\n    // in the past, the next time the origin's engagement is accessed the\n    // automatic decay will kick in - i.e. a double decay will have occurred.\n    // To prevent this, compute the decay that would have taken place since the\n    // new last visit and add it to the engagement at this point. When the\n    // engagement is next accessed, it will decay back to the proportionally\n    // reduced value rather than being decayed once here, and then once again\n    // when it is next accessed.\n    // TODO(crbug.com/41308686): Move the proportional decay logic into\n    // SiteEngagementScore, so it can decay raw_score_ directly, without the\n    // double-decay issue.\n    SiteEngagementScore engagement_score = CreateEngagementScore(origin);\n\n    double new_score = proportion_remaining * engagement_score.GetTotalScore();\n    int hours_since_engagement = (now - last_visit).InHours();\n    int periods =\n        hours_since_engagement / SiteEngagementScore::GetDecayPeriodInHours();\n    new_score += periods * SiteEngagementScore::GetDecayPoints();\n    new_score *= pow(1.0 / SiteEngagementScore::GetDecayProportion(), periods);\n\n    double score = std::min(SiteEngagementScore::kMaxPoints, new_score);\n    engagement_score.Reset(score, last_visit);\n    if (!engagement_score.last_shortcut_launch_time().is_null() &&\n        engagement_score.last_shortcut_launch_time() > last_visit) {\n      engagement_score.set_last_shortcut_launch_time(last_visit);\n    }\n\n    engagement_score.Commit();\n  }\n\n  SetLastEngagementTime(now);\n}","pos":37,"query":"Proportionally decays site engagement scores","filepos":24,"timecost":710.2988000000041,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_feedback\\system_logs\\log_sources\\edge_cloud_messaging_log_source.cc:39-73","function":"EdgeCloudMessagingLogSource::GetDiagnosticData","codesnippet":"{\n  base::Value::Dict diagnostics{};\n\n  Profile* profile = ProfileManager::GetLastUsedProfile();\n  if (!profile) {\n    return diagnostics;\n  }\n\n  edge::cloud_messaging::CloudMessagingService* cloud_messaging_service =\n      edge::cloud_messaging::CloudMessagingServiceFactory::GetForProfile(\n          profile);\n  if (cloud_messaging_service) {\n    for (const auto& [key, value] :\n         cloud_messaging_service->GetDiagnosticsManager()->GetValues()) {\n      diagnostics.SetByDottedPath(key, value.printed_value);\n    }\n  }\n\n  // Remove token\n  if (auto* auth_manager_dict = diagnostics.FindDict(\"AuthManager\")) {\n    auth_manager_dict->Remove(\"AccessToken\");\n  }\n\n  if (auto* auth_manager_dict = diagnostics.FindDict(\"NetworkChannel\")) {\n    auth_manager_dict->Remove(\"AuthorizationValue\");\n  }\n\n  if (auto* prefs_manager_dict = diagnostics.FindDict(\"PrefsManager\")) {\n    if (auto* profile_prefs_dict =\n            prefs_manager_dict->FindDict(\"ProfilePrefs\")) {\n      profile_prefs_dict->Remove(\"CachedTargetToken\");\n    }\n  }\n\n  return diagnostics;\n}","pos":-1,"query":"generateDiagnosticsWithoutSensitiveTokens","filepos":-1,"timecost":1843.2939000000042,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\lens\\lens_overlay_image_helper.cc:421-452","function":"ExtractVibrantOrDominantColorFromImage","codesnippet":"{\n  if (image.empty() || image.isNull()) {\n    return SK_ColorTRANSPARENT;\n  }\n\n  min_population_pct = std::clamp(min_population_pct, 0.0f, 1.0f);\n\n  std::vector<color_utils::ColorProfile> profiles;\n  // vibrant color profile\n  profiles.emplace_back(color_utils::LumaRange::ANY,\n                        color_utils::SaturationRange::VIBRANT);\n  // any color profile\n  profiles.emplace_back(color_utils::LumaRange::ANY,\n                        color_utils::SaturationRange::ANY);\n\n  auto vibrantAndDominantColors = color_utils::CalculateProminentColorsOfBitmap(\n      image, profiles, /*region=*/nullptr, color_utils::ColorSwatchFilter());\n\n  for (const auto& swatch : vibrantAndDominantColors) {\n    // Valid color. Extraction failure returns 0 alpha channel.\n    // Population Threshold.\n    if (SkColorGetA(swatch.color) != SK_AlphaTRANSPARENT &&\n        static_cast<float>(swatch.population) >=\n            static_cast<float>(\n                std::min(image.width() * image.height(),\n                         color_utils::kMaxConsideredPixelsForSwatches)) *\n                min_population_pct) {\n      return swatch.color;\n    }\n  }\n  return SK_ColorTRANSPARENT;\n}","pos":1,"query":"extractProminentVibrantColor","filepos":1,"timecost":1328.9021999999968,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\connectors_internals\\connectors_internals_page_handler.cc:146-188","function":"ConnectorsInternalsPageHandler::GetClientCertificateState","codesnippet":"{\n#if BUILDFLAG(ENTERPRISE_CLIENT_CERTIFICATES)\n  auto* profile_certificate_provisioning_service =\n      client_certificates::CertificateProvisioningServiceFactory::GetForProfile(\n          profile_);\n  auto* browser_certificate_provisioning_service =\n      g_browser_process->browser_policy_connector()\n          ->chrome_browser_cloud_management_controller()\n          ->GetCertificateProvisioningService();\n  if (!profile_certificate_provisioning_service &&\n      !browser_certificate_provisioning_service) {\n    std::move(callback).Run(\n        connectors_internals::mojom::ClientCertificateState::New(\n            std::vector<std::string>(), nullptr, nullptr));\n    return;\n  }\n\n  std::vector<std::string> enabled_levels;\n  connectors_internals::mojom::ClientIdentityPtr managed_browser_identity =\n      nullptr;\n  if (browser_certificate_provisioning_service) {\n    managed_browser_identity = GetIdentity(\n        browser_certificate_provisioning_service, enabled_levels, kBrowser);\n  }\n\n  connectors_internals::mojom::ClientIdentityPtr managed_profile_identity =\n      nullptr;\n  if (profile_certificate_provisioning_service) {\n    managed_profile_identity = GetIdentity(\n        profile_certificate_provisioning_service, enabled_levels, kProfile);\n  }\n\n  std::move(callback).Run(\n      connectors_internals::mojom::ClientCertificateState::New(\n          std::move(enabled_levels), std::move(managed_profile_identity),\n          std::move(managed_browser_identity)));\n\n#else\n  std::move(callback).Run(\n      connectors_internals::mojom::ClientCertificateState::New(\n          std::vector<std::string>(), nullptr, nullptr));\n#endif  // BUILDFLAG(ENTERPRISE_CLIENT_CERTIFICATES)\n}","pos":-1,"query":"Determine client certificate provisioning state","filepos":-1,"timecost":908.4223999999958,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\predictors\\resource_prefetch_predictor.cc:347-400","function":"ResourcePrefetchPredictor::PredictPreconnectOrigins","codesnippet":"{\n  DCHECK(!prediction || prediction->requests.empty());\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (initialization_state_ != INITIALIZED)\n    return false;\n\n  url::Origin url_origin = url::Origin::Create(url);\n  url::Origin redirect_origin;\n  bool has_any_prediction = GetRedirectEndpointsForPreconnect(\n      url_origin, *host_redirect_data_, prediction);\n  if (!GetRedirectOrigin(url_origin, *host_redirect_data_, &redirect_origin)) {\n    // GetRedirectOrigin() may return false if it's not confident about the\n    // redirect target or the navigation target. Calling\n    // GetRedirectEndpointsForPreconnect() ensures we add all possible redirect\n    // targets to the preconnect prediction.\n    return has_any_prediction;\n  }\n\n  OriginData data;\n  if (!origin_data_->TryGetData(redirect_origin.host(), &data)) {\n    return has_any_prediction;\n  }\n\n  if (prediction) {\n    prediction->host = redirect_origin.host();\n    prediction->is_redirected = (redirect_origin != url_origin);\n  }\n  net::SchemefulSite redirect_site = net::SchemefulSite(redirect_origin);\n  auto network_anonymization_key =\n      net::NetworkAnonymizationKey::CreateSameSite(redirect_site);\n\n  for (const OriginStat& origin : data.origins()) {\n    float confidence = static_cast<float>(origin.number_of_hits()) /\n                       (origin.number_of_hits() + origin.number_of_misses());\n    if (confidence < kMinOriginConfidenceToTriggerPreresolve)\n      continue;\n\n    has_any_prediction = true;\n    if (prediction) {\n      if (confidence > kMinOriginConfidenceToTriggerPreconnect) {\n        prediction->requests.emplace_back(\n            url::Origin::Create(GURL(origin.origin())), 1,\n            network_anonymization_key);\n      } else {\n        prediction->requests.emplace_back(\n            url::Origin::Create(GURL(origin.origin())), 0,\n            network_anonymization_key);\n      }\n    }\n  }\n\n  return has_any_prediction;\n}","pos":-1,"query":"Generate preconnect prediction for URL redirects","filepos":57,"timecost":1385.3776999999973,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_mac_welcome\\edge_mac_welcome_ui.cc:27-133","function":"EdgeMacWelcomeUI::EdgeMacWelcomeUI","codesnippet":"{\n  fre_client_ = edge::fre::FreClientFactory::GetInstance()->GetForProfile(\n      Profile::FromWebUI(web_ui));\n  edge::WebUIPageMetricsHistogramData::CreateOrUpdateForWebContents(\n      web_ui->GetWebContents(), \"MacWelcome\");\n  // Create the trusted source for edge://mac-welcome.\n  content::WebUIDataSource* source = content::WebUIDataSource::CreateAndAdd(\n      web_ui->GetWebContents()->GetBrowserContext(),\n      chrome::kEdgeMacWelcomeHost);\n\n  static constexpr webui::LocalizedString kLocalizedStrings[] = {\n      {\"title\", IDS_EDGE_MAC_WELCOME_TITLE},\n      {\"privacyStatementText\", IDS_EDGE_MAC_WELCOME_PRIVACY_STATEMENT_TEXT},\n      {\"learnMoreText\", IDS_EDGE_MAC_WELCOME_LEARN_MORE_TEXT},\n      {\"confirmButtonText\", IDS_EDGE_MAC_WELCOME_CONFIRM_BUTTON_TEXT},\n      {\"backButtonText\", IDS_EDGE_MAC_WELCOME_BACK_BUTTON_TEXT},\n      {\"notNowButtonText\", IDS_EDGE_MAC_WELCOME_NOT_NOW_BUTTON_TEXT},\n      {\"finishButtonText\", IDS_EDGE_MAC_WELCOME_FINISH_BUTTON_TEXT},\n      {\"signinTitle\", IDS_EDGE_MAC_WELCOME_SIGNIN_TITLE},\n      {\"signinDescription\", IDS_EDGE_MAC_WELCOME_SIGNIN_DESCRIPTION},\n      {\"signinButtonText\", IDS_EDGE_MAC_WELCOME_SIGNIN_BUTTON_TEXT},\n      {\"signinCreateAccount\", IDS_EDGE_MAC_WELCOME_SIGNIN_CREATE_ACCOUNT},\n      {\"signinChooseAccount\", IDS_EDGE_MAC_WELCOME_SIGNIN_CHOOSE_ACCOUNT},\n      {\"signinAddNewAccount\", IDS_EDGE_MAC_WELCOME_SIGNIN_ADD_NEW_ACCOUNT},\n      {\"sanTitle\", IDS_EDGE_MAC_WELCOME_SAN_TITLE},\n      {\"sanDescription\", IDS_EDGE_MAC_WELCOME_SAN_DESCRIPTION},\n      {\"sanCheckboxTitle\", IDS_EDGE_MAC_WELCOME_SAN_CHECKBOX_TITLE},\n      {\"sanConfirmButtonText\", IDS_EDGE_MAC_WELCOME_SAN_CONFIRM_BUTTON_TEXT},\n      {\"importTitle\", IDS_EDGE_MAC_WELCOME_IMPORT_TITLE},\n      {\"importDescription\", IDS_EDGE_MAC_WELCOME_IMPORT_DESCRIPTION},\n      {\"importDescriptionChrome\",\n       IDS_EDGE_MAC_WELCOME_IMPORT_DESCRIPTION_CHROME},\n      {\"importButtonText\", IDS_EDGE_MAC_WELCOME_IMPORT_IMPORT_BUTTON_TEXT},\n      {\"importFromText\", IDS_EDGE_MAC_WELCOME_IMPORT_IMPORT_FROM_TEXT},\n      {\"selectItemsToImportText\",\n       IDS_EDGE_MAC_WELCOME_IMPORT_SELECT_ITEMS_TO_IMPORT_TEXT},\n      {\"favoritesOrBookmarksText\",\n       IDS_EDGE_MAC_WELCOME_IMPORT_FAVORITES_OR_BOOKMARKS_TEXT},\n      {\"settingsText\", IDS_EDGE_MAC_WELCOME_IMPORT_SETTINGS_TEXT},\n      {\"savedPasswordsText\", IDS_EDGE_MAC_WELCOME_IMPORT_SAVED_PASSWORDS_TEXT},\n      {\"openTabsText\", IDS_EDGE_MAC_WELCOME_IMPORT_OPEN_TABS_TEXT},\n      {\"personalInfoText\", IDS_EDGE_MAC_WELCOME_IMPORT_PERSONAL_INFO_TEXT},\n      {\"extensionsText\", IDS_EDGE_MAC_WELCOME_IMPORT_EXTENSIONS_TEXT},\n      {\"browsingHistoryText\",\n       IDS_EDGE_MAC_WELCOME_IMPORT_BROWSING_HISTORY_TEXT},\n      {\"defaultBrowserTitle\", IDS_EDGE_MAC_WELCOME_DEFAULT_BROWSER_TITLE},\n      {\"defaultBrowserDescription\",\n       IDS_EDGE_MAC_WELCOME_DEFAULT_BROWSER_DESCRIPTION},\n      {\"setAsDefaultButtonText\",\n       IDS_EDGE_MAC_WELCOME_DEFAULT_BROWSER_SET_AS_DEFAULT_BUTTON_TEXT},\n      {\"customizationTitle\", IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_TITLE},\n      {\"customizationDescription\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_DESCRIPTION},\n      {\"customizationAppearanceText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_APPEARANCE_TEXT},\n      {\"customizationOverallAppearanceText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_OVERALL_APPEARANCE_TEXT},\n      {\"systemDefaultText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_APPEARANCE_DEFAULT_TEXT},\n      {\"lightModeText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_APPEARANCE_LIGHT_TEXT},\n      {\"darkModeText\", IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_APPEARANCE_DARK_TEXT},\n      {\"homepageFeedsLayoutText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_HOMEPAGE_FEEDS_LAYOUT_TEXT},\n      {\"homepageFeedsLayoutHeadingsText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_HOMEPAGE_FEEDS_LAYOUT_HEADINGS_TEXT},\n      {\"homepageFeedsLayoutPartialViewText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_HOMEPAGE_FEEDS_LAYOUT_PARTIAL_VIEW_TEXT},\n      {\"homepageFeedsLayoutFullPageText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_HOMEPAGE_FEEDS_LAYOUT_FULL_PAGE_TEXT},\n      {\"tabLayoutText\", IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_TAB_LAYOUT_TEXT},\n      {\"tabLayoutHorizontalText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_TAB_LAYOUT_HORIZONTAL_TEXT},\n      {\"tabLayoutVerticalText\",\n       IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_TAB_LAYOUT_VERTICAL_TEXT},\n      {\"pickAThemeText\", IDS_EDGE_MAC_WELCOME_CUSTOMIZATION_PICK_A_THEME_TEXT},\n      {\"allowButtonText\", IDS_EDGE_MAC_WELCOME_ALLOW_BUTTON_TEXT},\n      {\"doNotAllowButtonText\", IDS_EDGE_MAC_WELCOME_DO_NOT_ALLOW_BUTTON_TEXT},\n      {\"welcomeTitleV2\", IDS_EDGE_MAC_WELCOME_SCREEN_TITLE},\n      {\"welcomeDescriptionV2\", IDS_EDGE_MAC_WELCOME_SCREEN_DESCRIPTION},\n      {\"welcomeStartButtonTextV2\", IDS_EDGE_MAC_WELCOME_START_BUTTON_TEXT},\n      {\"signInTitleV2\", IDS_EDGE_MAC_SIGN_IN_TITLE},\n      {\"signInDescriptionV2\", IDS_EDGE_MAC_SIGN_IN_DESCRIPTION},\n      {\"signInButtonTextV2\", IDS_EDGE_MAC_SIGN_IN_BUTTON_TEXT},\n      {\"signInCreateAccountButtonTextV2\",\n       IDS_EDGE_MAC_SIGN_IN_CREATE_ACCOUNT_BUTTON_TEXT},\n      {\"skipButtonTextV2\", IDS_EDGE_MAC_SKIP_BUTTON_TEXT},\n      {\"defaultBrowserTitleV2\", IDS_EDGE_MAC_DEFAULT_BROWSER_TITLE},\n      {\"defaultBrowserDescriptionV2\", IDS_EDGE_MAC_DEFAULT_BROWSER_DESCRIPTION},\n      {\"setEdgeDefaultBrowserButtonTextV2\",\n       IDS_EDGE_MAC_SET_EDGE_DEFAULT_BUTTON_TEXT},\n      {\"useMyOwnBrowserButtonTextV2\",\n       IDS_EDGE_MAC_USE_MY_OWN_BROWSER_BUTTON_TEXT},\n      {\"startBrowsingButtonTextV2\", IDS_EDGE_MAC_START_BROWSING_BUTTON_TEXT},\n  };\n  source->AddLocalizedStrings(kLocalizedStrings);\n\n  // Add links\n  source->AddString(\"privacyStatementURL\", chrome::kEdgePrivacyStatementURL);\n  source->AddString(\"personalizedDataCollectionLearnMoreURL\",\n                    chrome::kEdgePersonalizedDataCollectionLearnMoreURL);\n\n  // Add required resources.\n  edge_webui::SetupWebUIDataSource(web_ui, source, this,\n                                   kEdgeMacWelcomeWebuiResources,\n                                   IDR_EDGE_MAC_WELCOME_WEBUI_INDEX_HTML);\n}","pos":-1,"query":"setupMacWelcomePageUI","filepos":4,"timecost":891.8542000000016,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_mac_welcome\\edge_mac_welcome_ui_handler.cc:422-464","function":"EdgeMacWelcomeHandler::OnBrowserProfilesLoaded","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  bool pending_chrome_profiles_loading = false;\n  for (size_t index = 0; index < one_time_importer_list_->count(); ++index) {\n    const importer::SourceProfile& browser_profile =\n        one_time_importer_list_->GetSourceProfileAt(index);\n    auto source_item = edge_mac_welcome::mojom::ImportSourceItem::New();\n    source_item->index = index;\n    switch (browser_profile.importer_type) {\n      case importer::ImporterType::TYPE_CHROME:\n        source_item->type = edge_mac_welcome::mojom::BrowserImportType::kChrome;\n        break;\n      case importer::ImporterType::TYPE_FIREFOX:\n        source_item->type =\n            edge_mac_welcome::mojom::BrowserImportType::kFirefox;\n        break;\n      case importer::ImporterType::TYPE_SAFARI:\n        source_item->type = edge_mac_welcome::mojom::BrowserImportType::kSafari;\n        // Skip Safari for now\n        continue;\n      default:\n        source_item->type = edge_mac_welcome::mojom::BrowserImportType::kChrome;\n        break;\n    }\n    import_source_profiles_.push_back(std::move(source_item));\n    // if type is chrome, then detect user profiles\n    if (browser_profile.importer_type == importer::ImporterType::TYPE_CHROME) {\n      one_time_importer_list_->DetectUserSourceProfiles(\n          importer::ImporterType::TYPE_CHROME,\n          base::BindRepeating(&EdgeMacWelcomeHandler::OnUserProfilesLoaded,\n                              weak_ptr_factory_.GetWeakPtr(),\n                              import_source_profiles_.size() - 1,\n                              browser_profile.importer_type));\n      pending_chrome_profiles_loading = true;\n    }\n  }\n  if (!pending_chrome_profiles_loading) {\n    import_source_profiles_ready_ = true;\n    // Call GetFreSteps to update the import step\n    if (get_fre_steps_callback_) {\n      ContinueGetFreSteps();\n    }\n  }\n}","pos":-1,"query":"Import browser profiles and handle Chrome profiles","filepos":-1,"timecost":873.6059999999998,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\apps\\app_service\\webapk\\webapk_install_task.cc:117-164","function":"DoesShareTargetDiffer","codesnippet":"{\n  if (!share_info) {\n    // There's no |share_info| in the current WebAPK, which means that a share\n    // target was added.\n    return true;\n  }\n\n  // There is only one share target added.\n  auto share_target = manifest.share_targets(0);\n  DCHECK_EQ(manifest.share_targets_size(), 1);\n\n  if (share_target.action() != share_info->action.value_or(\"\") ||\n      share_target.method() != share_info->method.value_or(\"\") ||\n      share_target.enctype() != share_info->enctype.value_or(\"\")) {\n    return true;\n  }\n\n  auto share_param = share_target.params();\n  if (share_param.title() != share_info->param_title.value_or(\"\") ||\n      share_param.text() != share_info->param_text.value_or(\"\") ||\n      share_param.url() != share_info->param_url.value_or(\"\")) {\n    return true;\n  }\n\n  // Compare share files.\n  if (share_param.files_size() !=\n      static_cast<int>(share_info->file_names.size())) {\n    return true;\n  }\n\n  for (int i = 0; i < share_param.files_size(); i++) {\n    if (share_param.files(i).name() != share_info->file_names[i]) {\n      return true;\n    }\n\n    if (share_param.files(i).accept_size() !=\n        static_cast<int>(share_info->file_accepts[i].size())) {\n      return true;\n    }\n\n    for (int j = 0; j < share_param.files(i).accept_size(); j++) {\n      if (share_param.files(i).accept(j) != share_info->file_accepts[i][j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}","pos":-1,"query":"checkShareTargetModification","filepos":-1,"timecost":1307.3891000000003,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_rewards_view.cc:194-231","function":"EdgeRewardsView::UpdateRewardsButton","codesnippet":"{\n  // When calling Init, being enrolled is enforced.\n  // If our rewards status somehow changed (became unenrolled or error),\n  // leave the UI in the last known state.\n  // A refresh of the UI (clicking on the profile chooser) will update it again.\n  if (!rewards_status_->IsRewardsUser())\n    return;\n\n  constexpr int kIconSizeOffset = -2;\n  if (rewards_status_->is_give_mode()) {\n    give_mode_ = true;\n    SetIconImageModel(kRewardsHeartIcon, kIconSizeOffset);\n    if (!rewards_status_->give_organization().empty()) {\n      rewards_button_->SetText(l10n_util::GetStringFUTF16(\n          IDS_PROFILES_REWARDS_GIVE_MODE_LABEL,\n          base::FormatNumber(rewards_status_->GetTotalPoints()),\n          base::UTF8ToUTF16(rewards_status_->give_organization())));\n      rewards_button_->GetViewAccessibility().SetName(l10n_util::GetStringFUTF16(\n          IDS_PROFILES_REWARDS_BUTTON_GIVE_ACC,\n          base::FormatNumber(rewards_status_->GetTotalPoints()),\n          base::UTF8ToUTF16(rewards_status_->give_organization())));\n    } else {\n      rewards_button_->SetText(\n          base::FormatNumber(rewards_status_->GetTotalPoints()));\n      rewards_button_->GetViewAccessibility().SetName(l10n_util::GetStringFUTF16(\n          IDS_PROFILES_REWARDS_BUTTON_GIVE_ACC,\n          base::FormatNumber(rewards_status_->GetTotalPoints()),\n          std::u16string()));\n    }\n  } else {\n    give_mode_ = false;\n    SetIconImageModel(kRewardsMedalIcon);\n    rewards_button_->SetText(\n        base::FormatNumber(rewards_status_->GetTotalPoints()));\n    rewards_button_->GetViewAccessibility().SetName(l10n_util::GetStringFUTF16(\n        IDS_PROFILES_REWARDS_BUTTON_REWARDS_ACC,\n        base::FormatNumber(rewards_status_->GetTotalPoints())));\n  }\n}","pos":-1,"query":"updateRewardsUIBasedOnStatus","filepos":-1,"timecost":1105.056899999996,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\download\\download_query.cc:441-488","function":"DownloadQuery::AddSorter","codesnippet":"{\n  switch (type) {\n    case SORT_END_TIME:\n      sorters_.push_back(Sorter::Build<int64_t>(direction, &GetEndTimeMsEpoch));\n      break;\n    case SORT_START_TIME:\n      sorters_.push_back(\n          Sorter::Build<int64_t>(direction, &GetStartTimeMsEpoch));\n      break;\n    case SORT_ORIGINAL_URL:\n      sorters_.push_back(\n          Sorter::Build<std::string>(direction, &GetOriginalUrl));\n      break;\n    case SORT_URL:\n      sorters_.push_back(Sorter::Build<std::string>(direction, &GetUrl));\n      break;\n    case SORT_FILENAME:\n      sorters_.push_back(\n          Sorter::Build<std::u16string>(direction, &GetFilename));\n      break;\n    case SORT_DANGER:\n      sorters_.push_back(Sorter::Build<DownloadDangerType>(\n          direction, &GetDangerType));\n      break;\n    case SORT_DANGER_ACCEPTED:\n      sorters_.push_back(Sorter::Build<bool>(direction, &GetDangerAccepted));\n      break;\n    case SORT_EXISTS:\n      sorters_.push_back(Sorter::Build<bool>(direction, &GetExists));\n      break;\n    case SORT_STATE:\n      sorters_.push_back(Sorter::Build<DownloadItem::DownloadState>(\n          direction, &GetState));\n      break;\n    case SORT_PAUSED:\n      sorters_.push_back(Sorter::Build<bool>(direction, &IsPaused));\n      break;\n    case SORT_MIME:\n      sorters_.push_back(Sorter::Build<std::string>(direction, &GetMimeType));\n      break;\n    case SORT_BYTES_RECEIVED:\n      sorters_.push_back(Sorter::Build<double>(direction, &GetReceivedBytes));\n      break;\n    case SORT_TOTAL_BYTES:\n      sorters_.push_back(Sorter::Build<double>(direction, &GetTotalBytes));\n      break;\n  }\n}","pos":117,"query":"addSorterBasedOnType","filepos":117,"timecost":2477.1672999999937,"filemrr":0.4},{"filePath":"D:\\Edge\\src\\chrome\\browser\\search\\edge_ntp_icon_source.cc:118-161","function":"ParseNtpIconPath","codesnippet":"{\n  ParsedNtpIconPath parsed;\n  parsed.show_fallback_monogram = true;\n  parsed.size_in_dip = gfx::kFaviconSize;\n  parsed.url = GURL();\n\n  if (path.empty())\n    return parsed;\n\n  // NOTE(dbeam): can't start with an empty GURL() and use ReplaceComponents()\n  // because it's not allowed for invalid URLs.\n  GURL request = GURL(base::StrCat({chrome::kChromeSearchScheme, \"://\",\n                                    chrome::kChromeUINewTabIconHost}))\n                     .Resolve(path);\n\n  for (net::QueryIterator it(request); !it.IsAtEnd(); it.Advance()) {\n    auto key = it.GetKey();\n    if (key == kShowFallbackMonogramParam) {\n      parsed.show_fallback_monogram = it.GetUnescapedValue() != \"false\";\n    } else if (key == kColorParam) {\n      parsed.color_rgba = it.GetUnescapedValue();\n    } else if (key == kSizeParam) {\n      std::vector<std::string> pieces =\n          base::SplitString(it.GetUnescapedValue(), \"@\", base::TRIM_WHITESPACE,\n                            base::SPLIT_WANT_NONEMPTY);\n      if (pieces.empty() || pieces.size() > 2)\n        continue;\n      int size_in_dip = 0;\n      if (!base::StringToInt(pieces[0], &size_in_dip))\n        continue;\n      parsed.size_in_dip = std::min(size_in_dip, kMaxIconSizeDip);\n      if (pieces.size() > 1) {\n        float scale_factor = 0.0;\n        webui::ParseScaleFactor(pieces[1], &scale_factor);\n        // Do not exceed the maximum scale factor for the device.\n        parsed.device_scale_factor =\n            std::min(scale_factor, GetMaxDeviceScaleFactor());\n      }\n    } else if (key == kUrlParam) {\n      parsed.url = GURL(it.GetUnescapedValue());\n    }\n  }\n\n  return parsed;\n}","pos":0,"query":"parseNtpIconPath","filepos":0,"timecost":1486.0432999999975,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\chrome_layout_provider.cc:108-264","function":"ChromeLayoutProvider::GetDistanceMetric","codesnippet":"{\n  DCHECK_GE(metric, views::VIEWS_DISTANCE_START);\n  DCHECK_LT(metric, views::VIEWS_DISTANCE_MAX);\n\n  if (metric < views::VIEWS_DISTANCE_END) {\n    return LayoutProvider::GetDistanceMetric(metric);\n  }\n\n  switch (static_cast<ChromeDistanceMetric>(metric)) {\n    case DISTANCE_CONTENT_LIST_VERTICAL_SINGLE:\n      return 4;\n    case DISTANCE_CONTENT_LIST_VERTICAL_MULTI:\n      return 8;\n    case DISTANCE_EXTENSIONS_MENU_WIDTH:\n      return kMediumDialogWidth;\n    case DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SIZE:\n      return 20;\n    case DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SMALL_SIZE:\n      return 16;\n    case DISTANCE_EXTENSIONS_MENU_EXTENSION_ICON_SIZE:\n      return 28;\n    case DISTANCE_EXTENSIONS_MENU_ICON_SPACING:\n      return (GetDistanceMetric(DISTANCE_EXTENSIONS_MENU_EXTENSION_ICON_SIZE) -\n              GetDistanceMetric(DISTANCE_EXTENSIONS_MENU_BUTTON_ICON_SIZE)) /\n             2;\n    case DISTANCE_EXTENSIONS_MENU_BUTTON_MARGIN:\n      return 12;\n    case DISTANCE_EXTENSIONS_MENU_LABEL_ICON_SPACING:\n      return 4;\n    case DISTANCE_RELATED_CONTROL_HORIZONTAL_SMALL:\n      return 16;\n    case DISTANCE_RELATED_CONTROL_VERTICAL_SMALL:\n      return 8;\n    case DISTANCE_BUTTON_MINIMUM_WIDTH:\n      return GetDistanceMetric(views::DISTANCE_DIALOG_BUTTON_MINIMUM_WIDTH);\n    case DISTANCE_RELATED_LABEL_HORIZONTAL_LIST:\n      return 8;\n    case DISTANCE_SUBSECTION_HORIZONTAL_INDENT:\n      return 0;\n    case DISTANCE_TOAST_CONTROL_VERTICAL:\n      return 8;\n    case DISTANCE_TOAST_LABEL_VERTICAL:\n      return 12;\n    case DISTANCE_UNRELATED_CONTROL_HORIZONTAL_LARGE:\n      return 16;\n    case DISTANCE_UNRELATED_CONTROL_VERTICAL_LARGE:\n      return 16;\n    case DISTANCE_STANDALONE_BUBBLE_PREFERRED_WIDTH:\n      return kMediumDialogWidth;\n    case DISTANCE_BETWEEN_PRIMARY_AND_SECONDARY_LABELS_HORIZONTAL:\n      return 24;\n    case DISTANCE_OMNIBOX_CELL_VERTICAL_PADDING:\n#if !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      return 12;\n#else\n      return 8;\n#endif  // !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    case DISTANCE_OMNIBOX_TWO_LINE_CELL_VERTICAL_PADDING:\n      return 4;\n    case DISTANCE_SIDE_PANEL_HEADER_VECTOR_ICON_SIZE:\n      return 16;\n    case DISTANCE_SIDE_PANEL_HEADER_BUTTON_MINIMUM_SIZE:\n      return 20;\n    case DISTANCE_SIDE_PANEL_HEADER_INTERIOR_MARGIN_HORIZONTAL:\n      return 4;\n    case DISTANCE_HORIZONTAL_SEPARATOR_PADDING_PAGE_INFO_VIEW:\n      return 20;\n    case DISTANCE_INFOBAR_HORIZONTAL_ICON_LABEL_PADDING:\n      return 16;\n    case DISTANCE_INFOBAR_HEIGHT:\n#if MICROSOFT_EDGE_BUILD\n      // For Edge Spec says height of button should be 24dp, vertical padding on\n      // both top and bottom should be 8dp.\n      return 24 + 2 * 8;\n#else\n      // Spec says height of button should be 36dp, vertical padding on both\n      // top and bottom should be 8dp.\n      return 36 + 2 * 8;\n#endif\n    case DISTANCE_PERMISSION_PROMPT_HORIZONTAL_ICON_LABEL_PADDING:\n      return 8;\n    case DISTANCE_RICH_HOVER_BUTTON_ICON_HORIZONTAL:\n      return 8;\n    case DISTANCE_TASK_MANAGER_SEARCH_BAR_ICON_AND_BUTTON_HORIZONTAL_SPACING:\n      return 4;\n    case DISTANCE_TASK_MANAGER_SEARCH_ICON_SIZE:\n      return 20;\n    case DISTANCE_TASK_MANAGER_SEARCH_BAR_MIN_WIDTH:\n      return 160;\n    case DISTANCE_TASK_MANAGER_SEARCH_BAR_MIN_HEIGHT:\n      return 36;\n    case DISTANCE_TASK_MANAGER_TAB_HEIGHT:\n      return 54;\n    case DISTANCE_TOAST_BUBBLE_BETWEEN_CHILD_SPACING:\n    case DISTANCE_TOAST_BUBBLE_BROWSER_WINDOW_MARGIN:\n      return 4;\n    case DISTANCE_TOAST_BUBBLE_BETWEEN_LABEL_ACTION_BUTTON_SPACING:\n    case DISTANCE_TOAST_BUBBLE_BETWEEN_LABEL_MENU_BUTTON_SPACING:\n      return 16;\n    case DISTANCE_TOAST_BUBBLE_HEIGHT:\n      return 48;\n    case DISTANCE_TOAST_BUBBLE_HEIGHT_ACTION_BUTTON:\n      return 36;\n    case DISTANCE_TOAST_BUBBLE_HEIGHT_CONTENT:\n      return 24;\n    case DISTANCE_TOAST_BUBBLE_ICON_SIZE:\n    case DISTANCE_TOAST_BUBBLE_MENU_ICON_SIZE:\n      return 20;\n    case DISTANCE_TOAST_BUBBLE_LEADING_ICON_SIDE_MARGINS:\n      return 2;\n    case DISTANCE_TOAST_BUBBLE_MARGIN_LEFT:\n      return 12;\n    case DISTANCE_TOAST_BUBBLE_MARGIN_RIGHT_ACTION_BUTTON:\n      return 6;\n    case DISTANCE_TOAST_BUBBLE_MARGIN_RIGHT_CLOSE_BUTTON:\n    case DISTANCE_TOAST_BUBBLE_MARGIN_RIGHT_MENU_BUTTON:\n      return 10;\n    case DISTANCE_TOAST_BUBBLE_MARGIN_RIGHT_LABEL:\n      return 16;\n    case DISTANCE_RECENT_ACTIVITY_AVATAR_SIZE:\n      return 32;\n    case DISTANCE_RECENT_ACTIVITY_AVATAR_FALLBACK_SIZE:\n      return 24;\n    case DISTANCE_RECENT_ACTIVITY_FAVICON_CONTAINER_RADIUS:\n      return 9;\n    case DISTANCE_RECENT_ACTIVITY_FAVICON_CONTAINER_BORDER_WIDTH:\n      return 2;\n    case DISTANCE_RECENT_ACTIVITY_FAVICON_CONTAINER_PADDING:\n      return 4;\n    case DISTANCE_RECENT_ACTIVITY_FAVICON_CONTAINER_OFFSET_FROM_AVATAR:\n      return 2;\n    case DISTANCE_RECENT_ACTIVITY_CONTAINER_RADIUS:\n      return 8;\n    case DISTANCE_RECENT_ACTIVITY_CONTAINER_VERTICAL_MARGIN:\n      return 10;\n    case DISTANCE_RECENT_ACTIVITY_CONTAINER_VERTICAL_PADDING:\n      return 6;\n    case DISTANCE_RECENT_ACTIVITY_ROW_VERTICAL_PADDING:\n      return 6;\n    case DISTANCE_ACCOUNT_INFO_ROW_AVATAR_EMAIL:\n      return 8;\n    case DISTANCE_COLLABORATION_MESSAGING_AVATAR_FALLBACK_ICON_PADDING:\n      return 2;\n    case DISTANCE_COLLABORATION_MESSAGING_AVATAR_FALLBACK_ICON_BORDER_SIZE:\n      return 1;\n    case DISTANCE_TEXTFIELD_ACCOUNT_CARD_VERTICAL:\n      return 4;\n    case DISTANCE_FEATURE_FIRST_RUN_INFO_BOX_ICON_SIZE:\n      return 16;\n    case DISTANCE_FEATURE_FIRST_RUN_INFO_BOX_PADDING:\n      return 12;\n    case DISTANCE_FEATURE_FIRST_RUN_INFO_BOX_ROUNDED_BORDER_RADIUS:\n      return 12;\n    case DISTANCE_FEATURE_FIRST_RUN_INFO_BOX_VERTICAL:\n      return 1;\n  }\n  NOTREACHED();\n}","pos":0,"query":"GetDistanceMetricValue","filepos":0,"timecost":1513.5137000000104,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_downloads_btr\\edge_downloads_btr_handler.cc:201-259","function":"BuildDangerousDownloadItem","codesnippet":"{\n  auto download_item = BuildBasicDownloadItem(item);\n  download_item->type = \"dangerous\";\n\n  std::string icon = kErrorIcon;\n  download::DownloadDangerType danger_type = item->GetDangerType();\n  if (danger_type ==\n          download::DownloadDangerType::DOWNLOAD_DANGER_TYPE_UNCOMMON_CONTENT ||\n      danger_type == download::DownloadDangerType::\n                         DOWNLOAD_DANGER_TYPE_POTENTIALLY_UNWANTED) {\n    icon = kWarningIcon;\n  }\n  download_item->icon = icon;\n\n  // Add inline actions\n  download_item->inline_actions =\n      std::vector<edge_downloads_btr::mojom::EdgeDownloadsBtrActionPtr>();\n  download_item->inline_actions->push_back(BuildAction(\n      \"discardDangerous\", IDS_DISCARD_DOWNLOAD, true /*is_icon*/, \"delete\"));\n\n  // Set appropriate danger message based on danger type\n  std::u16string file_name = item->GetFileNameToReportUser().LossyDisplayName();\n  std::string title;\n  switch (danger_type) {\n    case download::DownloadDangerType::DOWNLOAD_DANGER_TYPE_DANGEROUS_CONTENT:\n      title = l10n_util::GetStringFUTF8(\n          IDS_PROMPT_DANGEROUS_DOWNLOAD_APPREP_MALICIOUS, file_name);\n      break;\n    case download::DownloadDangerType::DOWNLOAD_DANGER_TYPE_UNCOMMON_CONTENT:\n      title = l10n_util::GetStringFUTF8(\n          IDS_PROMPT_DANGEROUS_DOWNLOAD_APPREP_UNCOMMON, file_name);\n      break;\n    case download::DownloadDangerType::\n        DOWNLOAD_DANGER_TYPE_POTENTIALLY_UNWANTED:\n      title =\n          l10n_util::GetStringFUTF8(IDS_PROMPT_PUA_DOWNLOAD_BLOCK, file_name);\n      break;\n    case download::DownloadDangerType::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE:\n      if (item->AppRepHadError()) {\n        title = l10n_util::GetStringFUTF8(\n            IDS_PROMPT_DANGEROUS_DOWNLOAD_APPREP_ERROR, file_name);\n      } else {\n        title =\n            l10n_util::GetStringFUTF8(IDS_PROMPT_DANGEROUS_DOWNLOAD, file_name);\n      }\n      break;\n    case download::DownloadDangerType::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL:\n      title = l10n_util::GetStringFUTF8(IDS_PROMPT_MALICIOUS_DOWNLOAD_URL,\n                                        file_name);\n      break;\n    default:\n      title =\n          l10n_util::GetStringFUTF8(IDS_PROMPT_DANGEROUS_DOWNLOAD, file_name);\n      break;\n  }\n  download_item->title = std::move(title);\n\n  return download_item;\n}","pos":171,"query":"createDangerousDownloadItem","filepos":41,"timecost":1318.3899999999994,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\autofill\\popup\\popup_row_view.cc:361-407","function":"PopupRowView::SetSelectedCell","codesnippet":"{\n  if (!controller_) {\n    return;\n  }\n\n  if (new_cell == selected_cell_) {\n    return;\n  }\n\n  // If the previous cell was content, set it as unselected.\n  if (selected_cell_ == CellType::kContent) {\n    content_view_->UpdateStyle(/*selected=*/false);\n    content_view_->GetViewAccessibility().SetIsSelected(false);\n    controller_->UnselectSuggestion();\n  }\n\n  if ((new_cell == CellType::kControl && expand_child_suggestions_view_) ||\n      (new_cell == CellType::kContent && !suggestion_is_acceptable_)) {\n    // TODO(crbug.com/370695550): `SetIsSelected()` must go after\n    // `NotifyAXSelection()` as the latter calls `SetPopupFocusOverride()`  that\n    // is required for a11y focus working on a non-activatable popup.  Consider\n    // moving `SetIsSelected()` into `NotifyAXSelection()` (and rename it) to\n    // hide this API complexity from clients.\n    GetA11ySelectionDelegate().NotifyAXSelection(*this);\n    GetViewAccessibility().SetIsSelected(true);\n    NotifyAccessibilityEventDeprecated(\n        ax::mojom::Event::kSelectedChildrenChanged, true);\n    selected_cell_ = new_cell;\n  } else if (new_cell == CellType::kContent) {\n    controller_->SelectSuggestion(line_number_);\n    content_view_->UpdateStyle(/*selected=*/highlight_on_select_);\n    GetA11ySelectionDelegate().NotifyAXSelection(*content_view_);\n    content_view_->GetViewAccessibility().SetIsSelected(true);\n    NotifyAccessibilityEventDeprecated(\n        ax::mojom::Event::kSelectedChildrenChanged, true);\n    selected_cell_ = new_cell;\n  } else {\n    // Set the selected cell to none in case an invalid choice was made (e.g.\n    // selecting a control cell when none exists) or the cell was reset\n    // explicitly with `std::nullopt`.\n    selected_cell_ = std::nullopt;\n\n    GetViewAccessibility().SetIsSelected(false);\n    content_view_->GetViewAccessibility().SetIsSelected(false);\n  }\n\n  UpdateBackground();\n}","pos":72,"query":"updateCellSelectionAndAccessibility","filepos":72,"timecost":1450.3862999999983,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_mobile_business\\identity\\b2w_sso_msa_navigation_throttle.cc:74-128","function":"MSANavigationThrottle::Check","codesnippet":"{\n  auto* handle = navigation_handle();\n\n  auto* identity_manager =\n      IdentityManagerFactory::GetForProfile(Profile::FromBrowserContext(\n          handle->GetWebContents()->GetBrowserContext()));\n  if (!identity_manager ||\n      !identity_manager->HasPrimaryAccount(signin::ConsentLevel::kSignin)) {\n    return PROCEED;\n  }\n\n  auto account_info =\n      identity_manager->GetPrimaryAccountInfo(signin::ConsentLevel::kSignin);\n  if (!account_info.IsMSA()) {\n    WriteLog(handle, \"The active account is not MSA.\",\n             edge_mobile_logger::LogLevel::ERROR);\n    return PROCEED;\n  }\n\n  const bool has_sso_header = handle->GetRequestHeaders().HasHeader(kPRTHeader);\n  const auto url = handle->GetURL();\n  const bool is_login_request = IsLoginEndpointForMSA(url);\n  if (has_sso_header == is_login_request) {\n    return PROCEED;\n  }\n\n  if (has_sso_header) {\n    if (!IsFirstPartyWebSiteOfMicrosoft(url)) {\n      WriteLog(handle, \"Remove sso_cookie from request headers of \" +\n                           log::ToString(url));\n      handle->RemoveRequestHeader(kPRTHeader);\n    }\n    return PROCEED;\n  }\n\n  if (!handle->IsInPrimaryMainFrame()) {\n    // Only support b2w_sso for requests from the main frame.\n    return PROCEED;\n  }\n\n  WriteLog(handle, \"Recognize \" + log::ToString(url));\n  if (auto* service = ServiceFactory::GetForProfile(Profile::FromBrowserContext(\n          handle->GetWebContents()->GetBrowserContext()));\n      service) {\n    if (service->MakeCredentials(\n            /*from_interactive_context=*/true, url,\n            base::BindOnce(&MSANavigationThrottle::OnCredentialsGenerated,\n                           weak_factory_.GetWeakPtr(),\n                           account_info.gaia.ToString()))) {\n      return DEFER;\n    }\n  }\n  WriteLog(handle, \"Failed to start MakeCredentials.\",\n           edge_mobile_logger::LogLevel::ERROR);\n  return PROCEED;\n}","pos":-1,"query":"MSA account SSO request handler","filepos":-1,"timecost":769.2367999999988,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\file_manager\\copy_or_move_io_task_policy_impl.cc:124-154","function":"MaybeSendConnectorsBlockedFilesNotification","codesnippet":"{\n  if (dialog_info_map.empty()) {\n    return;\n  }\n\n  // Blocked files are only added if kFileTransferEnterpriseConnectorUI is\n  // enabled.\n  CHECK(base::FeatureList::IsEnabled(\n      features::kFileTransferEnterpriseConnectorUI));\n\n  auto* files_policy_manager =\n      policy::FilesPolicyNotificationManagerFactory::GetForBrowserContext(\n          profile);\n  if (!files_policy_manager) {\n    LOG(ERROR) << \"Couldn't find FilesPolicyNotificationManager\";\n    return;\n  }\n\n  for (const auto& [block_reason, dialog_info] : dialog_info_map) {\n    files_policy_manager->SetConnectorsBlockedFiles(\n        task_id,\n        type == file_manager::io_task::OperationType::kMove\n            ? policy::dlp::FileAction::kMove\n            : policy::dlp::FileAction::kCopy,\n        block_reason, std::move(dialog_info));\n  }\n}","pos":-1,"query":"SetBlockedFilesForPolicyManager","filepos":-1,"timecost":1214.6592999999993,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\document_scan\\document_scan_api_handler.cc:217-262","function":"DocumentScanAPIHandler::OnOpenScannerResponse","codesnippet":"{\n  auto response_out = response.To<api::document_scan::OpenScannerResponse>();\n\n  // Replace the internal connection string with the originally requested token.\n  response_out.scanner_id = scanner_id;\n\n  if (response_out.result != api::document_scan::OperationResult::kSuccess) {\n    std::move(callback).Run(std::move(response_out));\n    return;\n  }\n\n  ExtensionState& state = extension_state_[extension_id];\n  if (!base::Contains(state.active_scanner_ids, scanner_id)) {\n    response_out.result = api::document_scan::OperationResult::kInvalid;\n    std::move(callback).Run(std::move(response_out));\n    return;\n  }\n\n  // Clear any open handles that point to the same scanner.  These are no longer\n  // valid after opening a new handle.\n  for (auto it = state.scanner_handles.begin();\n       it != state.scanner_handles.end();) {\n    if (it->second == scanner_id) {\n      // Erase job handles pointing to the same scanner handle before erasing\n      // the scanner handle.\n      std::erase_if(state.active_job_handles, [&it](const auto& item) {\n        return item.second == it->first;\n      });\n      state.approved_scanner_handles.erase(it->first);\n      it = state.scanner_handles.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Track that this handle belongs to this extension.  This prevents other\n  // extensions from using it.\n  if (response_out.scanner_handle.has_value()) {\n    state.scanner_handles[response_out.scanner_handle.value()] = scanner_id;\n  }\n\n  std::move(callback).Run(std::move(response_out));\n}","pos":-1,"query":"manageScannerConnections","filepos":-1,"timecost":1394.3368999999948,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\user_education_internals\\user_education_internals_page_handler_impl.cc:146-177","function":"RemovePrefixAndCamelCase","codesnippet":"{\n  // Remove the prefix if one is present.\n  if (str.starts_with(prefix)) {\n    str = str.substr(strlen(prefix));\n  }\n\n  // De-camel-case the string. This inserts spaces between segments that are\n  // either capitalized words or all-caps acronyms.\n  //\n  // For example, \"SaveToCSVPromo\" would become \"Save To CSV Promo\".\n  //\n  // This doesn't work for every possible string but does work for almost\n  // anything that follows established IPH naming conventions.\n  std::string result;\n  bool was_cap_before = false;\n  bool was_cap = false;\n  for (char ch : str) {\n    const bool is_cap = absl::ascii_isupper(ch);\n    if (result.length() > 1U) {\n      if (was_cap && (!is_cap || (is_cap && !was_cap_before))) {\n        const char prev = result.back();\n        result.pop_back();\n        result.push_back(' ');\n        result.push_back(prev);\n      }\n    }\n    result.push_back(ch);\n    was_cap_before = was_cap;\n    was_cap = is_cap;\n  }\n\n  return result;\n}","pos":-1,"query":"deCamelCaseAndRemovePrefix","filepos":-1,"timecost":2191.1958999999915,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\vr\\chrome_xr_integration_client.cc:137-178","function":"ChromeXrIntegrationClient::GetAdditionalProviders","codesnippet":"{\n  content::XRProviderList providers;\n\n#if BUILDFLAG(IS_ANDROID)\n#if BUILDFLAG(ENABLE_OPENXR)\n  if (IsForcedByCommandLine(base::CommandLine::ForCurrentProcess(),\n                            switches::kWebXrRuntimeOpenXr) ||\n      (device::features::IsOpenXrEnabled() &&\n       !IsOtherRuntimeForced(base::CommandLine::ForCurrentProcess(),\n                             switches::kWebXrRuntimeOpenXr))) {\n    providers.emplace_back(std::make_unique<webxr::OpenXrDeviceProvider>());\n  }\n#endif  // BUILDFLAG(ENABLE_OPENXR)\n#if BUILDFLAG(ENABLE_CARDBOARD)\n  if (!IsOtherRuntimeForced(base::CommandLine::ForCurrentProcess(),\n                            switches::kWebXrRuntimeCardboard)) {\n    base::android::ScopedJavaLocalRef<jobject>\n        j_vr_compositor_delegate_provider =\n            vr::Java_VrCompositorDelegateProviderImpl_Constructor(\n                base::android::AttachCurrentThread());\n\n    providers.emplace_back(std::make_unique<webxr::CardboardDeviceProvider>(\n        std::make_unique<webxr::VrCompositorDelegateProvider>(\n            std::move(j_vr_compositor_delegate_provider))));\n  }\n#endif  // BUILDFLAG(ENABLE_CARDBOARD)\n#if BUILDFLAG(ENABLE_ARCORE)\n  if (!IsOtherRuntimeForced(base::CommandLine::ForCurrentProcess(),\n                            switches::kWebXrRuntimeArCore)) {\n    base::android::ScopedJavaLocalRef<jobject>\n        j_ar_compositor_delegate_provider =\n            vr::Java_ArCompositorDelegateProviderImpl_Constructor(\n                base::android::AttachCurrentThread());\n\n    providers.push_back(std::make_unique<webxr::ArCoreDeviceProvider>(\n        std::make_unique<webxr::ArCompositorDelegateProvider>(\n            std::move(j_ar_compositor_delegate_provider))));\n  }\n#endif  // BUILDFLAG(ENABLE_ARCORE)\n#endif  // BUILDFLAG(IS_ANDROID)\n\n  return providers;\n}","pos":-1,"query":"initializeXRProvidersForAndroid","filepos":-1,"timecost":1228.2344000000012,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_webshot\\chrome_webshot_client.cc:217-254","function":"ChromeWebShotClient::ViewWebShotAddedInCollections","codesnippet":"{\n  if (features::edge::IsCollectionsFeatureEnabled(\n          features::edge::kEdgeAddWebCapturetoCollections)) {\n    if (IsEditorOpen()) {\n      // If editor dialog is open then close it first, otherwise editor dialog\n      // will be closed after navigation to viewer url has started and closing\n      // editor after that will reset webshot_driver and manager state,\n      // following which viewer functionality won't work. Hence, close the\n      // editor dialog here itself.\n      CloseEditor();\n    }\n    collection_item_id_ = item_id;\n    // We need to set editor_web_contents as existing code has dependency\n    // on this for correct functioning of copy/save/zoom scenarios.\n    editor_web_contents_ = source_web_contents_;\n    content_webshot_driver_->SetRenderFrameHostID(\n        source_web_contents_->GetPrimaryPage()\n            .GetMainDocument()\n            .GetProcess()\n            ->GetID()\n            .GetUnsafeValue(),\n        source_web_contents_->GetPrimaryPage()\n            .GetMainDocument()\n            .GetRoutingID());\n\n    content::BrowserContext* browser_context =\n        source_web_contents_->GetBrowserContext();\n    Profile* profile = Profile::FromBrowserContext(browser_context);\n    DCHECK(profile);\n    Browser* browser = chrome::FindBrowserWithProfile(profile);\n    CollectionsManager::GetDataManager(browser)->ValidateIds(\n        collection_id, item_id,\n        base::BindOnce(\n            &ChromeWebShotClient::InitializeViewerOnValidationCompleted,\n            weak_pointer_factory_.GetWeakPtr()));\n  }\n}","pos":-1,"query":"Initialize web capture viewer if enabled","filepos":63,"timecost":1129.3473000000085,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\media_router\\media_router_dialog_controller_views.cc:56-95","function":"MediaRouterDialogControllerViews::CreateMediaRouterDialog","codesnippet":"{\n  base::Time dialog_creation_time = base::Time::Now();\n  if (GetActionController()) {\n    GetActionController()->OnDialogShown();\n  }\n  Profile* profile =\n      Profile::FromBrowserContext(initiator()->GetBrowserContext());\n\n  InitializeMediaRouterUI();\n  Browser* browser = chrome::FindBrowserWithTab(initiator());\n  BrowserView* browser_view =\n      browser ? BrowserView::GetBrowserViewForBrowser(browser) : nullptr;\n  if (browser_view) {\n    // Show the Cast dialog anchored to the Cast toolbar button.\n    if (browser_view->toolbar()->GetCastButton()) {\n      cast_dialog_coordinator_.ShowDialogWithToolbarAction(\n          ui_.get(), browser, dialog_creation_time, activation_location);\n    } else {\n      cast_dialog_coordinator_.ShowDialogCenteredForBrowserWindow(\n          ui_.get(), browser, dialog_creation_time, activation_location);\n    }\n  } else {\n    // Show the Cast dialog anchored to the top of the web contents.\n    gfx::Rect anchor_bounds = initiator()->GetContainerBounds();\n    // Set the height to 0 so that the dialog gets anchored to the top of the\n    // window.\n    anchor_bounds.set_height(0);\n    cast_dialog_coordinator_.ShowDialogCentered(anchor_bounds, ui_.get(),\n                                                profile, dialog_creation_time,\n                                                activation_location);\n  }\n  scoped_widget_observations_.AddObservation(\n      cast_dialog_coordinator_.GetCastDialogWidget());\n\n  if (dialog_creation_callback_) {\n    dialog_creation_callback_.Run();\n  }\n  MediaRouterMetrics::RecordMediaRouterDialogActivationLocation(\n      activation_location);\n}","pos":-1,"query":"ShowCastDialogBasedOnToolbarPresence","filepos":-1,"timecost":1282.713499999998,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\desktop_capture\\desktop_media_tab_list.cc:215-247","function":"DesktopMediaTabList::DesktopMediaTabList","codesnippet":"{\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  // The thumbnail size isn't allowed to be smaller than gfx::kFaviconSize by\n  // the underlying media list. TableView requires that the icon size be exactly\n  // ui::TableModel::kIconSize; if it's not, rendering of the TableView breaks.\n  // This DCHECK enforces that kIconSize is an acceptable size for the source\n  // list.\n  DCHECK_GE(ui::TableModel::kIconSize, gfx::kFaviconSize);\n\n  controller_->SetThumbnailSize(\n      gfx::Size(ui::TableModel::kIconSize, ui::TableModel::kIconSize));\n\n  SetLayoutManager(std::make_unique<views::FillLayout>());\n\n  model_ = std::make_unique<TabListModel>(\n      controller_, base::BindRepeating(&DesktopMediaTabList::OnPreviewUpdated,\n                                       weak_factory_.GetWeakPtr()));\n  auto selection_changed_callback = base::BindRepeating(\n      &DesktopMediaTabList::OnSelectionChanged, weak_factory_.GetWeakPtr());\n  view_observer_ = std::make_unique<TabListViewObserver>(\n      controller_, selection_changed_callback);\n\n  auto table = std::make_unique<views::TableView>(\n      model_.get(), std::vector<ui::TableColumn>(1),\n      views::TableType::kIconAndText, true);\n  table->set_observer(view_observer_.get());\n  table->GetViewAccessibility().SetName(accessible_name,\n                                        ax::mojom::NameFrom::kAttribute);\n  table_ = table.get();\n\n  AddChildView(BuildUI(std::move(table)));\n}","pos":-1,"query":"Initialize and configure tab list UI","filepos":71,"timecost":718.7667999999976,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\forced_extensions\\force_installed_tracker.cc:238-335","function":"ForceInstalledTracker::IsMisconfiguration","codesnippet":"{\n  if (installation_data.install_error_detail) {\n    CrxInstallErrorDetail detail =\n        installation_data.install_error_detail.value();\n    if (detail == CrxInstallErrorDetail::KIOSK_MODE_ONLY)\n      return true;\n\n    if (installation_data.extension_type &&\n        detail == CrxInstallErrorDetail::DISALLOWED_BY_POLICY &&\n        !extension_management_->IsAllowedManifestType(\n            installation_data.extension_type.value(), id)) {\n      return true;\n    }\n  }\n\n#if BUILDFLAG(IS_CHROMEOS)\n  // REPLACED_BY_SYSTEM_APP is a misconfiguration because these apps are legacy\n  // apps and are replaced by system apps.\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::REPLACED_BY_SYSTEM_APP) {\n    return true;\n  }\n\n  // REPLACED_BY_ARC_APP error is a misconfiguration if ARC++ is enabled for\n  // the device.\n  if (profile_->GetPrefs()->IsManagedPreference(arc::prefs::kArcEnabled) &&\n      profile_->GetPrefs()->GetBoolean(arc::prefs::kArcEnabled) &&\n      installation_data.failure_reason ==\n          InstallStageTracker::FailureReason::REPLACED_BY_ARC_APP) {\n    return true;\n  }\n#endif  // BUILDFLAG(IS_CHROMEOS)\n\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::NOT_PERFORMING_NEW_INSTALL) {\n    return true;\n  }\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::CRX_FETCH_URL_EMPTY) {\n    DCHECK(installation_data.no_updates_info);\n    if (installation_data.no_updates_info.value() ==\n        InstallStageTracker::NoUpdatesInfo::kEmpty) {\n      return true;\n    }\n  }\n\n  if (installation_data.manifest_invalid_error ==\n          ManifestInvalidError::BAD_APP_STATUS &&\n      installation_data.app_status_error ==\n          InstallStageTracker::AppStatusError::kErrorUnknownApplication) {\n    return true;\n  }\n\n  if (installation_data.unpacker_failure_reason ==\n      SandboxedUnpackerFailureReason::CRX_HEADER_INVALID) {\n    auto extension = extensions_.find(id);\n    // Extension id may be missing from this list if there is a change in\n    // ExtensionInstallForcelist policy after the user has logged in and\n    // |IsMisconfiguration| method is called from\n    // |ExtensionInstallEventLogCollector|.\n    if (extension != extensions_.end() && !extension->second.is_from_store &&\n        !IsExtensionFetchedFromCache(\n            installation_data.downloading_cache_status)) {\n      return true;\n    }\n  }\n\n  // When we receive 403 during update manifest fetch, it means that either\n  // update URL is wrong, or self-hosting server is misconfigured. Both cases\n  // are misconfigurations from Chrome's point view.\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::MANIFEST_FETCH_FAILED) {\n    auto extension = extensions_.find(id);\n    if (extension != extensions_.end() && !extension->second.is_from_store) {\n      if (installation_data.response_code == kHttpErrorCodeBadRequest ||\n          installation_data.response_code == kHttpErrorCodeForbidden ||\n          installation_data.response_code == kHttpErrorCodeNotFound) {\n        return true;\n      }\n    }\n  }\n\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::MANIFEST_INVALID) {\n    auto extension = extensions_.find(id);\n    if (extension != extensions_.end() && !extension->second.is_from_store) {\n      return true;\n    }\n  }\n\n  if (installation_data.failure_reason ==\n      InstallStageTracker::FailureReason::OVERRIDDEN_BY_SETTINGS) {\n    return true;\n  }\n\n  return false;\n}","pos":-1,"query":"Detects installation misconfiguration errors","filepos":-1,"timecost":1132.0810000000056,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\autofill\\payments\\filled_card_information_bubble_views.cc:185-257","function":"FilledCardInformationBubbleViews::AddCardDescriptionView","codesnippet":"{\n  const FilledCardInformationBubbleOptions& options =\n      controller_->GetBubbleOptions();\n  auto* const layout_provider = ChromeLayoutProvider::Get();\n\n  /*\n  |----------------------------------------------------------------|\n  |             |  masked_card_name | masked_card_number_last_four |\n  | card_image  |                                                  |\n  |             |  card_indicator                                  |\n  |----------------------------------------------------------------|\n  */\n  // Construct the container view as above.\n  auto* card_information_container =\n      parent->AddChildView(std::make_unique<views::BoxLayoutView>());\n  card_information_container->SetCrossAxisAlignment(\n      views::BoxLayout::CrossAxisAlignment::kCenter);\n  card_information_container->SetBetweenChildSpacing(\n      layout_provider->GetDistanceMetric(\n          views::DISTANCE_RELATED_CONTROL_HORIZONTAL));\n\n  std::pair<ui::ImageModel, std::optional<ui::ImageModel>> card_images =\n      controller_->GetCardImageForDescriptionView();\n  auto* card_image_view = card_information_container->AddChildView(\n      std::make_unique<views::ThemeTrackingImageView>(\n          /*light_image_model=*/card_images.first,\n          /*dark_image_model=*/card_images.second.value_or(card_images.first),\n          /*get_background_color_callback=*/\n          base::BindRepeating(\n              [](views::View* view) {\n                return ui::ColorVariant(view->GetColorProvider()->GetColor(\n                    ui::kColorDialogBackground));\n              },\n              base::Unretained(this))));\n  card_image_view->SetID(kCardImage);\n\n  // Add a child container view for the two-line text view.\n  auto* card_text_view = card_information_container->AddChildView(\n      std::make_unique<views::BoxLayoutView>());\n  card_text_view->SetOrientation(views::BoxLayout::Orientation::kVertical);\n  card_text_view->SetCrossAxisAlignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n  card_information_container->SetBetweenChildSpacing(\n      layout_provider->GetDistanceMetric(DISTANCE_TOAST_LABEL_VERTICAL));\n\n  // First line of the text content, the card network/description and last four.\n  // Note that the description can be truncated, but the last four digits never\n  // are.\n  auto* first_line =\n      card_text_view->AddChildView(std::make_unique<views::BoxLayoutView>());\n  first_line->SetBetweenChildSpacing(layout_provider->GetDistanceMetric(\n      DISTANCE_RELATED_LABEL_HORIZONTAL_LIST));\n  // `kEnd` aligns the child views to the end edge of the parent view so that\n  // `card_last_four_view` is positioned first at the end and is never pushed\n  // out.\n  first_line->SetMainAxisAlignment(views::BoxLayout::MainAxisAlignment::kEnd);\n  auto* card_name_view =\n      first_line->AddChildView(std::make_unique<views::Label>(\n          controller_->GetMaskedCardNameForDescriptionView(),\n          views::style::CONTEXT_DIALOG_BODY_TEXT, views::style::STYLE_PRIMARY));\n  card_name_view->SetID(kCardName);\n  auto* card_last_four_view =\n      first_line->AddChildView(std::make_unique<views::Label>(\n          options.masked_card_number_last_four,\n          views::style::CONTEXT_DIALOG_BODY_TEXT, views::style::STYLE_PRIMARY));\n  // Keep card_last_four_view at its natural size.\n  first_line->SetFlexForView(card_last_four_view, /*flex=*/0);\n\n  // Second line of the text content, the \"Card\" indicator label.\n  card_text_view->AddChildView(std::make_unique<views::Label>(\n      controller_->GetCardIndicatorLabel(),\n      views::style::CONTEXT_DIALOG_BODY_TEXT, views::style::STYLE_SECONDARY));\n}","pos":12,"query":"createCardInformationView","filepos":12,"timecost":1279.5395999999892,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\picture_in_picture\\picture_in_picture_occlusion_tracker.cc:263-309","function":"PictureInPictureOcclusionTracker::UpdateObserverStateForWidget","codesnippet":"{\n  const gfx::Rect observer_bounds = widget->GetWindowBoundsInScreen();\n  bool occluded = false;\n  for (const auto& [picture_in_picture_widget, observed_widget_data] :\n       observed_widget_data_) {\n    // We only care about occlusions from picture-in-picture widgets.\n    if (!observed_widget_data.is_picture_in_picture_widget) {\n      continue;\n    }\n\n    // Invisible widgets don't occlude anything.\n    if (!picture_in_picture_widget->IsVisible()) {\n      continue;\n    }\n\n    // If the observer widget is a child of this picture-in-picture widget (or\n    // the same widget), then it can't be occluded by it.\n    if (IsChildOfWidgetOrWidget(widget, picture_in_picture_widget)) {\n      continue;\n    }\n\n    const gfx::Rect picture_in_picture_bounds =\n        picture_in_picture_widget->GetWindowBoundsInScreen();\n    if (picture_in_picture_bounds.Intersects(observer_bounds)) {\n      occluded = true;\n      break;\n    }\n  }\n\n  auto iter = observed_widget_data_.find(widget);\n  CHECK(iter != observed_widget_data_.end());\n  if (!force_update && (occluded == iter->second.occluded)) {\n    return;\n  }\n\n  // Update the observers if the occlusion state has changed.\n  iter->second.occluded = occluded;\n  if (iter->second.forced_occlusion_state.has_value()) {\n    occluded = iter->second.forced_occlusion_state.value();\n  }\n  for (auto& observer : observers_) {\n    if (observer.occludable_widget() == widget) {\n      observer.occlusion_observer()->OnOcclusionStateChanged(occluded);\n    }\n  }\n}","pos":1,"query":"updateWidgetOcclusionState","filepos":0,"timecost":1797.823700000008,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\tabs\\tab_hover_card_bubble_view.cc:529-560","function":"TabHoverCardBubbleView::GetCollaborationMessagingData","codesnippet":"{\n  using collaboration::messaging::CollaborationEvent;\n\n  CollaborationMessagingRowData collaboration_messaging_data;\n  collaboration_messaging_data.should_show_collaboration_messaging = false;\n\n  auto data = tab_data.collaboration_messaging;\n  if (!data || !data->HasMessage()) {\n    return collaboration_messaging_data;\n  }\n\n  switch (data->collaboration_event()) {\n    case CollaborationEvent::TAB_ADDED:\n      collaboration_messaging_data.text = l10n_util::GetStringFUTF16(\n          IDS_DATA_SHARING_RECENT_ACTIVITY_MEMBER_ADDED_THIS_TAB,\n          data->given_name());\n      break;\n    case CollaborationEvent::TAB_UPDATED:\n      collaboration_messaging_data.text = l10n_util::GetStringFUTF16(\n          IDS_DATA_SHARING_RECENT_ACTIVITY_MEMBER_CHANGED_THIS_TAB,\n          data->given_name());\n      break;\n    default:\n      NOTREACHED();\n  }\n\n  collaboration_messaging_data.avatar = data->GetHoverCardImage(GetWidget());\n  collaboration_messaging_data.should_show_collaboration_messaging = true;\n\n  return collaboration_messaging_data;\n}","pos":-1,"query":"Generate collaboration messaging data","filepos":-1,"timecost":793.3540999999968,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\attestation\\tpm_challenge_key_result.cc:110-162","function":"unknown","codesnippet":"{\n  switch (result_code) {\n    case TpmChallengeKeyResultCode::kDevicePolicyDisabledError:\n      return kDevicePolicyDisabledErrorMsg;\n    case TpmChallengeKeyResultCode::kSignChallengeFailedError:\n      return kSignChallengeFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kUserNotManagedError:\n      return kUserNotManagedErrorMsg;\n    case TpmChallengeKeyResultCode::kKeyRegistrationFailedError:\n      return kKeyRegistrationFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kUserKeyNotAvailableError:\n      return kUserKeyNotAvailableErrorMsg;\n    case TpmChallengeKeyResultCode::kUserPolicyDisabledError:\n      return kUserPolicyDisabledErrorMsg;\n    case TpmChallengeKeyResultCode::kNonEnterpriseDeviceError:\n      return kNonEnterpriseDeviceErrorMsg;\n    case TpmChallengeKeyResultCode::kDbusError:\n      return kDbusErrorMsg;\n    case TpmChallengeKeyResultCode::kUserRejectedError:\n      return kUserRejectedErrorMsg;\n    case TpmChallengeKeyResultCode::kGetCertificateFailedError:\n      return kGetCertificateFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kResetRequiredError:\n      return kResetRequiredErrorMsg;\n    case TpmChallengeKeyResultCode::kAttestationUnsupportedError:\n      return kAttestationUnsupportedErrorMsg;\n    case TpmChallengeKeyResultCode::kTimeoutError:\n      return kTimeoutErrorMsg;\n    case TpmChallengeKeyResultCode::kDeviceWebBasedAttestationUrlError:\n      return kDeviceWebBasedAttestationUrlErrorMsg;\n    case TpmChallengeKeyResultCode::kExtensionNotAllowedError:\n      return kExtensionNotAllowedErrorMsg;\n    case TpmChallengeKeyResultCode::kChallengeBadBase64Error:\n      return kChallengeBadBase64ErrorMsg;\n    case TpmChallengeKeyResultCode::kDeviceWebBasedAttestationNotOobeError:\n      return kDeviceWebBasedAttestationNotOobeErrorMsg;\n    case TpmChallengeKeyResultCode::kGetPublicKeyFailedError:\n      return kGetPublicKeyFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kMarkCorporateKeyFailedError:\n      return kMarkCorporateKeyFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kAttestationServiceInternalError:\n      return kAttestationServiceInternalErrorMsg;\n    case TpmChallengeKeyResultCode::kUploadCertificateFailedError:\n      return kUploadCertificateFailedErrorMsg;\n    case TpmChallengeKeyResultCode::kDeviceTrustURLConflictError:\n      return kDeviceTrustURLConflictError;\n    case TpmChallengeKeyResultCode::kVerifiedAccessFlowUnsupportedError:\n      return kVerifiedAccessFlowUnsupportedErrorMsg;\n    case TpmChallengeKeyResultCode::kSuccess:\n      // Not an error message.\n      NOTREACHED();\n  }\n  NOTREACHED() << static_cast<int>(result_code);\n}","pos":-1,"query":"mapErrorCodeToMessage","filepos":-1,"timecost":1620.8535999999876,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_smart_switch\\smart_switch_notification_view.cc:196-228","function":"SmartSwitchNotificationView::CreateBubbleNotificationView","codesnippet":"{\n  auto notification_view = std::make_unique<views::View>();\n  auto* layout_manager =\n      notification_view->SetLayoutManager(std::make_unique<views::BoxLayout>(\n          views::BoxLayout::Orientation::kVertical,\n          gfx::Insets::TLBR(kVerticalSpacing, kBubbleBorder, kBubbleBorder,\n                            kBubbleBorder),\n          kVerticalSpacing));\n  layout_manager->set_cross_axis_alignment(\n      views::BoxLayout::CrossAxisAlignment::kStretch);\n\n  notification_view->AddChildView(CreateHeaderBar());\n\n  auto message = std::make_unique<views::Label>(content_);\n  message->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_LEFT);\n  message->SetBorder(views::CreateEmptyBorder(gfx::Insets::VH(0, 2)));\n  message->SetLineHeight(16);\n  notification_view->AddChildView(std::move(message));\n\n  auto link = std::make_unique<views::Link>(\n      l10n_util::GetStringUTF16(IDS_SMART_SWITCH_NOTIFICATION_LINK));\n  link->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_LEFT);\n  link->SetFontList(\n      link->font_list().DeriveWithWeight(gfx::Font::Weight::NORMAL));\n  link->SetLineHeight(16);\n  link->SetForceUnderline(false);\n  link->SetCallback(link_clicked_callback_);\n  link_ = notification_view->AddChildView(std::move(link));\n\n  notification_view->AddChildView(CreateButtonRow());\n\n  return notification_view;\n}","pos":-1,"query":"createNotificationViewWithHeaderLinkAndButton","filepos":48,"timecost":1193.500899999999,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\multidevice_internals\\multidevice_internals_phone_hub_handler.cc:102-145","function":"TryAddingMetadata","codesnippet":"{\n  const base::Value::Dict* browser_tab_metadata =\n      browser_tab_status_dict->FindDict(key);\n\n  if (!browser_tab_metadata) {\n    return;\n  }\n\n  const std::string* url = browser_tab_metadata->FindString(\"url\");\n  if (!url || url->empty()) {\n    return;\n  }\n\n  const std::string* title = browser_tab_metadata->FindString(\"title\");\n  if (!title) {\n    return;\n  }\n\n  // JavaScript time stamps don't fit in int.\n  std::optional<double> last_accessed_timestamp =\n      browser_tab_metadata->FindDouble(\"lastAccessedTimeStamp\");\n  if (!last_accessed_timestamp) {\n    return;\n  }\n\n  int favicon_image_type_as_int =\n      browser_tab_metadata->FindInt(\"favicon\").value_or(0);\n  if (!favicon_image_type_as_int) {\n    return;\n  }\n\n  auto favicon_image_type = static_cast<ImageType>(favicon_image_type_as_int);\n  gfx::Image favicon = gfx::Image::CreateFrom1xBitmap(\n      ImageTypeToBitmap(favicon_image_type, kIconSize));\n\n  auto metadata = phonehub::BrowserTabsModel::BrowserTabMetadata(\n      GURL(*url), base::UTF8ToUTF16(*title),\n      base::Time::FromMillisecondsSinceUnixEpoch(*last_accessed_timestamp),\n      favicon);\n\n  metadatas.push_back(metadata);\n}","pos":-1,"query":"Extracts and stores browser tab metadata","filepos":-1,"timecost":1293.3140999999887,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\policy\\enrollment\\enrollment_status.cc:11-45","function":"ToStringView","codesnippet":"{\n  switch (enrollment_code) {\n    case EnrollmentStatus::Code::kSuccess:\n      return \"Success\";\n    case EnrollmentStatus::Code::kNoStateKeys:\n      return \"NoStateKeys\";\n    case EnrollmentStatus::Code::kRegistrationFailed:\n      return \"RegistrationFailed\";\n    case EnrollmentStatus::Code::kRegistrationBadMode:\n      return \"RegistrationBadMode\";\n    case EnrollmentStatus::Code::kRobotAuthFetchFailed:\n      return \"RobotAuthFetchFailed\";\n    case EnrollmentStatus::Code::kRobotRefreshFetchFailed:\n      return \"RobotRefreshFetchFailed\";\n    case EnrollmentStatus::Code::kRobotRefreshStoreFailed:\n      return \"RobotRefreshStoreFailed\";\n    case EnrollmentStatus::Code::kPolicyFetchFailed:\n      return \"PolicyFetchFailed\";\n    case EnrollmentStatus::Code::kValidationFailed:\n      return \"ValidationFailed\";\n    case EnrollmentStatus::Code::kLockError:\n      return \"LockError\";\n    case EnrollmentStatus::Code::kStoreError:\n      return \"StoreError\";\n    case EnrollmentStatus::Code::kAttributeUpdateFailed:\n      return \"AttributeUpdateFailed\";\n    case EnrollmentStatus::Code::kRegistrationCertFetchFailed:\n      return \"RegistrationCertFetchFailed\";\n    case EnrollmentStatus::Code::kNoMachineIdentification:\n      return \"NoMachineIdentification\";\n    case EnrollmentStatus::Code::kDmTokenStoreFailed:\n      return \"DmTokenStoreFailed\";\n    case EnrollmentStatus::Code::kMayNotBlockDevMode:\n      return \"MayNotBlockDevMode\";\n  }\n}","pos":-1,"query":"mapEnrollmentCodeToString","filepos":-1,"timecost":1510.6240000000107,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_auth\\guided_switch\\edge_guided_switch_manager.cc:110-158","function":"EdgeGuidedSwitchManager::HandleActiveTabChanges","codesnippet":"{\n  const bool old_tab_has_request = HasOnGoingRequest(old_web_contents);\n  const bool new_tab_has_request = HasOnGoingRequest(new_web_contents);\n  bool show = true;\n  content::WebContents* web_content_to_use = new_web_contents;\n  if (old_tab_has_request && !new_tab_has_request) {\n    web_content_to_use = old_web_contents;\n    show = false;  // Hide.\n  } else if (!old_tab_has_request && new_tab_has_request) {\n    // Show.\n  } else {\n    return;\n  }\n\n  auto find_iter = current_request_map_.find(web_content_to_use);\n  if (find_iter == current_request_map_.end()) {\n    base::debug::DumpWithoutCrashing();\n    return;\n  }\n\n  Browser* browser = chrome::FindBrowserWithTab(web_content_to_use);\n  if (!browser) {\n    // Guided switch's owning view is being deleted or is already deleted. Close\n    // all backgrounds because guided switch will be closed.\n    for (auto& one_pair : browser_view_map_) {\n      HideBackgroundIfNeeded(one_pair.first, one_pair.second);\n    }\n  } else {\n    // Find the view and hide it.\n    auto view_iter = browser_view_map_.find(browser);\n    if (view_iter != browser_view_map_.end()) {\n      if (show) {\n        view_iter->second->Show();\n        // Hide others \"if needed\". Hide should be fine even if they are not\n        // visible. When web content is dragged to another browser, it becomes\n        // cleaner to hide all others \"if needed\", rather that tracking\n        // visibility and hiding.\n        for (auto& one_pair : browser_view_map_) {\n          if (one_pair.first != browser) {\n            HideBackgroundIfNeeded(one_pair.first, one_pair.second);\n          }\n        }\n      } else {\n        view_iter->second->Hide();\n      }\n    }\n  }\n}","pos":-1,"query":"ManageTabSwitchVisibility","filepos":-1,"timecost":913.0408999999927,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\mako\\mako_bubble_event_handler.cc:92-131","function":"ComputeResizingDirection","codesnippet":"{\n  // Detect resizing on corners.\n  if (pointer_pos.x() < (kWidgetCornerRadius + kWidgetPadding) &&\n      pointer_pos.y() < (kWidgetCornerRadius + kWidgetPadding)) {\n    return ResizingDirection::kTopLeft;\n  }\n  if (pointer_pos.x() >\n          (bounds.width() - kWidgetCornerRadius - kWidgetPadding) &&\n      pointer_pos.y() < (kWidgetCornerRadius + kWidgetPadding)) {\n    return ResizingDirection::kTopRight;\n  }\n  if (pointer_pos.x() < (kWidgetCornerRadius + kWidgetPadding) &&\n      pointer_pos.y() >\n          (bounds.height() - kWidgetCornerRadius - kWidgetPadding)) {\n    return ResizingDirection::kBottomLeft;\n  }\n  if (pointer_pos.x() >\n          (bounds.width() - kWidgetCornerRadius - kWidgetPadding) &&\n      pointer_pos.y() >\n          (bounds.height() - kWidgetCornerRadius - kWidgetPadding)) {\n    return ResizingDirection::kBottomRight;\n  }\n\n  // Detect resizing on edges.\n  if (pointer_pos.x() < kResizingRegionWidth) {\n    return ResizingDirection::kLeft;\n  }\n  if (pointer_pos.x() > bounds.width() - kResizingRegionWidth) {\n    return ResizingDirection::kRight;\n  }\n  if (pointer_pos.y() < kResizingRegionWidth) {\n    return ResizingDirection::kTop;\n  }\n  if (pointer_pos.y() > bounds.height() - kResizingRegionWidth) {\n    return ResizingDirection::kBottom;\n  }\n\n  // Otherwise, it's not resizing.\n  return ResizingDirection::kNone;\n}","pos":-1,"query":"detectResizingDirection","filepos":1,"timecost":1816.4796999999962,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\file_suggest\\drive_file_suggestion_provider.cc:188-242","function":"DriveFileSuggestionProvider::OnDriveFilePathsLocated","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  // If validation fails, return early.\n  if (!paths) {\n    EndDriveFilePathValidation(\n        DriveSuggestValidationStatus::kPathLocationFailed,\n        /*suggest_results=*/std::nullopt);\n    return;\n  }\n\n  DCHECK_EQ(raw_suggest_results.size(), paths->size());\n\n  std::vector<FileSuggestData> suggest_results;\n  for (size_t index = 0; index < paths->size(); ++index) {\n    const auto& path_or_error = paths->at(index);\n\n    // Fail to validate the file path at `index`, so skip this loop iteration.\n    if (!path_or_error->is_path()) {\n      continue;\n    }\n\n    std::optional<std::u16string> reason;\n    if (raw_suggest_results[index].prediction_reason) {\n      reason = base::UTF8ToUTF16(\n          raw_suggest_results[index].prediction_reason.value());\n    }\n    suggest_results.emplace_back(\n        FileSuggestionType::kDriveFile,\n        ReparentToDriveMount(path_or_error->get_path(), drive_service_),\n        /*title=*/std::nullopt, reason,\n        /*modified_time=*/std::nullopt,\n        /*viewed_time=*/std::nullopt,\n        /*shared_time=*/std::nullopt,\n        /*score=*/std::nullopt,\n        /*drive_file_id=*/std::nullopt,\n        /*icon_url=*/std::nullopt);\n  }\n\n  // Validation fails on each file, so return early.\n  if (suggest_results.empty()) {\n    EndDriveFilePathValidation(DriveSuggestValidationStatus::kAllFilesErrored,\n                               /*suggest_results=*/std::nullopt);\n    return;\n  }\n\n  result_filter_task_runner_->PostTaskAndReplyWithResult(\n      FROM_HERE,\n      base::BindOnce(&FilterSuggestResultsByTime, suggest_results,\n                     drive_file_max_last_modified_time_),\n      base::BindOnce(&DriveFileSuggestionProvider::EndDriveFilePathValidation,\n                     weak_factory_.GetWeakPtr(),\n                     DriveSuggestValidationStatus::kOk));\n}","pos":-1,"query":"validateAndFilterDriveFileSuggestions","filepos":-1,"timecost":912.6731,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_android_webview\\renderer\\aw_render_view_ext.cc:39-73","function":"AwRenderViewExt::UpdateContentsSize","codesnippet":"{\n  blink::WebView* webview = GetWebView();\n  blink::WebFrame* main_frame = webview->MainFrame();\n\n  // Even without out-of-process iframes, we now create RemoteFrames for the\n  // main frame when you navigate cross-process, to create a placeholder in the\n  // old process. This is necessary to support things like postMessage across\n  // windows that have references to each other. The RemoteFrame will\n  // immediately go away if there aren't any active frames left in the old\n  // process.\n  if (!main_frame->IsWebLocalFrame())\n    return;\n\n  if (!needs_contents_size_update_)\n    return;\n  needs_contents_size_update_ = false;\n\n  gfx::Size contents_size = main_frame->ToWebLocalFrame()->DocumentSize();\n\n  // Fall back to contentsPreferredMinimumSize if the mainFrame is reporting a\n  // 0x0 size (this happens during initial load).\n  if (contents_size.IsEmpty()) {\n    contents_size = webview->ContentsPreferredMinimumSize();\n  }\n\n  if (contents_size == last_sent_contents_size_)\n    return;\n\n  last_sent_contents_size_ = contents_size;\n\n  mojo::AssociatedRemote<mojom::FrameHost> frame_host_remote;\n  content::RenderFrame::FromWebFrame(main_frame->ToWebLocalFrame())\n      ->GetRemoteAssociatedInterfaces()\n      ->GetInterface(&frame_host_remote);\n  frame_host_remote->ContentsSizeChanged(contents_size);\n}","pos":1,"query":"updateFrameContentsSize","filepos":1,"timecost":1348.029800000004,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\app_service\\app_service_app_model_builder.cc:49-97","function":"AppServiceAppModelBuilder::OnAppUpdate","codesnippet":"{\n  ChromeAppListItem* item = GetAppItem(update.AppId());\n  bool show = ShouldShowInLauncher(update);\n  if (item) {\n    if (show) {\n      DCHECK_EQ(item->GetItemType(), AppServiceAppItem::kItemType);\n      static_cast<AppServiceAppItem*>(item)->OnAppUpdate(update);\n\n      // TODO(crbug.com/40569217): drop the check for kChromeApp or kWeb, and\n      // call UpdateItem unconditionally?\n      apps::AppType app_type = update.AppType();\n      if ((app_type == apps::AppType::kChromeApp) ||\n          (app_type == apps::AppType::kSystemWeb) ||\n          (app_type == apps::AppType::kWeb)) {\n        app_list::AppListSyncableService* serv = service();\n        if (serv) {\n          serv->UpdateItem(item);\n        }\n      }\n\n    } else {\n      bool unsynced_change = false;\n      if (update.AppType() == apps::AppType::kArc) {\n        // Don't sync app removal in case it was caused by disabling Google\n        // Play Store.\n        unsynced_change = !arc::IsArcPlayStoreEnabledForProfile(profile());\n      }\n\n      if (update.InstalledInternally()) {\n        // Don't sync default app removal as default installed apps are not\n        // synced.\n        unsynced_change = true;\n      }\n\n      if (update.Readiness() == apps::Readiness::kUninstalledByNonUser) {\n        // Don't sync migration uninstallations as it will interfere with other\n        // devices doing their own migration.\n        unsynced_change = true;\n      }\n\n      RemoveApp(update.AppId(), unsynced_change);\n    }\n\n  } else if (show) {\n    InsertApp(std::make_unique<AppServiceAppItem>(\n        profile(), model_updater(),\n        GetSyncItem(update.AppId(), sync_pb::AppListSpecifics::TYPE_APP),\n        update));\n  }\n}","pos":-1,"query":"Update or manage app list item","filepos":-1,"timecost":1101.871800000008,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\tab_search\\tab_search_ui.cc:337-368","function":"TabSearchUI::CreatePageHandler","codesnippet":"{\n  DCHECK(page);\n\n  // CreatePageHandler() can be called multiple times if reusing the same\n  // WebUIController. For eg refreshing the page will create new PageHandler but\n  // reuse TabSearchUI. Check to make sure |page_handler_timer_| is valid before\n  // logging metrics.\n  if (page_handler_timer_.has_value()) {\n    TRACE_EVENT_NESTABLE_ASYNC_END0(\n        \"browser\", \"TabSearchPageHandlerConstructionDelay\", this);\n    UmaHistogramMediumTimes(\"Tabs.TabSearch.PageHandlerConstructionDelay\",\n                            page_handler_timer_->Elapsed());\n\n    UmaHistogramMediumTimes(\"Microsoft.Tabs.TabSearch.PageHandlerConstructionDelay\",\n                            page_handler_timer_->Elapsed());\n    page_handler_timer_.reset();\n  }\n\n  MetricsReporterService* service =\n      MetricsReporterService::GetFromWebContents(web_ui()->GetWebContents());\n\n  // TODO(tluk): Investigate whether we can avoid recreating this multiple times\n  // per instance of the TabSearchUI.\n  page_handler_ = std::make_unique<TabSearchPageHandler>(\n      std::move(receiver), std::move(page), web_ui(), this,\n      service->metrics_reporter());\n\n  if (!page_handler_creation_callback_.is_null()) {\n    std::move(page_handler_creation_callback_).Run();\n  }\n}","pos":-1,"query":"InitializeTabSearchPageHandlerWithMetrics","filepos":-1,"timecost":1148.7835999999952,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\media\\webrtc\\permission_bubble_media_access_handler.cc:256-295","function":"PermissionBubbleMediaAccessHandler::OnMediaStreamRequestResponse","codesnippet":"{\n  if (pending_requests_.find(web_contents) == pending_requests_.end()) {\n    // WebContents has been destroyed. Don't need to do anything.\n    return;\n  }\n\n  // If the kill switch is, or the request was blocked because of permissions\n  // policy we don't update the tab context.\n  if (result != blink::mojom::MediaStreamRequestResult::KILL_SWITCH_ON &&\n      !blocked_by_permissions_policy) {\n    UpdatePageSpecificContentSettings(web_contents, request, audio_setting,\n                                      video_setting);\n  }\n\n  // At most one stream is expected as this function is not used with the\n  // getAllScreensMedia API (only used with getUserMedia).\n  DCHECK_LE(stream_devices_set.stream_devices.size(), 1u);\n  blink::mojom::StreamDevices devices;\n  if (!stream_devices_set.stream_devices.empty()) {\n    devices = *stream_devices_set.stream_devices[0];\n  }\n\n  std::unique_ptr<content::MediaStreamUI> ui;\n  if (!stream_devices_set.stream_devices.empty() &&\n      (stream_devices_set.stream_devices[0]->audio_device.has_value() ||\n       stream_devices_set.stream_devices[0]->video_device.has_value())) {\n    ui = MediaCaptureDevicesDispatcher::GetInstance()\n             ->GetMediaStreamCaptureIndicator()\n             ->RegisterMediaStream(web_contents, devices);\n  }\n  OnAccessRequestResponse(web_contents, request_id, stream_devices_set, result,\n                          std::move(ui));\n}","pos":23,"query":"Handle media stream access request","filepos":23,"timecost":946.6405999999988,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_compose\\compose_client_web_socket.cc:124-162","function":"WebSocketResponseDecoder::Decode","codesnippet":"{\n  std::optional<base::Value> metadata_response =\n      base::JSONReader::Read(response_text);\n\n  if (!metadata_response.has_value() || !metadata_response->is_dict()) {\n    return {};\n  }\n\n  const base::Value::Dict& response_dict = metadata_response->GetDict();\n  if (response_dict.empty()) {\n    return {};\n  }\n  auto* type_value = response_dict.Find(\"type\");\n  if (type_value == nullptr || !type_value->is_int()) {\n    return {};\n  }\n\n  std::vector<std::unique_ptr<EdgeComposeResponse>> result;\n  int type = type_value->GetInt();\n  if (type == static_cast<int>(SignalRMessageType::kInvocation)) {\n    std::string bot_response = ExtractBotResponse(response_dict);\n    if (bot_response.empty()) {\n      return result;\n    }\n    std::unique_ptr<EdgeComposeResponse> response =\n        std::make_unique<EdgeComposeResponse>();\n    response->content_ = std::move(bot_response);\n    response->data_type_ = EdgeComposeDataType::kText;\n    response->is_complete_ = false;\n    result.push_back(std::move(response));\n  } else if (type == static_cast<int>(SignalRMessageType::kStreamItem)) {\n    std::unique_ptr<EdgeComposeResponse> response =\n        std::make_unique<EdgeComposeResponse>();\n    response->is_complete_ = true;\n    result.push_back(std::move(response));\n  }\n\n  return result;\n}","pos":-1,"query":"ParseAndProcessMetadataResponse","filepos":-1,"timecost":1505.6354999999894,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\android\\tab_model\\android_live_tab_context.cc:177-213","function":"unknown","codesnippet":"{\n  Profile* profile = tab_model_->GetProfile();\n\n  // Prepare navigation history.\n  std::vector<std::unique_ptr<content::NavigationEntry>> nav_entries =\n      sessions::ContentSerializedNavigationBuilder::ToNavigationEntries(\n          tab.navigations, profile);\n\n  // Restore web contents with navigation history. This is used for background\n  // restore so start without a renderer.\n  auto params = content::WebContents::CreateParams(profile);\n  params.desired_renderer_state =\n      content::WebContents::CreateParams::kNoRendererProcess;\n  params.initially_hidden = true;\n  std::unique_ptr<content::WebContents> web_contents =\n      content::WebContents::Create(params);\n  content::WebContents* raw_web_contents = web_contents.get();\n  web_contents->GetController().Restore(tab.normalized_navigation_index(),\n                                        content::RestoreType::kRestored,\n                                        &nav_entries);\n\n  // Create new tab. Ownership is passed into java, which in turn creates a new\n  // TabAndroid instance to own the WebContents. Only select the restored tab\n  // when restoring a single tab from a TAB session.\n  tab_model_->CreateTab(\n      nullptr, web_contents.release(),\n      original_session_type == sessions::tab_restore::TAB ? true : false);\n  // Don't load the tab yet. This prevents a renderer from starting which keeps\n  // the tab restore lightweight as the tab is opened in the background only.\n  // The tab will be in a \"renderer was lost\" state. This is recovered from when\n  // the tab is made active.\n  return sessions::ContentLiveTab::GetForWebContents(raw_web_contents);\n}","pos":-1,"query":"RestoreTabWithNavigationHistory","filepos":-1,"timecost":935.5640999999887,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\search\\ranking\\score_normalizing_ranker.cc:50-81","function":"ScoreNormalizingRanker::UpdateResultRanks","codesnippet":"{\n  if (ShouldIgnoreProvider(provider)) {\n    return;\n  }\n\n  auto it = results.find(provider);\n  DCHECK(it != results.end());\n\n  // Skip normalization for continue section files - in continue section, files\n  // are either\n  // *   scored consistently based on the file timestamps (for\n  //     `ash::features::UseMixedFileLauncherContinueSection()`), or\n  // *   results from one provider are always preferred over the other, so\n  //     keeping existing scoring within the provider is sufficient.\n  if (provider == ProviderType::kZeroStateDrive ||\n      provider == ProviderType::kZeroStateFile) {\n    for (auto& result : it->second) {\n      result->scoring().set_normalized_relevance(result->relevance());\n    }\n    return;\n  }\n\n  std::string provider_string = ProviderToString(provider);\n  for (auto& result : it->second) {\n    normalizer_.Update(provider_string, result->relevance());\n  }\n\n  for (auto& result : it->second) {\n    result->scoring().set_normalized_relevance(\n        normalizer_.Normalize(provider_string, result->relevance()));\n  }\n}","pos":-1,"query":"NormalizeProviderResultsRelevance","filepos":-1,"timecost":1420.6186999999918,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\login\\saml\\password_sync_token_fetcher.cc:282-328","function":"PasswordSyncTokenFetcher::OnSimpleLoaderComplete","codesnippet":"{\n  int response_code = -1;\n  if (simple_url_loader_->ResponseInfo() &&\n      simple_url_loader_->ResponseInfo()->headers) {\n    response_code =\n        simple_url_loader_->ResponseInfo()->headers->response_code();\n  }\n  std::string json_string;\n  if (response_body)\n    json_string = std::move(*response_body);\n  simple_url_loader_.reset();\n\n  JSONStringValueDeserializer deserializer(json_string);\n  std::string error_msg;\n  std::unique_ptr<base::Value> json_value =\n      deserializer.Deserialize(/*error_code=*/nullptr, &error_msg);\n\n  if (!response_body || (response_code != net::HTTP_OK)) {\n    const auto* error_json = json_value && json_value->is_dict()\n                                 ? json_value->GetDict().FindDict(kErrorKey)\n                                 : nullptr;\n    const std::string* error =\n        error_json ? error_json->FindString(kErrorDescription) : nullptr;\n\n    LOG(WARNING) << \"Server returned wrong response code: \" << response_code\n                 << \": \" << (error ? *error : \"Unknown\") << \".\";\n    RecordEvent(InSessionPasswordSyncEvent::kErrorWrongResponseCode);\n    consumer_->OnApiCallFailed(ErrorType::kServerError);\n    return;\n  }\n\n  if (!json_value) {\n    LOG(WARNING) << \"Unable to deserialize json data.\";\n    RecordEvent(InSessionPasswordSyncEvent::kErrorInSerializedResponse);\n    consumer_->OnApiCallFailed(ErrorType::kInvalidJson);\n    return;\n  }\n\n  if (!json_value->is_dict()) {\n    LOG(WARNING) << \"Response is not a JSON dictionary.\";\n    RecordEvent(InSessionPasswordSyncEvent::kErrorInSerializedResponse);\n    consumer_->OnApiCallFailed(ErrorType::kNotJsonDict);\n    return;\n  }\n\n  ProcessValidTokenResponse(std::move(json_value->GetDict()));\n}","pos":-1,"query":"Handle API response and process JSON data","filepos":-1,"timecost":1405.5054999999993,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_nurturing\\url_parser\\nurturing_url_parser_browser_list_observer.cc:189-226","function":"NurturingUrlParserBrowserListObserver::HandleNurturingURLCampaign","codesnippet":"{\n  std::unique_ptr<base::Value::Dict> nurturing_param_values =\n      nurturing_url_parser_->GetNurturingParamValues(profile_.get());\n  std::optional<std::string*> campaign_id =\n      nurturing_param_values->FindString(kNurturingTargetCampaignParam);\n  if (!campaign_id.has_value()) {\n    return;\n  }\n  metrics::GetMetricsUtilInstance()->LogCampaignUIState(\n      metrics::UIState::kSourceIsExternal,\n      utility::GetMetadata(profile_.get(), *campaign_id.value()));\n  std::unique_ptr<UrlCampaignTrigger> url_campaign_trigger =\n      UrlCampaignTriggerFactory::GetTrigger(*campaign_id.value());\n  if (!profile_ ||\n      !url_campaign_trigger->ShouldTriggerCampaign(profile_.get())) {\n    return;\n  }\n  std::optional<int> target_surface =\n      nurturing_param_values->FindInt(kNurturingTargetSurfaceParam);\n  if (!target_surface.has_value()) {\n    return;\n  }\n  url_campaign_data_fetcher_ =\n      UrlCampaignDataFetcherFactory::GetCampaignDataFetcher(\n          *campaign_id.value());\n  if (url_campaign_data_fetcher_) {\n    // wait until campaign resources are fetched and remove observer\n    // there.\n    remove_observer = false;\n    url_campaign_data_fetcher_->RequestCampaignData(\n        profile_.get(),\n        base::BindRepeating(\n            &NurturingUrlParserBrowserListObserver::OnCampaignResourcesReceived,\n            weak_ptr_factory_.GetWeakPtr(), profile_.get(),\n            static_cast<TargetSurface>(target_surface.value()),\n            *campaign_id.value()));\n  }\n}","pos":-1,"query":"Handle nurturing campaign data fetching","filepos":-1,"timecost":2027.4732999999978,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\glic\\host\\glic_annotation_manager.cc:32-192","function":"GlicAnnotationManager::ScrollTo","codesnippet":"{\n  CHECK(base::FeatureList::IsEnabled(features::kGlicScrollTo));\n  if (annotation_task_ && annotation_task_->IsRunning()) {\n    annotation_task_->FailTask(mojom::ScrollToErrorReason::kNewerScrollToCall);\n  }\n  annotation_task_.reset();\n\n  mojom::ScrollToSelector* selector = params->selector.get();\n  std::optional<shared_highlighting::TextFragment> text_fragment;\n  std::optional<int> search_range_start_node_id = std::nullopt;\n  std::optional<int> node_id = std::nullopt;\n\n  if (selector->is_exact_text_selector()) {\n    auto* exact_text_selector = selector->get_exact_text_selector().get();\n    const std::string& exact_text = exact_text_selector->text;\n    if (exact_text.empty()) {\n      std::move(callback).Run(mojom::ScrollToErrorReason::kNotSupported);\n      return;\n    }\n    if (exact_text_selector->search_range_start_node_id.has_value()) {\n      if (!params->document_id) {\n        mojo::ReportBadMessage(\n            \"When the range_start_node_id is set, the document_id should be \"\n            \"set as well.\");\n        return;\n      }\n      search_range_start_node_id =\n          exact_text_selector->search_range_start_node_id;\n    }\n    text_fragment = shared_highlighting::TextFragment(exact_text);\n  } else if (selector->is_text_fragment_selector()) {\n    auto* text_fragment_selector = selector->get_text_fragment_selector().get();\n    const std::string& text_start = text_fragment_selector->text_start;\n    if (text_start.empty()) {\n      std::move(callback).Run(mojom::ScrollToErrorReason::kNotSupported);\n      return;\n    }\n    const std::string& text_end = text_fragment_selector->text_end;\n    if (text_end.empty()) {\n      std::move(callback).Run(mojom::ScrollToErrorReason::kNotSupported);\n      return;\n    }\n    if (text_fragment_selector->search_range_start_node_id.has_value()) {\n      if (!params->document_id) {\n        mojo::ReportBadMessage(\n            \"When the range_start_node_id is set, the document_id should be \"\n            \"set as well.\");\n        return;\n      }\n      search_range_start_node_id =\n          text_fragment_selector->search_range_start_node_id;\n    }\n    text_fragment = shared_highlighting::TextFragment(text_start, text_end,\n                                                      /*prefix=*/std::string(),\n                                                      /*suffix=*/std::string());\n  } else if (selector->is_node_selector()) {\n    if (!params->document_id) {\n      mojo::ReportBadMessage(\n          \"When node_id is set, document_id should be set as well.\");\n      return;\n    }\n    node_id = selector->get_node_selector()->node_id;\n  } else {\n    mojo::ReportBadMessage(\n        \"The client should have verified that one of the selector types was \"\n        \"specified.\");\n    return;\n  }\n\n  // \"exact_text\" and \"text_fragment\" selectors will set `text_fragment`, \"node\"\n  // selector will set `node_id`.\n  CHECK(text_fragment.has_value() || node_id.has_value());\n\n  if (!service_->profile()->GetPrefs()->GetBoolean(\n          prefs::kGlicTabContextEnabled)) {\n    std::move(callback).Run(\n        mojom::ScrollToErrorReason::kTabContextPermissionDisabled);\n    return;\n  }\n\n  auto focused_tab_data = service_->GetFocusedTabData();\n  content::Page* focused_primary_page = nullptr;\n  if (focused_tab_data.focus()) {\n    focused_primary_page = &focused_tab_data.focus()->GetPrimaryPage();\n  }\n  if (!focused_primary_page) {\n    std::move(callback).Run(mojom::ScrollToErrorReason::kNoFocusedTab);\n    return;\n  }\n\n  // Note: `GlicWindowController::IsShowing()` will be false and\n  // `focused_primary_page` will be non-null when `GlicWindowController` is\n  // running the close animation.\n  if (!service_->window_controller().IsShowing()) {\n    std::move(callback).Run(mojom::ScrollToErrorReason::kNoFocusedTab);\n    return;\n  }\n\n  if (annotation_agent_container_.has_value() &&\n      annotation_agent_container_->document.AsRenderFrameHostIfValid() !=\n          &focused_primary_page->GetMainDocument()) {\n    annotation_agent_container_ = std::nullopt;\n  }\n\n  if (!annotation_agent_container_.has_value()) {\n    annotation_agent_container_.emplace();\n    annotation_agent_container_->document =\n        focused_primary_page->GetMainDocument().GetWeakDocumentPtr();\n    focused_primary_page->GetMainDocument().GetRemoteInterfaces()->GetInterface(\n        annotation_agent_container_->remote.BindNewPipeAndPassReceiver());\n  }\n\n  // The caller currently only enforces if the documentId is set when DOMNodeId\n  // selector parameters are set. If this is configured to be true, we will\n  // always check that the documentId is set, and fail otherwise.\n  const bool fail_without_document_id =\n      features::kGlicScrollToEnforceDocumentId.Get();\n  if (fail_without_document_id && !params->document_id) {\n    std::move(callback).Run(glic::mojom::ScrollToErrorReason::kNotSupported);\n    return;\n  }\n\n  // Verifies that the document_id parameter (if set) refers to the primary\n  // document in the currently focused tab.\n  if (params->document_id) {\n    // We only support scrolling the currently focused tab's main frame.\n    content::RenderFrameHost& rfh = focused_primary_page->GetMainDocument();\n    auto* document_identifier_user_data =\n        optimization_guide::DocumentIdentifierUserData::GetForCurrentDocument(\n            &rfh);\n    if (!document_identifier_user_data ||\n        document_identifier_user_data->serialized_token() !=\n            params->document_id) {\n      std::move(callback).Run(\n          glic::mojom::ScrollToErrorReason::kNoMatchingDocument);\n      return;\n    }\n  }\n\n  blink::mojom::SelectorPtr blink_mojom_selector;\n  if (text_fragment) {\n    blink_mojom_selector = blink::mojom::Selector::NewSerializedSelector(\n        text_fragment->ToEscapedString(\n            shared_highlighting::TextFragment::EscapedStringFormat::\n                kWithoutTextDirective));\n  } else {\n    blink_mojom_selector = blink::mojom::Selector::NewNodeId(node_id.value());\n  }\n\n  mojo::PendingReceiver<blink::mojom::AnnotationAgentHost> agent_host_receiver;\n  mojo::Remote<blink::mojom::AnnotationAgent> agent_remote;\n  annotation_agent_container_->remote->CreateAgent(\n      agent_host_receiver.InitWithNewPipeAndPassRemote(),\n      agent_remote.BindNewPipeAndPassReceiver(),\n      blink::mojom::AnnotationType::kGlic, std::move(blink_mojom_selector),\n      search_range_start_node_id);\n  annotation_task_ = std::make_unique<AnnotationTask>(\n      this, std::move(agent_remote), std::move(agent_host_receiver),\n      std::move(callback), *focused_primary_page);\n}","pos":-1,"query":"scrollToElementWithSelectorValidation","filepos":-1,"timecost":1417.403600000005,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\first_party_sets\\first_party_sets_overrides_policy_handler.cc:73-104","function":"FirstPartySetsOverridesPolicyHandler::CheckPolicySettings","codesnippet":"{\n  std::unique_ptr<base::Value> policy_value;\n  if (!policy::SchemaValidatingPolicyHandler::CheckAndGetValue(policies, errors,\n                                                               &policy_value) ||\n      !policy_value) {\n    return false;\n  }\n\n  // Output error and return false if any of the sets provided in the\n  // \"replacements\" or \"additions\" list are not valid First-Party Sets.\n  auto [success, warnings] =\n      content::FirstPartySetsHandler::ValidateEnterprisePolicy(\n          policy_value->GetDict());\n\n  // Output warnings that occur when parsing the policy.\n  for (const ParseWarning& parse_warning : warnings) {\n    errors->AddError(policy_name(), IDS_POLICY_SCHEMA_VALIDATION_ERROR,\n                     ParseWarningTypeToString(parse_warning.type()),\n                     parse_warning.path(),\n                     policy::PolicyMap::MessageType::kWarning);\n  }\n\n  if (!success.has_value()) {\n    ParseError parse_error = success.error();\n    errors->AddError(policy_name(), IDS_POLICY_SCHEMA_VALIDATION_ERROR,\n                     ParseErrorTypeToString(parse_error.type()),\n                     parse_error.path());\n    return false;\n  }\n  return true;\n}","pos":-1,"query":"Validate and log policy schema errors","filepos":-1,"timecost":1241.1869000000006,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\net\\net_error_tab_helper.cc:171-224","function":"NetErrorTabHelper::DidFinishNavigation","codesnippet":"{\n  if (!navigation_handle->IsInPrimaryMainFrame())\n    return;\n\n  if (net::IsHostnameResolutionError(navigation_handle->GetNetErrorCode())) {\n    dns_error_active_ = true;\n    OnMainFrameDnsError();\n  }\n\n  // Resend status every time an error page commits; this is somewhat spammy,\n  // but ensures that the status will make it to the real error page, even if\n  // the link doctor loads a blank intermediate page or the tab switches\n  // renderer processes.\n  if (navigation_handle->IsErrorPage() && dns_error_active_) {\n    dns_error_page_committed_ = true;\n    DVLOG(1) << \"Committed error page; resending status.\";\n    SendInfo();\n  } else if (navigation_handle->HasCommitted() &&\n             !navigation_handle->IsErrorPage()) {\n    dns_error_active_ = false;\n    dns_error_page_committed_ = false;\n#if BUILDFLAG(ENABLE_OFFLINE_PAGES)\n    is_showing_download_button_in_error_page_ = false;\n#endif  // BUILDFLAG(ENABLE_OFFLINE_PAGES)\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    if (clearedcookies_active_) {\n      content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();\n      mojo::AssociatedRemote<edge::mojom::NetworkClearCookiesClient> client;\n      rfh->GetRemoteAssociatedInterfaces()->GetInterface(&client);\n      client->SuccessfulReload();\n    }\n\n    if (too_many_redirects_error_active_ &&\n        navigation_handle->GetReloadType() != content::ReloadType::NONE) {\n      // The successful navigation was due to a reload of the page after a error\n      // page\n      edge::EdgeLogNetErrorEvent(edge::EdgeNetworkErrorTabHelperEvent::\n                                     kNetErrorTooManyRedirectsReloadSuccess);\n    }\n\n    too_many_redirects_error_active_ = false;\n    clearedcookies_active_ = false;\n#endif\n  }\n\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n  if (navigation_handle->IsErrorPage() &&\n      navigation_handle->GetNetErrorCode() == net::ERR_TOO_MANY_REDIRECTS) {\n    too_many_redirects_error_active_ = true;\n    edge::EdgeLogNetErrorEvent(\n        edge::EdgeNetworkErrorTabHelperEvent::kNetErrorTooManyRedirects);\n  }\n#endif\n}","pos":-1,"query":"Handle DNS and redirect errors during navigation","filepos":-1,"timecost":1166.8203999999969,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\cloud_upload\\drive_upload_handler.cc:351-403","function":"DriveUploadHandler::ShowIOTaskError","codesnippet":"{\n  OfficeFilesUploadResult upload_result;\n  std::string error_message;\n  bool copy = upload_type_ == UploadType::kCopy;\n\n  // TODO(b/242685536) Find most relevant error in a multi-file upload when\n  // support for multi-files is added.\n  base::File::Error file_error =\n      GetFirstTaskError(status).value_or(base::File::FILE_ERROR_FAILED);\n\n  if (copy) {\n    cloud_open_metrics_->LogCopyError(file_error);\n  } else {\n    cloud_open_metrics_->LogMoveError(file_error);\n  }\n\n  switch (file_error) {\n    case base::File::FILE_ERROR_NO_SPACE:\n      upload_result = OfficeFilesUploadResult::kCloudQuotaFull;\n      // TODO(b/242685536) Use \"these files\" for multi-files when support for\n      // multi-files is added.\n      error_message = base::UTF16ToUTF8(\n          base::i18n::MessageFormatter::FormatWithNumberedArgs(\n              l10n_util::GetStringUTF16(\n                  copy ? IDS_OFFICE_UPLOAD_ERROR_FREE_UP_SPACE_TO_COPY\n                       : IDS_OFFICE_UPLOAD_ERROR_FREE_UP_SPACE_TO_MOVE),\n              // TODO(b/242685536) Update when support for multi-files is added.\n              1,\n              l10n_util::GetStringUTF16(\n                  IDS_OFFICE_CLOUD_PROVIDER_GOOGLE_DRIVE_SHORT)));\n      break;\n    case base::File::FILE_ERROR_NOT_FOUND:\n      if (copy) {\n        upload_result = OfficeFilesUploadResult::kCopyOperationError;\n      } else {\n        upload_result = OfficeFilesUploadResult::kMoveOperationError;\n      }\n      error_message = l10n_util::GetStringUTF8(\n          copy ? IDS_OFFICE_UPLOAD_ERROR_FILE_NOT_EXIST_TO_COPY\n               : IDS_OFFICE_UPLOAD_ERROR_FILE_NOT_EXIST_TO_MOVE);\n      break;\n    default:\n      if (copy) {\n        upload_result = OfficeFilesUploadResult::kCopyOperationError;\n      } else {\n        upload_result = OfficeFilesUploadResult::kMoveOperationError;\n      }\n      LOG(ERROR) << \"IO Task error\";\n      error_message = GetGenericErrorMessage();\n  }\n\n  OnEndCopy(upload_result, base::unexpected(error_message));\n}","pos":-1,"query":"handleFileUploadError","filepos":219,"timecost":1358.6408000000083,"filemrr":0.7},{"filePath":"D:\\Edge\\src\\chrome\\browser\\k_anonymity_service\\k_anonymity_trust_token_getter.cc:483-517","function":"KAnonymityTrustTokenGetter::FetchTrustToken","codesnippet":"{\n  auto key_commitment = storage_->GetKeyAndNonUniqueUserId();\n  DCHECK(key_commitment);\n\n  RecordTrustTokenGetterAction(\n      KAnonymityTrustTokenGetterAction::kFetchTrustToken);\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = auth_origin_.GetURL().Resolve(base::StringPrintf(\n      kIssueTrustTokenPathFmt, key_commitment->key_and_id.non_unique_user_id));\n  resource_request->method = net::HttpRequestHeaders::kPostMethod;\n  resource_request->headers.SetHeader(\n      net::HttpRequestHeaders::kAuthorization,\n      base::StrCat({\"Bearer \", access_token_.token}));\n  resource_request->credentials_mode =\n      network::mojom::CredentialsMode::kOmit;  // No cache read, always download\n                                               // from the network.\n  resource_request->load_flags =\n      net::LOAD_DISABLE_CACHE | net::LOAD_BYPASS_CACHE;\n  resource_request->trusted_params.emplace();\n  resource_request->trusted_params->isolation_info = isolation_info_;\n\n  network::mojom::TrustTokenParamsPtr params =\n      network::mojom::TrustTokenParams::New();\n  params->operation = network::mojom::TrustTokenOperationType::kIssuance;\n  params->custom_key_commitment = key_commitment->key_and_id.key_commitment;\n  resource_request->trust_token_params = *params;\n#if EXCLUDED_FROM_EDGE\n  url_loader_ = network::SimpleURLLoader::Create(\n      std::move(resource_request), kKAnonymityServiceGetTokenTrafficAnnotation);\n  url_loader_->SetTimeoutDuration(kRequestTimeout);\n  url_loader_->DownloadHeadersOnly(\n      url_loader_factory_.get(),\n      base::BindOnce(&KAnonymityTrustTokenGetter::OnFetchedTrustToken,\n                     weak_ptr_factory_.GetWeakPtr()));\n#endif  // EXCLUDED_FROM_EDGE\n}","pos":0,"query":"fetchTrustTokenFromNetwork","filepos":0,"timecost":1057.6747000000032,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_desktop\\fre\\navigation_view.cc:74-120","function":"NavigationView::NavigationView","codesnippet":"{\n  auto edge_close_icon = gfx::CreateVectorIcon(kEdgeCloseIcon, kCloseIconSize,\n                                               gfx::edge::kEdgeDarkGray);\n  close_button_ = AddChildView(CreateButton(\n      base::BindRepeating(&NavigationView::Close, weak_factory_.GetWeakPtr()),\n      edge_close_icon, IDS_WEB_WIDGET_SEARCH_ONLY_FRE_CLOSE_BUTTON_TOOLTIP));\n\n  auto left_chevron_icon = gfx::CreateVectorIcon(\n      kWebWidgetFreChevronLeftIcon, kChevronIconSize, gfx::edge::kEdgeDarkGray);\n  left_chevron_ = AddChildView(CreateButton(\n      base::BindRepeating(&NavigationView::Move, weak_factory_.GetWeakPtr(),\n                          true),\n      left_chevron_icon, IDS_WEB_WIDGET_SEARCH_ONLY_FRE_PREV_BUTTON_TOOLTIP));\n\n  auto right_chevron_icon =\n      gfx::CreateVectorIcon(kWebWidgetFreChevronRightIcon, kChevronIconSize,\n                            gfx::edge::kEdgeDarkGray);\n  right_chevron_ = AddChildView(CreateButton(\n      base::BindRepeating(&NavigationView::Move, weak_factory_.GetWeakPtr(),\n                          false),\n      right_chevron_icon, IDS_WEB_WIDGET_SEARCH_ONLY_FRE_NEXT_BUTTON_TOOLTIP));\n\n  // indicator container.\n  indicator_container_view_ = AddChildView(std::make_unique<views::View>());\n  indicator_container_view_\n      ->SetLayoutManager(std::make_unique<views::FlexLayout>())\n      ->SetOrientation(views::LayoutOrientation::kHorizontal)\n      .SetMainAxisAlignment(views::LayoutAlignment::kCenter);\n\n  for (size_t index = 0; index < controller_->size(); index++) {\n    views::ImageView* icon_view = indicator_container_view_->AddChildView(\n        std::make_unique<views::ImageView>());\n    SkColor icon_color = kUnSelectedColor;\n    if (index == 0)\n      icon_color = kSelectedColor;\n    auto icon = ui::ImageModel::FromVectorIcon(\n        kWebWidgetNavigationDotFilledIcon, icon_color, kIndicatorIconSize);\n    icon_view->SetImage(icon);\n    if (!current_indicator_) {\n      current_indicator_ = icon_view;\n    }\n  }\n  indicator_container_view_->SetVisible(false);\n\n  bitmap_fetcher_service_ =\n      BitmapFetcherServiceFactory::GetForBrowserContext(profile);\n}","pos":-1,"query":"InitializeNavigationViewComponents","filepos":-1,"timecost":1384.1062999999995,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_web_app_widgets\\web_app_widget_service_delegate_impl.cc:335-367","function":"WebAppWidgetServiceDelegateImpl::OnUpdateByTagCompleted","codesnippet":"{\n  if (shut_down_) {\n    base::UmaHistogramEnumeration(\n        blink::kEdgeWidgetUpdateStatusHistogramName,\n        blink::EdgeWebAppWidgetUpdateStatus::kErrorShutdown);\n    return;\n  }\n\n  if (!success) {\n    std::move(callback).Run(/*success=*/false);\n    return;\n  }\n\n  web_app::WebAppProvider* provider =\n      web_app::WebAppProvider::GetForWebApps(profile_);\n  DCHECK(provider);\n\n  bool updated = provider->sync_bridge_unsafe().EdgeUpdateWidgetByTag(\n      app_id, tag, std::move(updated_widget));\n\n  blink::EdgeWebAppWidgetUpdateStatus result =\n      updated ? blink::EdgeWebAppWidgetUpdateStatus::kSuccess\n              : blink::EdgeWebAppWidgetUpdateStatus::\n                    kErrorFailedToUpdateWebAppDatabase;\n  base::UmaHistogramEnumeration(blink::kEdgeWidgetUpdateStatusHistogramName,\n                                result);\n\n  std::move(callback).Run(updated);\n}","pos":45,"query":"updateEdgeWebAppWidgetStatus","filepos":11,"timecost":907.7258000000002,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\tabs\\filename_elider.cc:137-248","function":"FilenameElider::ElideImpl","codesnippet":"{\n  std::u16string_view text = render_text_->text();\n\n  // Validate the inputs. All of these are base assumptions.\n  DCHECK_LE(line_lengths.first, text.length());\n  DCHECK_LE(line_lengths.second, text.length());\n  DCHECK(render_text_->IsGraphemeBoundary(line_lengths.first));\n  DCHECK(render_text_->IsGraphemeBoundary(text.length() - line_lengths.second));\n\n  // If the entire text fits on a single line, use it as-is.\n  if (line_lengths.first == text.length() ||\n      line_lengths.second == text.length()) {\n    return std::u16string(text);\n  }\n\n  // If no characters will fit on one of the lines, return an empty string.\n  if (line_lengths.first == 0 || line_lengths.second == 0) {\n    return std::u16string();\n  }\n\n  // Let's figure out where to actually start the second line. Strings that\n  // are too long for one line but fit on two lines tend to create some\n  // overlap between the first and second line, so take the maximum of the\n  // second line cut and the end of the first line.\n  const size_t second_line_cut = text.length() - line_lengths.second;\n  size_t cut_point = std::max(second_line_cut, line_lengths.first);\n\n  // We got the whole line if the cut point is the character immediately\n  // after the first line cuts off (otherwise we've truncated and need to\n  // show an ellipsis in the final string).\n  const bool is_whole_string = (cut_point == line_lengths.first);\n\n  // If there is some flexibility in where we make our cut point (that is, the\n  // potential first and second lines overlap), there are a few specific places\n  // we preferentially want to separate the lines.\n  bool adjusted_cut_point = false;\n  if (is_whole_string && cut_point >= second_line_cut) {\n    // First, if there are image dimensions, preferentially put those on the\n    // second line.\n    const auto paren_pos = FindImageDimensions(text);\n    if (paren_pos != std::u16string::npos && paren_pos >= second_line_cut &&\n        paren_pos <= cut_point) {\n      cut_point = paren_pos;\n      adjusted_cut_point = true;\n    }\n\n    // Second, we can break at the start of the file extension.\n    if (!adjusted_cut_point) {\n      const size_t dot_pos = text.find_last_of(u'.');\n      if (dot_pos != std::u16string::npos && dot_pos >= second_line_cut &&\n          dot_pos <= cut_point) {\n        cut_point = dot_pos;\n        adjusted_cut_point = true;\n      }\n    }\n  }\n\n  // TODO(dfried): possibly handle the case where we chop a section with bidi\n  // delimiters out or split it between lines.\n\n  // If we didn't put the extension on its own line, eliminate whitespace\n  // from the start of the second line (it looks weird).\n  if (!adjusted_cut_point) {\n    cut_point =\n        gfx::FindValidBoundaryAfter(text, cut_point, /*trim_whitespace =*/true);\n  }\n\n  // Reassemble the string. Start with the first line up to `cut_point` or the\n  // end of the line, whichever comes sooner.\n  std::u16string result(\n      text.substr(0, std::min(line_lengths.first, cut_point)));\n  result.push_back(u'\\n');\n\n  // If we're starting the second line with a file extension hint that the\n  // directionality of the text might change by using an FSI mark. Allowing\n  // the renderer to re-infer RTL-ness produces much better results in text\n  // rendering when an RTL filename has an ASCII extension.\n  //\n  // TODO(dfried): Currently we do put an FSI before an ellipsis; this\n  // results in the ellipsis being placed with the text that immediately\n  // follows it (making the point of elision more obvious). If the text\n  // following the cut is LTR it goes on the left, and if the text is RTL it\n  // goes on the right. Reconsider if/how we should set text direction\n  // following an ellipsis:\n  // - No FSI would cause the ellipsis to align with the preceding rather\n  //   than the following text. It would provide a bit more visual continuity\n  //   between lines, but might be confusing as to where the text picks back\n  //   up (as the next character might be on the opposite side of the line).\n  // - We could preserve elided directionality markers, but they could end up\n  //   aligning the ellipsis with text that is not present at all on the\n  //   label.\n  // - We could also force direction to match the start of the first line for\n  //   consistency but that could result in an ellipsis that matches neither\n  //   the preceding nor following text.\n  //\n  // TODO(dfried): move these declarations to rtl.h alongside e.g.\n  // base::i18n::kRightToLeftMark\n  constexpr char16_t kFirstStrongIsolateMark = u'\\u2068';\n  constexpr char16_t kPopDirectionalIsolateMark = u'\\u2069';\n  if (adjusted_cut_point || !is_whole_string) {\n    result += kFirstStrongIsolateMark;\n  }\n  if (!is_whole_string) {\n    result.push_back(gfx::kEllipsisUTF16[0]);\n  }\n  result.append(text.substr(cut_point));\n  // If we added an FSI, we should bracket it with a PDI.\n  if (adjusted_cut_point || !is_whole_string) {\n    result += kPopDirectionalIsolateMark;\n  }\n  return result;\n}","pos":-1,"query":"splitTextIntoTwoLines","filepos":-1,"timecost":2032.9181000000099,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\smb_client\\smb_share_finder.cc:23-53","function":"SmbShareFinder::GatherSharesInNetwork","codesnippet":"{\n  const bool is_host_discovery_pending = !discovery_callbacks_.empty();\n  const bool is_share_discovery_pending = !share_callbacks_.empty();\n\n  if (is_host_discovery_pending) {\n    // Host discovery is currently running, add both |discovery_callback| and\n    // |share_callback| to their respective vectors.\n    InsertDiscoveryAndShareCallbacks(std::move(discovery_callback),\n                                     std::move(shares_callback));\n    return;\n  }\n\n  if (is_share_discovery_pending) {\n    // Host discovery is complete but there are still share callbacks pending.\n    // Run |discovery_callback| because pending share discoveries and no pending\n    // host discoveries indicate that a host discovery must have recently\n    // completed.\n    std::move(discovery_callback).Run();\n    InsertShareCallback(std::move(shares_callback));\n    return;\n  }\n\n  // No host discovery or share discovery in progress. This is only because\n  // GatherSharesInNetwork has not been called yet or the previous host\n  // discovery has been fully completed.\n  InsertDiscoveryAndShareCallbacks(std::move(discovery_callback),\n                                   std::move(shares_callback));\n  scanner_.FindHostsInNetwork(base::BindOnce(&SmbShareFinder::OnHostsFound,\n                                             weak_ptr_factory_.GetWeakPtr()));\n}","pos":-1,"query":"manageDiscoveryAndShareCallbacks","filepos":-1,"timecost":1153.402099999992,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\browser_tabstrip.cc:344-376","function":"ConfigureTabGroupForNavigation","codesnippet":"{\n  if (!nav_params->source_contents) {\n    return;\n  }\n\n  if (!nav_params->browser || !nav_params->browser->SupportsWindowFeature(\n                                  Browser::WindowFeature::FEATURE_TABSTRIP)) {\n    return;\n  }\n\n  TabStripModel* model = nav_params->browser->tab_strip_model();\n  DCHECK(model);\n\n  const int source_index =\n      model->GetIndexOfWebContents(nav_params->source_contents);\n\n  // If the source tab is not in the current tab strip (e.g. if the current\n  // navigation is in a new window), don't set the group. Groups cannot be\n  // shared across multiple windows.\n  if (source_index == TabStripModel::kNoTab) {\n    return;\n  }\n\n  // Do not set the group when the navigation is from bookmarks.\n  if (ui::PageTransitionCoreTypeIs(nav_params->transition,\n                                   ui::PAGE_TRANSITION_AUTO_BOOKMARK)) {\n    return;\n  }\n\n  if (nav_params->disposition == WindowOpenDisposition::NEW_FOREGROUND_TAB ||\n      nav_params->disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {\n    nav_params->group = model->GetTabGroupForTab(source_index);\n  }\n}","pos":3,"query":"SetTabGroupForNewTabNavigation","filepos":3,"timecost":980.1330000000016,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_restore\\full_restore_app_launch_handler.cc:408-478","function":"FullRestoreAppLaunchHandler::RecordLaunchBrowserResult","codesnippet":"{\n  RestoreTabResult result = RestoreTabResult::kNoTabs;\n\n  int window_count = 0;\n  int tab_count = 0;\n  std::list<SessionServiceEvent> events = GetSessionServiceEvents(profile());\n  if (!events.empty()) {\n    auto it = events.back();\n    if (it.type == SessionServiceEventLogType::kRestore) {\n      window_count = it.data.restore.window_count;\n      tab_count = it.data.exit.tab_count;\n      if (tab_count > 0)\n        result = RestoreTabResult::kHasTabs;\n    } else {\n      result = RestoreTabResult::kError;\n      window_count = -1;\n      tab_count = -1;\n    }\n  }\n\n  VLOG(1) << \"Browser is restored (windows=\" << window_count\n          << \" tabs=\" << tab_count << \").\";\n  base::UmaHistogramEnumeration(kRestoreBrowserResultHistogramPrefix, result);\n  base::UmaHistogramCounts100(kFullRestoreTabCountPrefix, tab_count);\n\n  if (result != RestoreTabResult::kNoTabs)\n    return;\n\n  SessionRestoreExitResult session_restore_exit =\n      SessionRestoreExitResult::kNoExit;\n  for (auto iter = events.rbegin(); iter != events.rend(); ++iter) {\n    if (iter->type != SessionServiceEventLogType::kStart)\n      continue;\n\n    ++iter;\n    if (iter != events.rend() &&\n        iter->type == SessionServiceEventLogType::kExit) {\n      bool is_first_session_service = iter->data.exit.is_first_session_service;\n      bool did_schedule_command = iter->data.exit.did_schedule_command;\n      if (is_first_session_service) {\n        session_restore_exit =\n            did_schedule_command\n                ? SessionRestoreExitResult::kIsFirstServiceDidSchedule\n                : SessionRestoreExitResult::kIsFirstServiceNoSchedule;\n      } else {\n        session_restore_exit =\n            did_schedule_command\n                ? SessionRestoreExitResult::kNotFirstServiceDidSchedule\n                : SessionRestoreExitResult::kNotFirstServiceNoSchedule;\n      }\n    }\n    break;\n  }\n\n  base::UmaHistogramEnumeration(kSessionRestoreExitResultPrefix,\n                                session_restore_exit);\n\n  SessionRestoreWindowCount restored_window_count;\n  if (browser_app_window_count_ != 0) {\n    restored_window_count =\n        browser_window_count_ == 0\n            ? SessionRestoreWindowCount::kHasAppWindowNoNormalWindow\n            : SessionRestoreWindowCount::kHasAppWindowHasNormalWindow;\n  } else {\n    restored_window_count =\n        browser_window_count_ == 0\n            ? SessionRestoreWindowCount::kNoWindow\n            : SessionRestoreWindowCount::kNoAppWindowHasNormalWindow;\n  }\n  base::UmaHistogramEnumeration(kSessionRestoreWindowCountPrefix,\n                                restored_window_count);\n}","pos":-1,"query":"LogSessionRestoreMetrics","filepos":-1,"timecost":1082.4762000000046,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\preinstalled_web_app_utils.cc:214-481","function":"ParseConfig","codesnippet":"{\n  if (app_config.type() != base::Value::Type::DICT) {\n    return base::StrCat(\n        {file.AsUTF8Unsafe(), \" was not a dictionary as the top level\"});\n  }\n  const base::Value::Dict& app_config_dict = app_config.GetDict();\n\n  // app_url\n  const std::string* app_url_string = app_config_dict.FindString(kAppUrl);\n  if (!app_url_string) {\n    return base::StrCat({file.AsUTF8Unsafe(), \" had a missing \", kAppUrl});\n  }\n  GURL install_url = GURL(*app_url_string);\n  if (!install_url.is_valid()) {\n    return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \", kAppUrl, \": \",\n                         *app_url_string});\n  }\n\n  ExternalInstallOptions options(install_url,\n                                 mojom::UserDisplayMode::kStandalone,\n                                 ExternalInstallSource::kExternalDefault);\n  options.require_manifest = true;\n  options.force_reinstall = false;\n\n  // user_type\n  const base::Value::List* list = app_config_dict.FindList(kUserType);\n  if (!list) {\n    return base::StrCat({file.AsUTF8Unsafe(), \" missing \", kUserType});\n  }\n  for (const auto& item : *list) {\n    if (!item.is_string()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" has invalid \", kUserType,\n                           item.DebugString()});\n    }\n    options.user_type_allowlist.push_back(item.GetString());\n  }\n  if (options.user_type_allowlist.empty()) {\n    return base::StrCat({file.AsUTF8Unsafe(), \" has empty \", kUserType});\n  }\n\n  // feature_name\n  const std::string* feature_name = app_config_dict.FindString(kFeatureName);\n  if (feature_name) {\n    options.gate_on_feature = *feature_name;\n  }\n\n  // feature_name_or_installed\n  const std::string* feature_name_or_installed =\n      app_config_dict.FindString(kFeatureNameOrInstalled);\n  if (feature_name_or_installed) {\n    options.gate_on_feature_or_installed = *feature_name_or_installed;\n  }\n  // only_for_new_users\n  const base::Value* value = app_config_dict.Find(kOnlyForNewUsers);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kOnlyForNewUsers});\n    }\n    options.only_for_new_users = value->GetBool();\n  }\n\n  // only_if_previously_preinstalled\n  value = app_config_dict.Find(kOnlyIfPreviouslyPreinstalled);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kOnlyIfPreviouslyPreinstalled});\n    }\n    options.only_if_previously_preinstalled = value->GetBool();\n  }\n\n  // hide_from_user\n  bool hide_from_user = false;\n  value = app_config_dict.Find(kHideFromUser);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kHideFromUser});\n    }\n    hide_from_user = value->GetBool();\n  }\n  options.add_to_applications_menu = !hide_from_user;\n  options.add_to_search = !hide_from_user;\n  options.add_to_management = !hide_from_user;\n\n  // create_shortcuts\n  bool create_shortcuts = false;\n  value = app_config_dict.Find(kCreateShortcuts);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kCreateShortcuts});\n    }\n    create_shortcuts = value->GetBool();\n  }\n  options.add_to_desktop = create_shortcuts;\n  options.add_to_quick_launch_bar = create_shortcuts;\n\n  // It doesn't make sense to hide the app and also create shortcuts for it.\n  DCHECK(!(hide_from_user && create_shortcuts));\n\n  // disable_if_arc_supported\n  value = app_config_dict.Find(kDisableIfArcSupported);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kDisableIfArcSupported});\n    }\n    options.disable_if_arc_supported = value->GetBool();\n  }\n\n  // disable_if_tablet_form_factor\n  value = app_config_dict.Find(kDisableIfTabletFormFactor);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kDisableIfTabletFormFactor});\n    }\n    options.disable_if_tablet_form_factor = value->GetBool();\n  }\n\n  // launch_container\n  const std::string* launch_container_str =\n      app_config_dict.FindString(kLaunchContainer);\n  if (!launch_container_str) {\n    return base::StrCat(\n        {file.AsUTF8Unsafe(), \" had an invalid \", kLaunchContainer});\n  }\n  if (*launch_container_str == kLaunchContainerTab) {\n    options.user_display_mode = mojom::UserDisplayMode::kBrowser;\n  } else if (*launch_container_str == kLaunchContainerWindow) {\n    options.user_display_mode = mojom::UserDisplayMode::kStandalone;\n  } else {\n    return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                         kLaunchContainer, \": \", *launch_container_str});\n  }\n\n  // launch_query_params\n  value = app_config_dict.Find(kLaunchQueryParams);\n  if (value) {\n    if (!value->is_string()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kLaunchQueryParams});\n    }\n    options.launch_query_params = value->GetString();\n  }\n\n  // load_and_await_service_worker_registration\n  value = app_config_dict.Find(kLoadAndAwaitServiceWorkerRegistration);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kLoadAndAwaitServiceWorkerRegistration});\n    }\n    options.load_and_await_service_worker_registration = value->GetBool();\n  }\n\n  // service_worker_registration_url\n  value = app_config_dict.Find(kServiceWorkerRegistrationUrl);\n  if (value) {\n    if (!options.load_and_await_service_worker_registration) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" should not specify a \",\n                           kServiceWorkerRegistrationUrl, \" while \",\n                           kLoadAndAwaitServiceWorkerRegistration,\n                           \" is disabled\"});\n    }\n    if (!value->is_string()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kServiceWorkerRegistrationUrl});\n    }\n    options.service_worker_registration_url.emplace(value->GetString());\n    if (!options.service_worker_registration_url->is_valid()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kServiceWorkerRegistrationUrl});\n    }\n  }\n\n  // uninstall_and_replace\n  value = app_config_dict.Find(kUninstallAndReplace);\n  if (value) {\n    if (!value->is_list()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kUninstallAndReplace});\n    }\n    const base::Value::List& uninstall_and_replace_values = value->GetList();\n\n    for (const auto& app_id_value : uninstall_and_replace_values) {\n      if (!app_id_value.is_string()) {\n        return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                             kUninstallAndReplace, \" entry\"});\n      }\n      options.uninstall_and_replace.push_back(app_id_value.GetString());\n    }\n  }\n\n  // only_use_offline_manifest\n  value = app_config_dict.Find(kOnlyUseOfflineManifest);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kOnlyUseOfflineManifest});\n    }\n    options.only_use_app_info_factory = value->GetBool();\n  }\n\n  // offline_manifest\n  value = app_config_dict.Find(kOfflineManifest);\n  if (value && value->is_dict()) {\n    WebAppInstallInfoFactoryOrError offline_manifest_result =\n        ParseOfflineManifest(file_utils, dir, file, *value);\n    if (std::string* error =\n            std::get_if<std::string>(&offline_manifest_result)) {\n      return std::move(*error);\n    }\n    options.app_info_factory =\n        std::move(std::get<WebAppInstallInfoFactory>(offline_manifest_result));\n  }\n\n  if (options.only_use_app_info_factory && !options.app_info_factory) {\n    return base::StrCat({file.AsUTF8Unsafe(), kOnlyUseOfflineManifest,\n                         \" set with no \", kOfflineManifest, \" available\"});\n  }\n\n  // force_reinstall_for_milestone\n  value = app_config_dict.Find(kForceReinstallForMilestone);\n  if (value) {\n    if (!value->is_int()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kForceReinstallForMilestone});\n    }\n    options.force_reinstall_for_milestone = value->GetInt();\n  }\n\n  // oem_installed\n  value = app_config_dict.Find(kOemInstalled);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat(\n          {file.AsUTF8Unsafe(), \" had an invalid \", kOemInstalled});\n    }\n    options.oem_installed = value->GetBool();\n  }\n\n  // disable_if_touchscreen_with_stylus_not_supported\n  value = app_config_dict.Find(kDisableIfTouchScreenWithStylusNotSupported);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kDisableIfTouchScreenWithStylusNotSupported});\n    }\n    options.disable_if_touchscreen_with_stylus_not_supported = value->GetBool();\n  }\n\n  // is_preferred_app_for_supported_links\n  value = app_config_dict.Find(kIsPreferredAppForSupportedLinks);\n  if (value) {\n    if (!value->is_bool()) {\n      return base::StrCat({file.AsUTF8Unsafe(), \" had an invalid \",\n                           kIsPreferredAppForSupportedLinks});\n    }\n    options.is_preferred_app_for_supported_links = value->GetBool();\n  }\n\n  return options;\n}","pos":20,"query":"parseAppConfigToInstallOptions","filepos":20,"timecost":1488.729999999996,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\profiles\\profile_io_data.cc:28-83","function":"ProfileIOData::IsHandledProtocol","codesnippet":"{\n  DCHECK_EQ(scheme, base::ToLowerASCII(scheme));\n\n  constexpr auto kProtocolList = base::MakeFixedFlatSet<std::string_view>({\n      url::kHttpScheme,\n      url::kHttpsScheme,\n#if BUILDFLAG(ENABLE_WEBSOCKETS)\n      url::kWsScheme,\n      url::kWssScheme,\n#endif  // BUILDFLAG(ENABLE_WEBSOCKETS)\n    url::kFileScheme,\n    content::kChromeDevToolsScheme,\n    dom_distiller::kDomDistillerScheme,\n#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)\n    extensions::kExtensionScheme,\n#endif\n    content::kChromeUIScheme,\n    content::kChromeUIUpstreamScheme,\n    content::kChromeUIUntrustedScheme,\n    url::kDataScheme,\n#if BUILDFLAG(IS_CHROMEOS)\n      content::kExternalFileScheme,\n#endif  // BUILDFLAG(IS_CHROMEOS)\n#if BUILDFLAG(IS_ANDROID)\n      url::kContentScheme,\n#endif  // BUILDFLAG(IS_ANDROID)\n    url::kAboutScheme,\n    url::kBlobScheme,\n    url::kFileSystemScheme,\n    url::kEdgeWebCaptureScheme,\n    chrome::kChromeSearchScheme,\n#if !BUILDFLAG(IS_ANDROID)\n      chrome::kIsolatedAppScheme,\n#endif  // !BUILDFLAG(IS_ANDROID)\n  });\n\n  return kProtocolList.contains(scheme) ||\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n         extensions::util::IsExtensionScheme(scheme) ||\n#endif\n\n      false;\n}\n\n// static\nbool ProfileIOData::IsHandledURL(const GURL& url) {\n  if (!url.is_valid()) {\n    // We handle error cases.\n    return true;\n  }\n\n  return IsHandledProtocol(url.scheme());\n}\n\ncontent::ResourceContext* ProfileIOData::GetResourceContext() const {\n  return resource_context_.get();\n}","pos":136,"query":"IsHandledURL","filepos":0,"timecost":2251.3965999999928,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\ash\\capture_mode\\lens_overlay_image_helper.cc:181-222","function":"CropAndDownscaleImageIfNeeded","codesnippet":"{\n  SkBitmap output;\n  auto full_image_size = gfx::Size(image.width(), image.height());\n  auto region_size = gfx::Size(region.width(), region.height());\n  auto target_width = lens::features::GetLensOverlayImageMaxWidth();\n  auto target_height = lens::features::GetLensOverlayImageMaxHeight();\n  if (ShouldDownscaleSize(region_size,\n                          lens::features::GetLensOverlayImageMaxArea(),\n                          target_width, target_height)) {\n    double scale = GetPreferredScale(region_size, target_width, target_height);\n    auto downscaled_region_size =\n        GetPreferredSize(region_size, target_width, target_height);\n    int scaled_full_image_width =\n        std::max<int>(scale * full_image_size.width(), 1);\n    int scaled_full_image_height =\n        std::max<int>(scale * full_image_size.height(), 1);\n    int scaled_x = int(scale * region.x());\n    int scaled_y = int(scale * region.y());\n\n    SkIRect dest_subset = {scaled_x, scaled_y,\n                           scaled_x + downscaled_region_size.width(),\n                           scaled_y + downscaled_region_size.height()};\n    output = skia::ImageOperations::Resize(\n        image, skia::ImageOperations::RESIZE_BEST, scaled_full_image_width,\n        scaled_full_image_height, dest_subset);\n  } else {\n    SkIRect dest_subset = {region.x(), region.y(), region.x() + region.width(),\n                           region.y() + region.height()};\n    output = skia::ImageOperations::Resize(\n        image, skia::ImageOperations::RESIZE_BEST, image.width(),\n        image.height(), dest_subset);\n  }\n\n  // Since we are cropping the image from a screenshot, we are assuming there\n  // cannot be transparent pixels. This allows encoding logic to choose the\n  // correct image format to represent the crop.\n  output.setAlphaType(kOpaque_SkAlphaType);\n  AddClientLogsForDownscale(client_logs, image, output);\n  return output;\n}","pos":42,"query":"downscaleAndCropImage","filepos":14,"timecost":1541.9697000000015,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_tab_center\\molding_painter.cc:15-58","function":"PaintMolding","codesnippet":"{\n  gfx::ScopedCanvas scoped_canvas(canvas);\n  const float scale = canvas->UndoDeviceScaleFactor();\n  const gfx::Rect scaled_bounds = gfx::ScaleToEnclosingRect(bounds, scale);\n  const int scaled_radius = base::ClampCeil(corner_radius * scale);\n\n  scoped_canvas.FlipIfRTL(scaled_bounds.right());\n\n  // Draw top background.\n  auto top_color = TabStyle::Get()->GetTabBackgroundColor(\n      TabStyle::TabSelectionState::kInactive, /*hovered*/ false,\n      paint_as_active, color_provider, /*is_tab_strip_vertical=*/false);\n  gfx::Rect top(scaled_bounds.x(), scaled_bounds.y(), scaled_bounds.width(),\n                scaled_radius);\n  canvas->FillRect(top, top_color);\n\n  // Draw bottom background.\n  auto bottom_color = color_provider.GetColor(kColorEdgeVTabPaneBackground);\n  gfx::Rect bottom(top.x(), top.bottom(), top.width(),\n                   scaled_bounds.height() - top.height());\n  canvas->FillRect(bottom, bottom_color);\n\n  if (scaled_radius) {\n    // Draw curve (top-left quadrant of a circle).\n    SkPath path;\n    cc::PaintFlags flags;\n    flags.setAntiAlias(true);\n    flags.setStyle(cc::PaintFlags::kFill_Style);\n    flags.setColor(bottom_color);\n\n    const int top_right = top.right();\n    const int top_bottom = top.bottom();\n\n    path.moveTo(top.x(), top_bottom);\n    path.arcTo(scaled_radius, scaled_radius, 0, SkPath::kSmall_ArcSize,\n               SkPathDirection::kCW, top_right, top.y());\n    path.lineTo(top_right, top_bottom);\n    path.close();\n    canvas->DrawPath(path, flags);\n  }\n}","pos":9,"query":"Draws tab background with rounded corners","filepos":9,"timecost":901.7288999999873,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\settings\\pages\\a11y\\settings_with_tts_preview_handler.cc:54-85","function":"SettingsWithTtsPreviewHandler::HandlePreviewTtsVoice","codesnippet":"{\n  DCHECK_EQ(2U, args.size());\n  const std::string& text = args[0].GetString();\n  const std::string& voice_id = args[1].GetString();\n\n  if (text.empty() || voice_id.empty()) {\n    return;\n  }\n\n  std::optional<base::Value> json = base::JSONReader::Read(voice_id);\n  std::string name;\n  std::string extension_id;\n  if (const std::string* ptr = json->GetDict().FindString(\"name\")) {\n    name = *ptr;\n  }\n  if (const std::string* ptr = json->GetDict().FindString(\"extension\")) {\n    extension_id = *ptr;\n  }\n\n  std::unique_ptr<content::TtsUtterance> utterance =\n      content::TtsUtterance::Create(web_ui()->GetWebContents());\n  utterance->SetText(text);\n  utterance->SetVoiceName(name);\n  utterance->SetEngineId(extension_id);\n  utterance->SetSrcUrl(GetSourceURL());\n  utterance->SetEventDelegate(this);\n  content::TtsController::GetInstance()->Stop();\n\n  base::Value result(true /* preview started */);\n  FireWebUIListener(\"tts-preview-state-changed\", result);\n  content::TtsController::GetInstance()->SpeakOrEnqueue(std::move(utterance));\n}","pos":-1,"query":"Initiates text-to-speech preview","filepos":-1,"timecost":817.2239000000118,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\file_system_access\\file_system_access_views_helpers.cc:21-51","function":"CreateOriginLabel","codesnippet":"{\n  Profile* profile =\n      web_contents\n          ? Profile::FromBrowserContext(web_contents->GetBrowserContext())\n          : nullptr;\n  std::u16string origin_identity_name =\n      file_system_access_ui_helper::GetUrlIdentityName(profile,\n                                                       origin.GetURL());\n\n  size_t offset;\n  auto label = std::make_unique<views::StyledLabel>();\n  label->SetText(\n      l10n_util::GetStringFUTF16(message_id, origin_identity_name, &offset));\n  label->SetTextContext(text_context);\n  label->SetDefaultTextStyle(show_emphasis ? views::style::STYLE_SECONDARY\n                                           : views::style::STYLE_PRIMARY);\n  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n\n  if (show_emphasis) {\n    views::StyledLabel::RangeStyleInfo origin_style;\n    origin_style.text_style = views::style::STYLE_EMPHASIZED;\n    label->AddStyleRange(\n        gfx::Range(offset, offset + origin_identity_name.length()),\n        origin_style);\n  }\n  return label;\n}","pos":-1,"query":"createStyledLabelWithOriginName","filepos":-1,"timecost":2163.5725000000093,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\fast_checkout\\fast_checkout_capabilities_fetcher_impl.cc:109-152","function":"FastCheckoutCapabilitiesFetcherImpl::OnFetchComplete","codesnippet":"{\n  base::UmaHistogramTimes(kUmaKeyResponseTime,\n                          base::TimeTicks::Now() - start_time);\n\n  int net_error = url_loader_->NetError();\n  bool report_http_response_code =\n      (net_error == net::OK ||\n       net_error == net::ERR_HTTP_RESPONSE_CODE_FAILURE) &&\n      url_loader_->ResponseInfo() && url_loader_->ResponseInfo()->headers;\n  base::UmaHistogramSparse(\n      kUmaKeyResponseAndNetErrorCode,\n      report_http_response_code\n          ? url_loader_->ResponseInfo()->headers->response_code()\n          : net_error);\n\n  // Reset `url_loader_` so that another request could be made.\n  url_loader_.reset();\n  last_fetch_timestamp_ = base::TimeTicks::Now();\n\n  if (net_error != net::OK) {\n    return;\n  }\n\n  if (!response_body) {\n    base::UmaHistogramEnumeration(kUmaKeyParsingResult,\n                                  ParsingResult::kNullResponse);\n    return;\n  }\n\n  ::fast_checkout::FastCheckoutFunnels funnels;\n  if (!funnels.ParseFromString(*response_body)) {\n    base::UmaHistogramEnumeration(kUmaKeyParsingResult,\n                                  ParsingResult::kParsingError);\n    return;\n  }\n\n  base::UmaHistogramEnumeration(kUmaKeyParsingResult, ParsingResult::kSuccess);\n\n  for (const ::fast_checkout::FastCheckoutFunnels_FastCheckoutFunnel&\n           funnel_proto : funnels.funnels()) {\n    AddFunnelToCache(funnel_proto);\n  }\n}","pos":-1,"query":"LogResponseMetricsAndCacheFunnels","filepos":-1,"timecost":1051.2056000000011,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\compose\\compose_enabling.cc:445-479","function":"ComposeEnabling::PageLevelChecks","codesnippet":"{\n  if (auto profile_show_status = IsEnabled();\n      !profile_show_status.has_value()) {\n    DVLOG(2) << \"not enabled\";\n    return profile_show_status;\n  }\n\n  if (!url.SchemeIsHTTPOrHTTPS()) {\n    DVLOG(2) << \"incorrect scheme\";\n    return base::unexpected(compose::ComposeShowStatus::kIncorrectScheme);\n  }\n\n  if (is_nested_within_fenced_frame) {\n    DVLOG(2) << \"field nested within fenced frame not supported\";\n    return base::unexpected(\n        compose::ComposeShowStatus::kFormFieldNestedInFencedFrame);\n  }\n\n  // Note: This does not check frames between the current and the top level\n  // frame. Because all our metadata for compose is either based on the origin\n  // of the top level frame or actually part of the top level frame, this is\n  // sufficient for now. TODO(b/309162238) follow up on whether this is\n  // sufficient long-term.\n  if (top_level_frame_origin != element_frame_origin) {\n    DVLOG(2) << \"cross frame origin not supported\";\n    return base::unexpected(\n        compose::ComposeShowStatus::kFormFieldInCrossOriginFrame);\n  }\n\n  return base::ok();\n}","pos":-1,"query":"validateProfileShowStatus","filepos":-1,"timecost":1107.959799999997,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\apps\\app_service\\app_install\\app_install_navigation_throttle.cc:184-220","function":"AppInstallNavigationThrottle::HandleRequest","codesnippet":"{\n  const GURL& url = navigation_handle()->GetURL();\n\n  if (!url.SchemeIs(chromeos::kAppInstallUriScheme)) {\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  // We accept `cros-apps:install-app` or `cros-apps://install-app`, when parsed\n  // with an opaque path (no host, path starts with //) or not.\n  if (url.host() != kAppInstallHost && url.path_piece() != kAppInstallHost &&\n      url.path_piece() != kAppInstallPath) {\n    return content::NavigationThrottle::PROCEED;\n  }\n\n  QueryParams query_params = ExtractQueryParams(url.query_piece());\n  if (!query_params.serialized_package_id.has_value()) {\n    return content::NavigationThrottle::CANCEL_AND_IGNORE;\n  }\n\n  content::WebContents* web_contents = navigation_handle()->GetWebContents();\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  auto* proxy = AppServiceProxyFactory::GetForProfile(profile);\n\n  std::optional<AppInstallService::WindowIdentifier> anchor_window =\n      GetAnchorWindow(web_contents, proxy);\n\n  proxy->AppInstallService().InstallAppWithFallback(\n      query_params.source,\n      std::move(query_params.serialized_package_id).value(), anchor_window,\n      base::DoNothing());\n\n  if (!web_contents->GetLastCommittedURL().is_valid()) {\n    web_contents->ClosePage();\n  }\n\n  return content::NavigationThrottle::CANCEL_AND_IGNORE;\n}","pos":-1,"query":"App installation URL handler","filepos":-1,"timecost":896.5663000000059,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\safe_browsing\\download_protection\\check_client_download_request_base.cc:328-379","function":"CheckClientDownloadRequestBase::OnRequestBuilt","codesnippet":"{\n  if (ShouldPromptForIncorrectPassword()) {\n    LogLocalDecryptionEvent(safe_browsing::DeepScanEvent::kIncorrectPassword);\n    FinishRequest(DownloadCheckResult::PROMPT_FOR_LOCAL_PASSWORD_SCANNING,\n                  REASON_LOCAL_DECRYPTION_PROMPT);\n    return;\n  }\n\n  if (ShouldShowScanFailure()) {\n    FinishRequest(DownloadCheckResult::DEEP_SCANNED_FAILED,\n                  REASON_LOCAL_DECRYPTION_FAILED);\n    return;\n  }\n\n  client_download_request_ = std::move(request);\n  SanitizeRequest();\n\n  // If it's an archive with no archives or executables, finish early.\n  if ((client_download_request_->download_type() ==\n           ClientDownloadRequest::ZIPPED_EXECUTABLE ||\n       client_download_request_->download_type() ==\n           ClientDownloadRequest::RAR_COMPRESSED_EXECUTABLE ||\n       client_download_request_->download_type() ==\n           ClientDownloadRequest::SEVEN_ZIP_COMPRESSED_EXECUTABLE) &&\n      client_download_request_->archive_summary().parser_status() ==\n          ClientDownloadRequest::ArchiveSummary::VALID &&\n      std::ranges::all_of(\n          client_download_request_->archived_binary(),\n          [](const ClientDownloadRequest::ArchivedBinary& archived_binary) {\n            return !archived_binary.is_executable() &&\n                   !archived_binary.is_archive();\n          })) {\n    FinishRequest(DownloadCheckResult::UNKNOWN,\n                  REASON_ARCHIVE_WITHOUT_BINARIES);\n    return;\n  }\n\n  if (!pingback_enabled_) {\n    FinishRequest(DownloadCheckResult::UNKNOWN, REASON_PING_DISABLED);\n    return;\n  }\n\n#if !BUILDFLAG(IS_ANDROID)\n  if (is_enhanced_protection_ && token_fetcher_) {\n    token_fetcher_->Start(base::BindOnce(\n        &CheckClientDownloadRequestBase::OnGotAccessToken, GetWeakPtr()));\n    return;\n  }\n#endif\n\n  SendRequest();\n}","pos":-1,"query":"HandleDownloadRequestWithSecurityChecks","filepos":81,"timecost":1137.693499999994,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\passage_embeddings\\passage_embeddings_coordinator.cc:45-78","function":"CollectTextForContentNode","codesnippet":"{\n  if (!node.has_content_attributes()) {\n    return;\n  }\n\n  const auto& attributes = node.content_attributes();\n\n  switch (attributes.attribute_type()) {\n    case optimization_guide::proto::ContentAttributeType::\n        CONTENT_ATTRIBUTE_TABLE:\n      if (!attributes.table_data().table_name().empty()) {\n        text.push_back(attributes.table_data().table_name());\n      }\n      break;\n\n    case optimization_guide::proto::ContentAttributeType::\n        CONTENT_ATTRIBUTE_TEXT:\n      if (!attributes.text_data().text_content().empty()) {\n        text.push_back(attributes.text_data().text_content());\n      }\n      break;\n\n    case optimization_guide::proto::ContentAttributeType::\n        CONTENT_ATTRIBUTE_IMAGE:\n      if (!attributes.image_data().image_caption().empty()) {\n        text.push_back(attributes.image_data().image_caption());\n      }\n      break;\n\n    default:\n      break;\n  }\n}","pos":-1,"query":"Extracts content attributes to text list","filepos":-1,"timecost":1923.6669999999867,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_oneauth_signin_view.cc:54-93","function":"EdgeOneAuthSigninView::EdgeOneAuthSigninView","codesnippet":"{\n  DCHECK(browser->profile());\n  browser_ = browser;\n  preferred_size_ = gfx::Size(std::max(kMinDialogWidth, width),\n                              std::max(kMinDialogHeight, height));\n  SetButtons(static_cast<int>(ui::mojom::DialogButton::kNone));\n  SetCanResize(true);\n  DialogDelegate::SetCloseCallback(base::BindOnce(\n      &EdgeOneAuthSigninView::HandleDialogClose, weak_factory_.GetWeakPtr()));\n\n  web_view_ = new views::WebView(browser->profile());\n  web_view_->GetWebContents()->SetDelegate(this);\n  SetUseDefaultFillLayout(true);\n  AddChildView(web_view_.get());\n\n  web_view_->SetPreferredSize(preferred_size_);\n  web_view_->GetWebContents()->Focus();\n\n  EdgeOneAuthSigninViewWebContentObserver::CreateForWebContents(\n      web_view_->GetWebContents(), browser,\n      base::BindRepeating(&EdgeOneAuthSigninView::HandleURLStartedLoading,\n                          base::Unretained(this)),\n      base::BindRepeating(&EdgeOneAuthSigninView::HandleURLFinishedLoading,\n                          weak_factory_.GetWeakPtr()));\n\n  // Set up for web_modal::WebContentsModalDialogManager\n  web_modal::WebContentsModalDialogManager::CreateForWebContents(\n      web_view_->web_contents());\n  web_modal::WebContentsModalDialogManager::FromWebContents(\n      web_view_->web_contents())\n      ->SetDelegate(this);\n  modal_dialog_manager_cleanup_ =\n      std::make_unique<ModalDialogManagerCleanup>(web_view_->web_contents());\n\n  blink::web_pref::WebPreferences web_prefs =\n      web_view_->GetWebContents()->GetOrCreateWebPreferences();\n  web_prefs.extension_script_disabled = true;\n  web_view_->GetWebContents()->SetWebPreferences(web_prefs);\n}","pos":-1,"query":"Initialize and configure web view dialog","filepos":-1,"timecost":949.2373999999836,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\chrome_extensions_api_client.cc:266-296","function":"ChromeExtensionsAPIClient::UpdateActionCount","codesnippet":"{\n  const Extension* extension =\n      ExtensionRegistry::Get(context)->enabled_extensions().GetByID(\n          extension_id);\n  DCHECK(extension);\n\n  ExtensionAction* action =\n      ExtensionActionManager::Get(context)->GetExtensionAction(*extension);\n  DCHECK(action);\n\n  action->SetDNRActionCount(tab_id, action_count);\n\n  // The badge text should be cleared if |action| contains explicitly set badge\n  // text for the |tab_id| when the preference is then toggled on. In this case,\n  // the matched action count should take precedence over the badge text.\n  if (clear_badge_text) {\n    action->ClearBadgeText(tab_id);\n  }\n\n  content::WebContents* tab_contents = nullptr;\n  if (ExtensionTabUtil::GetTabById(tab_id, context, /*include_incognito=*/true,\n                                   &tab_contents) &&\n      tab_contents) {\n    ExtensionActionDispatcher::Get(context)->NotifyChange(action, tab_contents,\n                                                          context);\n  }\n}","pos":204,"query":"updateExtensionActionBadge","filepos":204,"timecost":1178.8704000000143,"filemrr":0.7},{"filePath":"D:\\Edge\\src\\chrome\\browser\\webshare\\chromeos\\sharesheet_client.cc:275-306","function":"SharesheetClient::ShowSharesheet","codesnippet":"{\n  DCHECK_EQ(file_paths.size(), content_types.size());\n  DCHECK_EQ(file_paths.size(), file_sizes.size());\n\n  Profile* const profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  DCHECK(profile);\n\n  apps::IntentPtr intent =\n      file_paths.empty() ? apps_util::MakeShareIntent(text, title)\n                         : apps_util::CreateShareIntentFromFiles(\n                               profile, file_paths, content_types, text, title);\n  if (!intent->files.empty() && intent->files.size() == file_paths.size()) {\n    for (size_t index = 0; index < file_paths.size(); ++index) {\n      (intent->files)[index]->mime_type = content_types[index];\n      (intent->files)[index]->file_size = file_sizes[index];\n    }\n  }\n  DCHECK(intent->share_text.has_value() || !intent->files.empty());\n\n  sharesheet::SharesheetService* const sharesheet_service =\n      sharesheet::SharesheetServiceFactory::GetForProfile(profile);\n  sharesheet_service->ShowBubble(web_contents, std::move(intent),\n                                 sharesheet::LaunchSource::kWebShare,\n                                 std::move(delivered_callback));\n}","pos":-1,"query":"createAndShowShareIntent","filepos":-1,"timecost":1367.381400000013,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\sync_file_system\\drive_backend\\uninstall_app_task.cc:33-68","function":"UninstallAppTask::RunExclusive","codesnippet":"{\n  if (!IsContextReady()) {\n    std::move(callback).Run(SYNC_STATUS_FAILED);\n    return;\n  }\n\n  if (uninstall_flag_ == RemoteFileSyncService::UNINSTALL_AND_KEEP_REMOTE) {\n    SyncStatusCode status = metadata_database()->UnregisterApp(app_id_);\n    std::move(callback).Run(status);\n    return;\n  }\n  DCHECK_EQ(RemoteFileSyncService::UNINSTALL_AND_PURGE_REMOTE, uninstall_flag_);\n\n  int64_t sync_root_tracker_id = metadata_database()->GetSyncRootTrackerID();\n  TrackerIDSet trackers;\n  if (!metadata_database()->FindTrackersByParentAndTitle(sync_root_tracker_id,\n                                                         app_id_, &trackers) ||\n      !trackers.has_active()) {\n    std::move(callback).Run(SYNC_STATUS_OK);\n    return;\n  }\n\n  FileTracker app_root_tracker;\n  if (!metadata_database()->FindTrackerByTrackerID(trackers.active_tracker(),\n                                                   &app_root_tracker)) {\n    NOTREACHED();\n  }\n  app_root_tracker_id_ = app_root_tracker.tracker_id();\n  DCHECK(app_root_tracker.has_synced_details());\n\n  drive_service()->DeleteResource(\n      app_root_tracker.file_id(),\n      std::string(),  // etag\n      base::BindOnce(&UninstallAppTask::DidDeleteAppRoot,\n                     weak_ptr_factory_.GetWeakPtr(), std::move(callback),\n                     metadata_database()->GetLargestKnownChangeID()));\n}","pos":84,"query":"Uninstall app and manage sync status","filepos":29,"timecost":1041.0934000000125,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\crostini\\crostini_upgrader.cc:66-101","function":"CrostiniUpgrader::CreateNewLogFile","codesnippet":"{\n  base::FilePath path =\n      file_manager::util::GetMyFilesFolderForProfile(profile_).Append(\n          kLogFileBasename);\n  // Create the new log file on the blocking threadpool.\n  log_sequence_->PostTaskAndReplyWithResult(\n      FROM_HERE,\n      base::BindOnce(\n          [](base::FilePath path) -> std::optional<base::FilePath> {\n            path = base::GetUniquePath(path);\n            base::File file(path,\n                            base::File::FLAG_READ | base::File::FLAG_CREATE);\n            if (!file.IsValid()) {\n              PLOG(ERROR) << \"Failed to create log file!\";\n              return std::nullopt;\n            }\n            return path;\n          },\n          path),\n      // Once the file is created, write out the buffered log messages.\n      base::BindOnce(\n          [](base::WeakPtr<CrostiniUpgrader> weak_this,\n             std::optional<base::FilePath> path) {\n            if (!weak_this) {\n              return;\n            }\n\n            weak_this->current_log_file_ = path;\n            if (path) {\n              weak_this->WriteLogMessages(std::move(weak_this->log_buffer_));\n              for (auto& observer : weak_this->upgrader_observers_) {\n                observer.OnLogFileCreated(path->BaseName());\n              }\n            }\n          },\n          weak_ptr_factory_.GetWeakPtr()));\n}","pos":19,"query":"CreateAndWriteLogFile","filepos":19,"timecost":1324.8722000000125,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\sessions\\session_restore_android.cc:25-69","function":"unknown","codesnippet":"{\n  DCHECK(session_tab.navigations.size() > 0);\n  content::BrowserContext* context = web_contents->GetBrowserContext();\n  Profile* profile = Profile::FromBrowserContext(context);\n  TabModel* tab_model = TabModelList::GetTabModelForWebContents(web_contents);\n  DCHECK(tab_model);\n  std::vector<std::unique_ptr<content::NavigationEntry>> entries =\n      sessions::ContentSerializedNavigationBuilder::ToNavigationEntries(\n          session_tab.navigations, profile);\n\n  bool is_background_tab =\n      disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB;\n  content::WebContents::CreateParams create_params(context);\n  if (is_background_tab && skip_renderer_creation) {\n    create_params.initially_hidden = true;\n    create_params.desired_renderer_state =\n        content::WebContents::CreateParams::kNoRendererProcess;\n  }\n  // Ensure that skipping renderer creation is only enabled for background tabs.\n  DCHECK(skip_renderer_creation ? is_background_tab : true);\n  std::unique_ptr<content::WebContents> new_web_contents =\n      content::WebContents::Create(create_params);\n\n  content::WebContents* raw_new_web_contents = new_web_contents.get();\n  int selected_index = session_tab.normalized_navigation_index();\n  new_web_contents->GetController().Restore(\n      selected_index, content::RestoreType::kRestored, &entries);\n\n  TabAndroid* current_tab = TabAndroid::FromWebContents(web_contents);\n  DCHECK(current_tab);\n  // If swapped, return the current tab's most up-to-date web contents.\n  if (disposition == WindowOpenDisposition::CURRENT_TAB) {\n    current_tab->SwapWebContents(std::move(new_web_contents), false, false);\n    return current_tab->web_contents();\n  }\n  DCHECK(disposition == WindowOpenDisposition::NEW_FOREGROUND_TAB ||\n         disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB);\n  // Do not select a tab here it will interrupt bulk session restores.\n  tab_model->CreateTab(current_tab, new_web_contents.release(),\n                       /*select=*/false);\n  return raw_new_web_contents;\n}","pos":0,"query":"restoreAndCreateTabFromSession","filepos":0,"timecost":1353.2723000000115,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_embedded_browser\\embedded_browser_desktop_screen.cc:193-229","function":"EmbeddedBrowserDesktopScreenWin::UpdateDisplayInfos","codesnippet":"{\n  display.set_device_scale_factor(scale_factor);\n\n  // We need to make sure to update the Display's work area and bounds rects in\n  // addition to the scale factor when using custom rasterization scale. If we\n  // only update the scale factor, all positioning will be relative to a stale\n  // work area and bounds and things like owned windows positioning will break.\n  // The browser updates the Display's work area and bounds in\n  // ScreenWin::UpdateFromDisplayInfos which is often called upon screen update,\n  // so we do the same thing here.\n  std::optional<MONITORINFOEXW> monitor_info = MonitorInfoFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\n  if (monitor_info) {\n    // Ideally we want to use ScaleToEnclosingRect just like the browser does to\n    // scale the work_area and bounds rects in CreateDisplayFromDisplayInfo.\n    // However, after ScaleToEnclosingRect scales both origins and sizes for these\n    // rects, the browser has logic in DisplayInfosToScreenWinDisplays that calls\n    // ApplyToDisplayList which then calls ApplyDisplayPlacement to recalculate\n    // and set the target screen's origin with the correct origin. So for custom\n    // rasterization scale, calling ScaleToEnclosingRect will not give us the\n    // actual origin of the non primary screens. We need to keep the display's\n    // origins and scale only the sizes of the work_area and bounds rects here.\n    // Note: ScaleToEnclosingRect uses ceil clamping underneath for the rect's\n    // width and height so we also use it here to align with the browser logic.\n    gfx::Rect work_area = display.work_area();\n    work_area.set_size(gfx::ScaleToCeiledSize(\n        gfx::Size(gfx::Rect(monitor_info->rcWork).size()), 1.0f / scale_factor));\n    display.set_work_area(work_area);\n\n    gfx::Rect bounds = display.bounds();\n    bounds.set_size(gfx::ScaleToCeiledSize(\n        gfx::Size(gfx::Rect(monitor_info->rcMonitor).size()),\n        1.0f / scale_factor));\n    display.set_bounds(bounds);\n  }\n}","pos":3,"query":"updateDisplayScaleAndBounds","filepos":3,"timecost":1408.0892000000167,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\toolbar\\reload_button.cc:269-325","function":"ReloadButton::ButtonPressed","codesnippet":"{\n  // This is called in order to signal that external protocol dialogs are\n  // allowed to show due to a user action, which are likely to happen on the\n  // next page load after the reload button is clicked.\n  // Ideally, the browser UI's event system would notify ExternalProtocolHandler\n  // that a user action occurred and we are OK to open the dialog, but for some\n  // reason that isn't happening every time the reload button is clicked. See\n  // http://crbug.com/1206456\n  ExternalProtocolHandler::PermitLaunchUrl();\n\n  ClearPendingMenu();\n\n  if (visible_mode_ == Mode::kStop) {\n    base::UmaHistogramCounts10000(\n      \"Microsoft.Toolbar.StopButton.Clicked\",\n      1);\n  } else {\n    base::UmaHistogramCounts10000(\n      \"Microsoft.Toolbar.RefreshButton.Clicked\",\n      1);\n  }\n\n  if (visible_mode_ == Mode::kStop) {\n    if (command_updater_) {\n      command_updater_->ExecuteCommandWithDisposition(\n          IDC_STOP, WindowOpenDisposition::CURRENT_TAB);\n    }\n    // The user has clicked, so we can feel free to update the button, even if\n    // the mouse is still hovering.\n    ChangeMode(Mode::kReload, true);\n    return;\n  }\n\n  if (!double_click_timer_.IsRunning()) {\n    // Shift-clicking or ctrl-clicking the reload button means we should ignore\n    // any cached content.\n    int command;\n    int flags = event.flags();\n    if (event.IsShiftDown() || event.IsControlDown()) {\n      command = IDC_RELOAD_BYPASSING_CACHE;\n      // Mask off Shift and Control so they don't affect the disposition below.\n      flags &= ~(ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN);\n    } else {\n      command = IDC_RELOAD;\n    }\n\n    // Start a timer - while this timer is running, the reload button cannot be\n    // changed to a stop button.  We do not set |intended_mode_| to Mode::kStop\n    // here as the browser will do that when it actually starts loading (which\n    // may happen synchronously, thus the need to do this before telling the\n    // browser to execute the reload command).\n    double_click_timer_.Start(FROM_HERE, double_click_timer_delay_, this,\n                              &ReloadButton::OnDoubleClickTimer);\n\n    ExecuteBrowserCommand(command, flags);\n    ++testing_reload_count_;\n  }\n}","pos":-1,"query":"handleReloadOrStopButtonClick","filepos":-1,"timecost":1332.5613999999769,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\extensions\\edge_extension_installed_bubble_view.cc:354-390","function":"EdgeExtensionInstalledBubbleView::Init","codesnippet":"{\n  UpdateAnchorView();\n  ChromeLayoutProvider* provider = ChromeLayoutProvider::Get();\n  auto layout = std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical, gfx::Insets(),\n      provider->GetDistanceMetric(\n          views::DISTANCE_EXTENSIONS_PERMISSION_VERTICAL));\n  layout->set_minimum_cross_axis_size(kRightColumnWidth);\n  layout->set_cross_axis_alignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n  layout->set_between_child_spacing(kChildSpacing);\n  SetLayoutManager(std::move(layout));\n\n  AddChildView(CreateHeaderView());\n  AddChildView(CreateBodyView());\n\n  if (model_->show_how_to_use() && !model_->GetHowToUseText().empty()) {\n    AddChildView(CreateHowToUseText(model_->GetHowToUseText()));\n  }\n\n  if (model_->show_key_binding()) {\n    AddChildView(CreateButtonView(\n        base::BindRepeating(\n            &EdgeExtensionInstalledBubbleView::OnManageShortcutsClicked,\n            weak_ptr_factory_.GetWeakPtr()),\n        IDS_EXTENSION_INSTALLED_MANAGE_SHORTCUTS));\n\n  } else {\n    AddChildView(CreateButtonView(\n        base::BindRepeating(\n            &EdgeExtensionInstalledBubbleView::OnViewExtensionClicked,\n            weak_ptr_factory_.GetWeakPtr()),\n        IDS_EXTENSION_INSTALLED_VIEW_EXTENSION));\n  }\n  // Raise confirmation of action event so users can F6 focus.\n  // This is optionally triggered when there is a link on the bubble.\n  edge::a11y::RaiseNotificationAppearEvent(GetAnchorView(), GetWindowTitle());\n}","pos":-1,"query":"Configure and display extension installation UI.","filepos":238,"timecost":1117.6630000000005,"filemrr":0.8},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\cert_provisioning\\cert_provisioning_serializer.cc:298-346","function":"CertProvisioningSerializer::DeserializeWorker","codesnippet":"{\n  static_assert(CertProvisioningWorkerStatic::kVersion == 2,\n                \"This function should be updated\");\n\n  // This will show to the scheduler that the worker is not doing anything yet\n  // and that it should be continued manually.\n  worker->is_waiting_ = true;\n\n  bool is_ok = true;\n  int error_code = 0;\n\n  // Try to only add new deserialize statements at the end so error_code values\n  // are stable.\n  is_ok = is_ok && ++error_code &&\n          DeserializeEnumValue<CertScope>(saved_worker, kKeyNameCertScope,\n                                          &(worker->cert_scope_));\n\n  is_ok = is_ok && ++error_code &&\n          DeserializeCertProfile(saved_worker, kKeyNameCertProfile,\n                                 &(worker->cert_profile_));\n\n  is_ok = is_ok && ++error_code &&\n          DeserializeEnumValue<CertProvisioningWorkerState>(\n              saved_worker, kKeyNameState, &(worker->state_));\n\n  is_ok = is_ok && ++error_code &&\n          DeserializeBase64Encoded(saved_worker, kKeyNamePublicKey,\n                                   &(worker->public_key_));\n\n  is_ok = is_ok && ++error_code &&\n          DeserializeStringValue(saved_worker, kKeyNameInvalidationTopic,\n                                 &(worker->invalidation_topic_));\n\n  is_ok = is_ok && ++error_code &&\n          DeserializeStringValue(saved_worker, kKeyNameProcessId,\n                                 &(worker->process_id_));\n\n  if (!is_ok) {\n    LOG(ERROR)\n        << \" Failed to deserialize cert provisioning worker, error code: \"\n        << error_code;\n    return false;\n  }\n\n  worker->InitAfterDeserialization();\n\n  return true;\n}","pos":0,"query":"DeserializeCertProvisioningWorkerData","filepos":0,"timecost":1518.2212,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\arc\\arc_app_icon.cc:245-301","function":"ArcAppIcon::ArcAppIcon","codesnippet":"{\n  CHECK(observer_);\n\n  gfx::Size resource_size(resource_size_in_dip, resource_size_in_dip);\n  const std::vector<ui::ResourceScaleFactor>& scale_factors =\n      ui::GetSupportedResourceScaleFactors();\n  switch (icon_type) {\n    case IconType::kAdaptive:\n      foreground_image_skia_ = gfx::ImageSkia(\n          std::make_unique<Source>(weak_ptr_factory_.GetWeakPtr(),\n                                   resource_size_in_dip),\n          resource_size);\n\n      // ArcAppIcon::Source::GetImageForScale calls host_->LoadForScaleFactor to\n      // read both the foreground and background files, so the\n      // |background_image_skia_| doesn't need to set the host to call\n      // LoadForScaleFactor again. Otherwise, it might duplicate the opened\n      // files number, and cause the system crash,\n      background_image_skia_ = gfx::ImageSkia(\n          std::make_unique<Source>(nullptr, resource_size_in_dip),\n          resource_size);\n      for (const auto scale_factor : scale_factors) {\n        foreground_incomplete_scale_factors_.insert(\n            {scale_factor, base::Time::Now()});\n        background_incomplete_scale_factors_.insert(\n            {scale_factor, base::Time::Now()});\n        is_adaptive_icons_.insert({scale_factor, true});\n      }\n      // Deliberately fall through to IconType::kUncompressed to update\n      // |image_skia_| and |incomplete_scale_factors_|.\n      [[fallthrough]];\n    case IconType::kUncompressed:\n      image_skia_ = gfx::ImageSkia(\n          std::make_unique<Source>(weak_ptr_factory_.GetWeakPtr(),\n                                   resource_size_in_dip),\n          resource_size);\n      // Deliberately fall through to IconType::kCompressed to update\n      // |incomplete_scale_factors_|.\n      [[fallthrough]];\n    case IconType::kCompressed:\n      for (const auto scale_factor : scale_factors) {\n        incomplete_scale_factors_.insert({scale_factor, base::Time::Now()});\n        if (icon_type != IconType::kAdaptive)\n          is_adaptive_icons_.insert({scale_factor, false});\n      }\n      break;\n  }\n}","pos":-1,"query":"initializeIconImagesAndScaleFactors","filepos":267,"timecost":1091.8672999999835,"filemrr":0.9},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\system\\automatic_reboot_manager.cc:301-390","function":"AutomaticRebootManager::Reschedule","codesnippet":"{\n  VLOG(1) << \"Rescheduling reboot\";\n  // Safeguard against reboot loops under error conditions: If the boot time is\n  // unavailable because /proc/uptime could not be read, do nothing.\n  if (!boot_time_)\n    return;\n\n  // Assume that no reboot has been requested.\n  reboot_requested_ = false;\n\n  // If an uptime limit is set, calculate the time at which it should cause a\n  // reboot to be requested.\n  const base::TimeDelta uptime_limit = base::Seconds(\n      local_state_registrar_.prefs()->GetInteger(prefs::kUptimeLimit));\n  base::TimeTicks reboot_request_time = *boot_time_ + uptime_limit;\n  bool have_reboot_request_time = !uptime_limit.is_zero();\n  if (have_reboot_request_time)\n    reboot_reason_ = AutomaticRebootManagerObserver::REBOOT_REASON_PERIODIC;\n\n  // If the policy to automatically reboot after an update is enabled and an\n  // update has been applied, set the time at which a reboot should be\n  // requested to the minimum of its current value and the time when the reboot\n  // became necessary.\n  if (update_reboot_needed_time_ &&\n      local_state_registrar_.prefs()->GetBoolean(prefs::kRebootAfterUpdate) &&\n      (!have_reboot_request_time ||\n       *update_reboot_needed_time_ < reboot_request_time)) {\n    VLOG(1) << \"Scheduling reboot because of OS update\";\n    reboot_request_time = *update_reboot_needed_time_;\n    have_reboot_request_time = true;\n    reboot_reason_ = AutomaticRebootManagerObserver::REBOOT_REASON_OS_UPDATE;\n  }\n\n  // If no reboot should be requested, remove any grace period.\n  if (!have_reboot_request_time) {\n    grace_start_timer_.reset();\n    grace_end_timer_.reset();\n    return;\n  }\n\n  // Safeguard against reboot loops: Ensure that the uptime after which a reboot\n  // is actually requested and the grace period begins is never less than\n  // |kMinRebootUptime| or the value passed in |kMinRebootUptimeMsSwitch|.\n  base::TimeDelta minRebootUptime = kMinRebootUptime;\n\n  if (auto* command_line = base::CommandLine::ForCurrentProcess();\n      command_line && command_line->HasSwitch(kMinRebootUptimeMsSwitch)) {\n    int parsed_value = 0;\n    std::string switch_value =\n        command_line->GetSwitchValueASCII(kMinRebootUptimeMsSwitch);\n\n    if (base::StringToInt(switch_value, &parsed_value)) {\n      minRebootUptime = base::Milliseconds(parsed_value);\n    } else {\n      LOG(WARNING) << \"Failed to parse kMinRebootUptimeMsSwitch's value \"\n                   << switch_value;\n    }\n  }\n\n  const base::TimeTicks now = tick_clock_->NowTicks();\n  const base::Time wall_clock_now = clock_->Now();\n  const base::TimeTicks grace_start_time =\n      std::max(reboot_request_time, *boot_time_ + minRebootUptime);\n\n  // Set up a timer for the start of the grace period. If the grace period\n  // started in the past, the timer is still used with its delay set to zero.\n  if (!grace_start_timer_)\n    grace_start_timer_ =\n        std::make_unique<base::WallClockTimer>(clock_, tick_clock_);\n  VLOG(1) << \"Scheduling reboot attempt at \"\n          << wall_clock_now + (grace_start_time - now);\n  grace_start_timer_->Start(\n      FROM_HERE,\n      wall_clock_now + std::max(grace_start_time - now, base::TimeDelta()),\n      base::BindOnce(&AutomaticRebootManager::RequestReboot,\n                     base::Unretained(this)));\n\n  const base::TimeTicks grace_end_time =\n      grace_start_time + base::Milliseconds(kGracePeriodMs);\n  // Set up a timer for the end of the grace period. If the grace period ended\n  // in the past, the timer is still used with its delay set to zero.\n  if (!grace_end_timer_)\n    grace_end_timer_ =\n        std::make_unique<base::WallClockTimer>(clock_, tick_clock_);\n  VLOG(1) << \"Scheduling unconditional reboot at \"\n          << wall_clock_now + (grace_end_time - now);\n  grace_end_timer_->Start(\n      FROM_HERE,\n      wall_clock_now + std::max(grace_end_time - now, base::TimeDelta()),\n      base::BindOnce(&AutomaticRebootManager::Reboot, base::Unretained(this)));\n}","pos":-1,"query":"Automatic reboot scheduling and management","filepos":3,"timecost":1387.0774000000092,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_pinned_sites\\pinned_sites_internal.cc:26-57","function":"FindTabWithPinUrl","codesnippet":"{\n  internal::BrowserTab result;\n  if (!pin_url.is_valid()) {\n    return result;\n  }\n\n  UrlMatcher url_matcher(pin_url);\n  for (Browser* browser : *browsers) {\n    // Only consider normal tabbed browsers for the specified profile.\n    if (browser->profile() != profile || !browser->is_type_normal()) {\n      continue;\n    }\n    TabStripModel* tabs = browser->tab_strip_model();\n    // Start searching from the active tab\n    const int start_index = std::max(0, tabs->active_index());\n    const int tab_count = tabs->count();\n    for (int i = 0; i < tab_count; ++i) {\n      const int tab_index = (start_index + i) % tab_count;\n      if (content::WebContents* tab = tabs->GetWebContentsAt(tab_index)) {\n        const GURL tab_url = tab->GetLastCommittedURL();\n        // Only an exact match will be returned.\n        if (url_matcher.TestUrl(tab_url) && url_matcher.FoundExactMatch()) {\n          VLOG(3) << \"  Exact match found: browser 0x\" << std::hex\n                  << \", tab_index=\" << tab_index;\n          return internal::BrowserTab{browser, tab_index};\n        }\n      }\n    }\n  }\n  return result;\n}","pos":-1,"query":"findExactMatchingTabInBrowsers","filepos":-1,"timecost":1129.2362999999896,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\devtools\\device\\windows_device_manager.cc:97-140","function":"DevToolsWindowsDeviceManager::ConnectDevice","codesnippet":"{\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  GURL url(address);\n  if (!url.is_valid()) {\n    std::move(callback).Run(404, \"invalid URL\");\n    return;\n  }\n\n  GURL::Replacements replacements;\n  replacements.SetPathStr(\"/msedge/json/deviceinfo\");\n  url = url.ReplaceComponents(replacements);\n\n  auto req = std::make_unique<network::ResourceRequest>();\n  // Omit any credentials stored in the network context. This ensures that the\n  // user will go through the auth flow on the edge://inspect page and provide\n  // credentials to the DevToolsWindowsDeviceManager.\n  req->credentials_mode = network::mojom::CredentialsMode::kOmit;\n  req->url = url;\n\n  if (!username.empty() && !password.empty()) {\n    std::string encoded_credentials =\n        base::Base64Encode(username + \":\" + password);\n    const auto headers = \"Authorization: Basic \" + encoded_credentials;\n    req->headers.AddHeadersFromString(headers);\n  }\n\n  auto loader = network::SimpleURLLoader::Create(std::move(req),\n                                                 GetTrafficAnnotationTag());\n  loader->SetTimeoutDuration(base::Seconds(10));\n\n  const url::SchemeHostPort origin(url);\n\n  auto* loader_raw = loader.get();\n  loader_raw->DownloadToString(\n      url_loader_factory_.get(),\n      base::BindOnce(\n          &DevToolsWindowsDeviceManager::ConnectDeviceResponseReceived,\n          base::Unretained(this), std::move(loader), origin, username, password,\n          std::move(callback)),\n      network::SimpleURLLoader::kMaxBoundedStringDownloadSize);\n}","pos":-1,"query":"FetchDeviceInfoWithAuthHeader","filepos":-1,"timecost":1075.9097000000183,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\arc\\arc_app_icon.cc:381-435","function":"ArcAppIcon::LoadForScaleFactor","codesnippet":"{\n  // We provide Play Store icon from Chrome resources and it is not expected\n  // that we have external load request.\n  DCHECK_NE(app_id(), arc::kPlayStoreAppId);\n\n  ArcAppListPrefs* const prefs = ArcAppListPrefs::Get(context_);\n  DCHECK(prefs);\n\n  const ArcAppIconDescriptor descriptor(resource_size_in_dip_, scale_factor);\n  std::vector<base::FilePath> paths;\n  std::vector<base::FilePath> default_app_paths;\n  switch (icon_type_) {\n    case IconType::kAdaptive: {\n      base::FilePath foreground_path =\n          prefs->GetForegroundIconPath(mapped_app_id_, descriptor);\n      base::FilePath background_path =\n          prefs->GetBackgroundIconPath(mapped_app_id_, descriptor);\n      if (foreground_path.empty() || background_path.empty())\n        return;\n      paths.emplace_back(foreground_path);\n      paths.emplace_back(background_path);\n\n      default_app_paths.emplace_back(\n          prefs->MaybeGetForegroundIconPathForDefaultApp(mapped_app_id_,\n                                                         descriptor));\n      default_app_paths.emplace_back(\n          prefs->MaybeGetBackgroundIconPathForDefaultApp(mapped_app_id_,\n                                                         descriptor));\n      // Deliberately fall through to IconType::kCompressed to add |path| to\n      // |paths|. For the migration scenario, when the foreground icon file\n      // doesn't exist, load the original icon file to resolve the icon lag\n      // issue.\n      [[fallthrough]];\n    }\n    case IconType::kUncompressed: {\n      // Deliberately fall through to IconType::kCompressed to add |path| to\n      // |paths|.\n      [[fallthrough]];\n    }\n    case IconType::kCompressed: {\n      base::FilePath path = prefs->GetIconPath(mapped_app_id_, descriptor);\n      if (path.empty())\n        return;\n      paths.emplace_back(path);\n      default_app_paths.emplace_back(\n          prefs->MaybeGetIconPathForDefaultApp(mapped_app_id_, descriptor));\n      break;\n    }\n  }\n\n  base::ThreadPool::PostTaskAndReplyWithResult(\n      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},\n      base::BindOnce(&ArcAppIcon::ReadOnBackgroundThread, icon_type_,\n                     scale_factor, paths, default_app_paths),\n      base::BindOnce(&ArcAppIcon::OnIconRead, weak_ptr_factory_.GetWeakPtr()));\n}","pos":128,"query":"Load and process app icons asynchronously.","filepos":102,"timecost":1307.411300000007,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\profiles\\edge_web_signin_cta_view.cc:238-307","function":"EdgeWebSignInCtaView::CreateContent","codesnippet":"{\n  auto content_view = std::make_unique<views::View>();\n  auto* layout =\n      content_view->SetLayoutManager(std::make_unique<views::FlexLayout>());\n  content_view->SetLayoutManagerUseConstrainedSpace(false);\n  layout->SetOrientation(views::LayoutOrientation::kVertical)\n      .SetMainAxisAlignment(views::LayoutAlignment::kStart)\n      .SetCrossAxisAlignment(views::LayoutAlignment::kStart);\n  layout->SetInteriorMargin(kContentInsets);\n\n  auto title_view = std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_EDGE_WEB_SIGN_IN_CTA_TITLE));\n  title_view->SetMultiLine(true);\n  title_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  title_view->SetMaximumWidth(kTextWidth);\n  title_view->SetLineHeight(kTitleLineHeight);\n  title_view->SetFontList(gfx::FontList({kFontFamily}, gfx::Font::NORMAL,\n                                        kTitleFontSize,\n                                        gfx::Font::Weight::BOLD));\n  content_view->AddChildView(std::move(title_view));\n\n  auto title_view_spacer = std::make_unique<views::View>();\n  title_view_spacer->SetPreferredSize(\n      gfx::Size(1, kContentInteriorSpacerHeight));\n  content_view->AddChildView(std::move(title_view_spacer));\n\n  auto description_view = std::make_unique<views::Label>(\n      l10n_util::GetStringUTF16(IDS_EDGE_WEB_SIGN_IN_CTA_DESCRIPTION));\n  description_view->SetMultiLine(true);\n  description_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n  description_view->SetMaximumWidth(kTextWidth);\n  description_view->SetLineHeight(kDescriptionLineHeight);\n  description_view->SetFontList(gfx::FontList({kFontFamily}, gfx::Font::NORMAL,\n                                              kDescriptionFontSize,\n                                              gfx::Font::Weight::NORMAL));\n  content_view->AddChildView(std::move(description_view));\n\n  if (combined_sync_enabled_) {\n    auto combined_sync_spacer = std::make_unique<views::View>();\n    combined_sync_spacer->SetPreferredSize(\n        gfx::Size(1, kContentInteriorSpacerHeight));\n    content_view->AddChildView(std::move(combined_sync_spacer));\n\n    auto combined_sync_text =\n        std::make_unique<views::Label>(l10n_util::GetStringUTF16(\n            IDS_PROFILES_SIGNIN_TEXT_COMBINED_SYNC_SIGNIN_HISTORY_ENABLED));\n    combined_sync_text->SetMultiLine(true);\n    combined_sync_text->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n    combined_sync_text->SetMaximumWidth(kTextWidth);\n    combined_sync_text->SetLineHeight(kPrivacyLineHeight);\n    combined_sync_text->SetFontList(\n        gfx::FontList({kFontFamily}, gfx::Font::NORMAL, kPrivacyFontSize,\n                      gfx::Font::Weight::NORMAL));\n    content_view->AddChildView(std::move(combined_sync_text));\n\n    auto privacy_link = CreateLink(\n        l10n_util::GetStringUTF16(IDS_PROFILES_MICROSOFT_PRIVACY_LINK),\n        base::BindRepeating(&EdgeWebSignInCtaView::OnPrivacyLinkClicked,\n                            weak_factory_.GetWeakPtr()));\n    privacy_link->SetMultiLine(true);\n    privacy_link->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n    privacy_link->SetMaximumWidth(kTextWidth);\n    privacy_link->SetLineHeight(kPrivacyLineHeight);\n    privacy_link->SetFontList(gfx::FontList({kFontFamily}, gfx::Font::NORMAL,\n                                            kPrivacyFontSize,\n                                            gfx::Font::Weight::NORMAL));\n    content_view->AddChildView(std::move(privacy_link));\n  }\n\n  return content_view;\n}","pos":0,"query":"createEdgeWebSignInCtaViewContent","filepos":0,"timecost":994.1984999999986,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\apps\\app_service\\app_service_proxy_base.cc:79-110","function":"AppServiceProxyBase::AppInnerIconLoader::LoadIconFromIconKey","codesnippet":"{\n  if (overriding_icon_loader_for_testing_) {\n    return overriding_icon_loader_for_testing_->LoadIconFromIconKey(\n        id, icon_key, icon_type, size_hint_in_dip, allow_placeholder_icon,\n        std::move(callback));\n  }\n\n  AppType app_type = host_->AppRegistryCache().GetAppType(id);\n  if (host_->ShouldReadIcons(app_type)) {\n    host_->ReadIcons(app_type, id, size_hint_in_dip, icon_key.Clone(),\n                     icon_type, std::move(callback));\n    return nullptr;\n  }\n\n  auto* publisher = host_->GetPublisher(app_type);\n  if (!publisher) {\n    LOG(WARNING) << \"No publisher for requested icon\";\n    std::move(callback).Run(std::make_unique<IconValue>());\n    return nullptr;\n  }\n\n  RecordIconLoadMethodMetrics(IconLoadingMethod::kViaNonMojomCall);\n  publisher->LoadIcon(id, icon_key, icon_type, size_hint_in_dip,\n                      allow_placeholder_icon, std::move(callback));\n  return nullptr;\n}","pos":-1,"query":"LoadAppIconWithFallbacks","filepos":81,"timecost":858.059500000003,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_workspaces\\desktop\\collaborative_web_contents_delegate_desktop.cc:152-200","function":"unknown","codesnippet":"{\n  if (!browser_) {\n    return nullptr;\n  }\n\n  core().LogMessage(\n      fluid::mojom::MessageLevel::kInfo, \"ReplaceWebContents\",\n      base::Value::Dict()\n          .Set(\"tab\", core().fluid_guid())\n          .Set(\"navigations\", static_cast<int>(navigation_stack.size())));\n\n  content::WebContents* web_contents = nullptr;\n  const int tab_index =\n      browser_->tab_strip_model()->GetIndexOfWebContents(current_web_contents);\n\n  // On adding a new tab sometimes chrome will insert a web contents with no\n  // navigation stack, then update the navigation stack. If this happens the\n  // navigation_stack will be empty. In such a case we replace the tab with a\n  // new web_contents.\n  if (navigation_stack.empty()) {\n    content::WebContents::CreateParams const create_params(core().profile_);\n    std::unique_ptr<content::WebContents> new_web_contents =\n        content::WebContents::Create(create_params);\n\n    web_contents = new_web_contents.get();\n\n    browser_->tab_strip_model()->DiscardWebContentsAt(\n        tab_index, std::move(new_web_contents));\n  } else {\n    // Unused data types\n    std::string const extension_app_id;\n    content::SessionStorageNamespace* storage_namespace = nullptr;\n    sessions::SerializedUserAgentOverride const user_agent_override;\n    std::map<int, std::string> const ie_region_guids;\n\n    web_contents = chrome::ReplaceRestoredTabAt(\n        browser_.get(), navigation_stack, tab_index, selected_navigation,\n        extension_app_id, storage_namespace, user_agent_override,\n        false /* from_session_restore */, ie_region_guids,\n        false /* rbi_pinned */, core().GetTabGroupId(),\n        true /* use_replace_web_contents_at */, from_fluid);\n  }\n\n  return web_contents;\n}","pos":0,"query":"replaceOrCreateWebContentsInTab","filepos":0,"timecost":2087.741700000013,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\download\\download_query.cc:286-319","function":"DownloadQuery::MatchesQuery","codesnippet":"{\n  if (query_terms.empty())\n    return true;\n\n  std::u16string original_url_raw(\n      base::UTF8ToUTF16(item.GetOriginalUrl().spec()));\n  std::u16string url_raw(base::UTF8ToUTF16(item.GetURL().spec()));\n  // Try to also match query with above URLs formatted in user display friendly\n  // way. This will unescape characters (including spaces) and trim all extra\n  // data (like username and password) from raw url so that for example raw url\n  // \"http://some.server.org/example%20download/file.zip\" will be matched with\n  // search term \"example download\".\n  std::u16string original_url_formatted(\n      url_formatter::FormatUrl(item.GetOriginalUrl()));\n  std::u16string url_formatted(url_formatter::FormatUrl(item.GetURL()));\n  std::u16string path(item.GetTargetFilePath().LossyDisplayName());\n\n  for (auto it = query_terms.begin(); it != query_terms.end(); ++it) {\n    std::u16string term = base::i18n::ToLower(*it);\n    if (!base::i18n::StringSearchIgnoringCaseAndAccents(term, original_url_raw,\n                                                        nullptr, nullptr) &&\n        !base::i18n::StringSearchIgnoringCaseAndAccents(\n            term, original_url_formatted, nullptr, nullptr) &&\n        !base::i18n::StringSearchIgnoringCaseAndAccents(term, url_raw, nullptr,\n                                                        nullptr) &&\n        !base::i18n::StringSearchIgnoringCaseAndAccents(term, url_formatted,\n                                                        nullptr, nullptr) &&\n        !base::i18n::StringSearchIgnoringCaseAndAccents(term, path, nullptr,\n                                                        nullptr)) {\n      return false;\n    }\n  }\n  return true;\n}","pos":-1,"query":"URL and path query matcher","filepos":-1,"timecost":949.6913000000059,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\policy\\reporting\\metrics_reporting\\network\\network_telemetry_sampler.cc:171-295","function":"NetworkTelemetrySampler::CollectNetworksStates","codesnippet":"{\n  if (cros_healthd_telemetry.is_null() ||\n      cros_healthd_telemetry->network_interface_result.is_null()) {\n    DVLOG(1) << \"cros_healthd: Error getting network result, result is null.\";\n  } else if (cros_healthd_telemetry->network_interface_result->is_error()) {\n    DVLOG(1)\n        << \"cros_healthd: Error getting network result: \"\n        << cros_healthd_telemetry->network_interface_result->get_error()->msg;\n  }\n\n  MetricData metric_data;\n  ::ash::NetworkStateHandler::NetworkStateList network_state_list =\n      GetNetworkStateList();\n  if (network_state_list.empty()) {\n    std::move(callback).Run(std::nullopt);\n    return;\n  }\n\n  bool should_report = false;\n  for (const auto* network : network_state_list) {\n    ::ash::NetworkTypePattern type =\n        ::ash::NetworkTypePattern::Primitive(network->type());\n    // Only collect and report networks of any types that are connected, or wifi\n    // networks that have signal strength regardless of their connection states.\n    if (!network->IsConnectedState() &&\n        (!type.Equals(::ash::NetworkTypePattern::WiFi()) ||\n         network->signal_strength() == 0)) {\n      continue;\n    }\n\n    should_report = true;\n\n    NetworkTelemetry* const network_telemetry =\n        metric_data.mutable_telemetry_data()\n            ->mutable_networks_telemetry()\n            ->add_network_telemetry();\n\n    network_telemetry->set_guid(network->guid());\n\n    network_telemetry->set_type(GetNetworkType(type));\n\n    network_telemetry->set_connection_state(GetNetworkConnectionState(network));\n\n    if (!network->device_path().empty()) {\n      network_telemetry->set_device_path(network->device_path());\n    }\n\n    const auto* network_config = network->network_config();\n    if (network_config) {\n      if (network_config->ipv4_address.has_value()) {\n        network_telemetry->set_ip_address(\n            network_config->ipv4_address->addr.ToString());\n      }\n      if (network_config->ipv4_gateway.has_value()) {\n        network_telemetry->set_gateway(\n            network_config->ipv4_gateway->ToString());\n      }\n\n      for (const auto& ipv6_address : network_config->ipv6_addresses) {\n        network_telemetry->add_ipv6_address(ipv6_address.addr.ToString());\n      }\n\n      if (network_config->ipv6_gateway.has_value()) {\n        network_telemetry->set_ipv6_gateway(\n            network_config->ipv6_gateway->ToString());\n      }\n    }\n\n    network_telemetry->set_is_metered(network->metered());\n\n    if (network->max_downlink_speed_kbps().has_value()) {\n      network_telemetry->set_link_down_speed_kbps(\n          network->max_downlink_speed_kbps().value());\n    }\n\n    if (type.Equals(::ash::NetworkTypePattern::WiFi())) {\n      network_telemetry->set_signal_strength(network->signal_strength());\n      if (base::Contains(service_path_rssi_map, network->path())) {\n        network_telemetry->set_signal_strength_dbm(\n            service_path_rssi_map.at(network->path()));\n      } else {\n        DVLOG(1) << \"Wifi signal RSSI not found in the service to signal \"\n                    \"map for service: \"\n                 << network->path();\n      }\n\n      const auto& network_interface_info = GetWifiNetworkInterfaceInfo(\n          network->device_path(), cros_healthd_telemetry);\n      if (!network_interface_info.is_null() &&\n          !network_interface_info->get_wireless_interface_info().is_null()) {\n        const auto& wireless_info =\n            network_interface_info->get_wireless_interface_info();\n\n        // Power management can be set even if the device is not connected to an\n        // access point.\n        network_telemetry->set_power_management_enabled(\n            wireless_info->power_management_on);\n\n        // wireless link info is only available when the device is\n        // connected to the access point.\n        if (!wireless_info->wireless_link_info.is_null() &&\n            network->IsConnectedState()) {\n          const auto& wireless_link_info = wireless_info->wireless_link_info;\n          network_telemetry->set_tx_bit_rate_mbps(\n              wireless_link_info->tx_bit_rate_mbps);\n          network_telemetry->set_rx_bit_rate_mbps(\n              wireless_link_info->rx_bit_rate_mbps);\n          network_telemetry->set_tx_power_dbm(wireless_link_info->tx_power_dBm);\n          network_telemetry->set_encryption_on(\n              wireless_link_info->encyption_on);\n          network_telemetry->set_link_quality(wireless_link_info->link_quality);\n        }\n      }\n    }\n  }\n\n  if (should_report) {\n    std::move(callback).Run(std::move(metric_data));\n    return;\n  }\n\n  std::move(callback).Run(std::nullopt);\n}","pos":11,"query":"collectAndReportNetworkTelemetry","filepos":10,"timecost":1382.988400000002,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_sleeping_tabs\\sleeping_tabs_snapshot_data.cc:19-83","function":"SleepingTabsSnapshotData::Fill","codesnippet":"{\n  BrowserList* browser_list = BrowserList::GetInstance();\n  for (Browser* browser : *browser_list) {\n    sleeping_tabs_enabled_ =\n        edge::sleeping_tabs::SleepingTabsManager::IsSleepingTabsTurnedOn(\n            browser->profile());\n    sleeping_tabs_threshold_ =\n        edge::sleeping_tabs::SleepingTabsManager::GetSleepingTabsTimeout(\n            browser->profile());\n\n    for (int i = 0; i < browser->tab_strip_model()->count(); ++i) {\n      content::WebContents* web_contents =\n          browser->tab_strip_model()->GetWebContentsAt(i);\n      auto* tab_lifecycle_unit_external =\n          resource_coordinator::TabLifecycleUnitExternal::FromWebContents(\n              web_contents);\n      if (!tab_lifecycle_unit_external)\n        continue;\n\n      ++tab_count_total_;\n\n      // Don't check the decision details for frozen, discarded, or visible tabs\n      if (tab_lifecycle_unit_external->IsFrozen()) {\n        tab_count_map_[TabFreezeEligibilityType::Frozen]++;\n\n        auto last_frozen_time =\n            tab_lifecycle_unit_external->GetWallTimeWhenFrozen();\n        if (!last_frozen_time.is_max())\n          total_tab_sleep_time_ +=\n              resource_coordinator::NowTicks() - last_frozen_time;\n\n        continue;\n      }\n      if (tab_lifecycle_unit_external->GetTabState() ==\n          ::mojom::LifecycleUnitState::DISCARDED) {\n        tab_count_map_[TabFreezeEligibilityType::Discarded]++;\n        continue;\n      }\n      if (web_contents->GetVisibility() == content::Visibility::VISIBLE) {\n        tab_count_map_[TabFreezeEligibilityType::Visible]++;\n        continue;\n      }\n\n      ++hidden_tab_count_total_;\n\n      resource_coordinator::DecisionDetails details;\n      const bool can_freeze =\n          tab_lifecycle_unit_external->IsAutoFreezable(details);\n      const auto reasons = details.reasons();\n      for (const auto& reason : reasons) {\n        if (reason.IsFailure())\n          decision_failure_map_[reason.failure_reason()]++;\n      }\n\n      if (can_freeze)\n        tab_count_map_[TabFreezeEligibilityType::CanFreeze]++;\n      else\n        tab_count_map_[TabFreezeEligibilityType::CannotFreeze]++;\n    }\n  }\n\n  if (tab_count_map_[TabFreezeEligibilityType::Frozen] > 0) {\n    average_tab_sleep_time_ = total_tab_sleep_time_ /\n                              tab_count_map_[TabFreezeEligibilityType::Frozen];\n  }\n}","pos":-1,"query":"Analyze browser tabs for freeze eligibility","filepos":-1,"timecost":1104.0072999999975,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\android\\customtabs\\custom_tabs_connection.cc:79-111","function":"JNI_CustomTabsConnection_CreateAndStartDetachedResourceRequest","codesnippet":"{\n  DCHECK(native_profile);\n\n  GURL native_url(url);\n  GURL native_origin(origin);\n  DCHECK(native_url.is_valid());\n  DCHECK(native_origin.is_valid());\n\n  // Java only knows about the blink referrer policy.\n  net::ReferrerPolicy url_request_referrer_policy =\n      content::Referrer::ReferrerPolicyForUrlRequest(\n          content::Referrer::ConvertToPolicy(referrer_policy));\n  DetachedResourceRequest::Motivation request_motivation =\n      static_cast<DetachedResourceRequest::Motivation>(motivation);\n\n  DetachedResourceRequest::OnResultCallback cb =\n      session.is_null()\n          ? base::DoNothing()\n          : base::BindOnce(&NotifyClientOfDetachedRequestCompletion,\n                           base::android::ScopedJavaGlobalRef<jobject>(session),\n                           native_url);\n\n  DetachedResourceRequest::CreateAndStart(\n      native_profile, native_url, native_origin, url_request_referrer_policy,\n      request_motivation, package_name, std::move(cb));\n}","pos":-1,"query":"CreateAndStartDetachedResourceRequest","filepos":-1,"timecost":1104.2507999999798,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\sanitized_image_source.cc:129-220","function":"SanitizedImageSource::StartDataRequest","codesnippet":"{\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  std::string image_url_or_params = url.query();\n  if (url != GURL(base::StrCat(\n                 {chrome::kChromeUIImageURL, \"?\", image_url_or_params}))) {\n    std::move(callback).Run(nullptr);\n    return;\n  }\n\n  RequestAttributes request_attributes;\n  GURL image_url = GURL(image_url_or_params);\n  bool send_auth_token = false;\n  if (!image_url.is_valid()) {\n    // Attempt to parse URL and additional options from params.\n    auto params = ParseParams(image_url_or_params);\n\n    auto url_it = params.find(kUrlKey);\n    if (url_it == params.end()) {\n      std::move(callback).Run(nullptr);\n      return;\n    }\n    image_url = GURL(url_it->second);\n\n    auto static_encode_it = params.find(kStaticEncodeKey);\n    if (static_encode_it != params.end()) {\n      request_attributes.static_encode = static_encode_it->second == \"true\";\n    }\n\n    auto encode_type_ir = params.find(kEncodeTypeKey);\n    if (encode_type_ir != params.end()) {\n      request_attributes.encode_type =\n          encode_type_ir->second == \"webp\"\n              ? RequestAttributes::EncodeType::kWebP\n              : RequestAttributes::EncodeType::kPng;\n    }\n\n    auto google_photos_it = params.find(kIsGooglePhotosKey);\n    if (google_photos_it != params.end() &&\n        google_photos_it->second == \"true\" && IsGooglePhotosUrl(image_url)) {\n      send_auth_token = true;\n    }\n  }\n\n  if (image_url.SchemeIs(url::kHttpScheme)) {\n    // Disallow any HTTP requests, treat them as a failure instead.\n    std::move(callback).Run(nullptr);\n    return;\n  }\n\n  request_attributes.image_url = image_url;\n\n  // Download the image body.\n  if (!send_auth_token) {\n    StartImageDownload(std::move(request_attributes), std::move(callback));\n    return;\n  }\n\n  // Request an auth token for downloading the image body.\n  auto fetcher = std::make_unique<signin::PrimaryAccountAccessTokenFetcher>(\n      \"sanitized_image_source\", identity_manager_,\n      signin::ScopeSet({GaiaConstants::kPhotosModuleImageOAuth2Scope}),\n      signin::PrimaryAccountAccessTokenFetcher::Mode::kImmediate,\n      signin::ConsentLevel::kSignin);\n  auto* fetcher_ptr = fetcher.get();\n  fetcher_ptr->Start(base::BindOnce(\n      [](const base::WeakPtr<SanitizedImageSource>& self,\n         std::unique_ptr<signin::PrimaryAccountAccessTokenFetcher> fetcher,\n         RequestAttributes request_attributes,\n         content::URLDataSource::GotDataCallback callback,\n         GoogleServiceAuthError error,\n         signin::AccessTokenInfo access_token_info) {\n        if (error.state() != GoogleServiceAuthError::NONE) {\n          LOG(ERROR) << \"Failed to authenticate for Google Photos in order to \"\n                        \"download \"\n                     << request_attributes.image_url.spec()\n                     << \". Error message: \" << error.ToString();\n          return;\n        }\n\n        request_attributes.access_token_info = access_token_info;\n\n        if (self) {\n          self->StartImageDownload(std::move(request_attributes),\n                                   std::move(callback));\n        }\n      },\n      weak_ptr_factory_.GetWeakPtr(), std::move(fetcher),\n      std::move(request_attributes), std::move(callback)));\n}","pos":-1,"query":"Download and authenticate image request","filepos":-1,"timecost":1299.8006999999925,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\input_method\\japanese\\japanese_settings.cc:200-275","function":"ToMojomInputMethodSettings","codesnippet":"{\n  JapaneseSettingsPtr response = MakeDefaultJapaneseSettings();\n  if (const std::string* val = prefs.FindString(kJpPrefInputMode);\n      val != nullptr) {\n    if (auto it = kInputModes.find(*val); it != kInputModes.end()) {\n      response->input_mode = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefPunctuationStyle);\n      val != nullptr) {\n    if (auto it = kPunctuations.find(*val); it != kPunctuations.end()) {\n      response->punctuation_style = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefSymbolStyle);\n      val != nullptr) {\n    if (auto it = kSymbols.find(*val); it != kSymbols.end()) {\n      response->symbol_style = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefSpaceInputStyle);\n      val != nullptr) {\n    if (auto it = kSpaceInputStyles.find(*val); it != kSpaceInputStyles.end()) {\n      response->space_input_style = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefSelectionShortcut);\n      val != nullptr) {\n    if (auto it = kSelectionShortcuts.find(*val);\n        it != kSelectionShortcuts.end()) {\n      response->selection_shortcut = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefKeymapStyle);\n      val != nullptr) {\n    if (auto it = kKeymapStyles.find(*val); it != kKeymapStyles.end()) {\n      response->keymap_style = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n  if (const std::string* val = prefs.FindString(kJpPrefShiftKeyModeStyle);\n      val != nullptr) {\n    if (auto it = kShiftKeyModeStyle.find(*val);\n        it != kShiftKeyModeStyle.end()) {\n      response->shift_key_mode_style = it->second;\n    } else {\n      LOG(ERROR) << \"Value not found for \" << *val;\n    }\n  }\n\n  response->use_input_history = prefs.FindBool(kJpPrefUseInputHistory)\n                                    .value_or(response->use_input_history);\n  response->use_system_dictionary =\n      prefs.FindBool(kJpPrefUseSystemDictionary)\n          .value_or(response->use_system_dictionary);\n  response->number_of_suggestions =\n      prefs.FindInt(kJpPrefNumberOfSuggestions)\n          .value_or(response->number_of_suggestions);\n  response->disable_personalized_suggestions =\n      prefs.FindBool(kJpPrefDisablePersonalizedSuggestions)\n          .value_or(response->disable_personalized_suggestions);\n  response->automatically_switch_to_halfwidth =\n      prefs.FindBool(kJpPrefAutomaticallySwitchToHalfwidth)\n          .value_or(response->automatically_switch_to_halfwidth);\n  return response;\n}","pos":-1,"query":"configureJapaneseSettingsFromPreferences","filepos":-1,"timecost":1220.284400000004,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\isolated_web_apps\\test\\bundle_versions_storage.cc:123-155","function":"BundleVersionsStorage::GetResource","codesnippet":"{\n  // Parses /<web_bundle_id>/<file_name> into { <web_bundle_id>, <file_name> }.\n  auto pieces = base::SplitString(route, \"/\", base::TRIM_WHITESPACE,\n                                  base::SPLIT_WANT_NONEMPTY);\n  if (pieces.size() != 2) {\n    return std::nullopt;\n  }\n\n  ASSIGN_OR_RETURN(auto web_bundle_id,\n                   web_package::SignedWebBundleId::Create(pieces[0]),\n                   [](auto) -> std::optional<BundleOrUpdateManifest> {\n                     return std::nullopt;\n                   });\n  const auto* bundle_versions =\n      base::FindOrNull(bundle_versions_per_id_, web_bundle_id);\n  if (!bundle_versions) {\n    return std::nullopt;\n  }\n\n  const auto& path = pieces[1];\n  if (path == kUpdateManifestFileName) {\n    return GetUpdateManifest(web_bundle_id);\n  } else if (path.ends_with(\".swbn\")) {\n    base::Version version(path.substr(0, path.size() - 5));\n    if (version.IsValid()) {\n      if (auto* bundle_info = base::FindPtrOrNull(*bundle_versions, version)) {\n        return bundle_info->bundle.get();\n      }\n    }\n  }\n\n  return std::nullopt;\n}","pos":-1,"query":"parseAndRetrieveWebBundleInfo","filepos":-1,"timecost":1977.772799999977,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\android\\httpclient\\http_client.cc:116-155","function":"HttpClient::OnSimpleLoaderComplete","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  int32_t response_code = 0;\n  int32_t net_error_code = simple_loader->NetError();\n\n  std::map<std::string, std::string> response_headers;\n  auto* response_info = simple_loader->ResponseInfo();\n  if (response_info && response_info->headers) {\n    response_code = response_info->headers->response_code();\n\n    size_t iter = 0;\n    std::string name, value;\n    while (response_info->headers->EnumerateHeaderLines(&iter, &name, &value)) {\n      std::string& slot = response_headers[name];\n      if (slot.empty()) {\n        slot = std::move(value);\n      } else {\n        slot += '\\n';\n        slot += value;\n      }\n    }\n  }\n\n  // If the response string is empty, that means a network error exists.\n  // We'll not populate the response body in that case.\n  std::vector<uint8_t> response_body;\n  if (response) {\n    const uint8_t* begin = reinterpret_cast<const uint8_t*>(response->data());\n    const uint8_t* end = begin + response->size();\n    response_body.assign(begin, end);\n  }\n\n  ReleaseUrlLoader(simple_loader);\n\n  std::move(response_callback)\n      .Run(response_code, net_error_code, std::move(response_body),\n           std::move(response_headers));\n}","pos":-1,"query":"Process HTTP response and invoke callback","filepos":217,"timecost":2195.0630999999994,"filemrr":0.7},{"filePath":"D:\\Edge\\src\\chrome\\browser\\lifetime\\application_lifetime_desktop.cc:380-431","function":"MarkAsCleanShutdown","codesnippet":"{\n#if BUILDFLAG(IS_CHROMEOS)\n  LogMarkAsCleanShutdown();\n  // Tracks profiles that have pending write of the exit type.\n  std::set<Profile*> pending_profiles;\n#endif  // BUILDFLAG(IS_CHROMEOS)\n\n  for (Browser* browser : *BrowserList::GetInstance()) {\n#if !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    if (ExitTypeService* exit_type_service =\n            ExitTypeService::GetInstanceForProfile(browser->profile())) {\n      exit_type_service->SetCurrentSessionExitType(ExitType::kClean);\n#else\n    if (EdgeExitTypeTracker* exit_type_tracker =\n            EdgeExitTypeTracker::GetInstanceForProfile(browser->profile())) {\n      exit_type_tracker->SetClean();\n#endif  // !BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n\n#if BUILDFLAG(IS_CHROMEOS)\n      // Explicitly schedule pending writes on ChromeOS so that even if the\n      // UI thread is hosed (e.g. taking a long time to close all tabs because\n      // of page faults/swap-in), the clean shutdown flag still gets a chance\n      // to be persisted. See https://crbug.com/1294764\n      Profile* profile = browser->profile();\n      if (pending_profiles.insert(profile).second) {\n        profile->GetPrefs()->CommitPendingWrite();\n      }\n#endif  // BUILDFLAG(IS_CHROMEOS)\n    }\n  }\n}\n\nbool AreAllBrowsersCloseable() {\n  if (BrowserList::GetInstance()->empty()) {\n    return true;\n  }\n\n  // If there are any downloads active, all browsers are not closeable.\n  // However, this does not block for malicious downloads.\n  if (DownloadCoreService::BlockingShutdownCountAllProfiles() > 0) {\n    return false;\n  }\n\n  // Check TabsNeedBeforeUnloadFired().\n  for (Browser* browser : *BrowserList::GetInstance()) {\n    if (browser->TabsNeedBeforeUnloadFired()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n}","pos":-1,"query":"Clean shutdown management, browser closeability check","filepos":42,"timecost":999.5158999999985,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\privacy\\page_data_provider_tracking_prevention_exceptions.cc:121-175","function":"TrackingPreventionExceptionsPageDataProvider::\n    RepopulateTrackerExceptionsTable","codesnippet":"{\n  table_utils::Table table;\n\n  BuildTableHeader(exceptions.size(), table);\n  for (const auto& exception_dict : exceptions) {\n    std::string serialized_data = SerializeDictToJSON(exception_dict);\n    const std::string* display_name = exception_dict.FindString(\"displayName\");\n    if (!display_name) {\n      continue;\n    }\n\n    const std::string* source = exception_dict.FindString(\"source\");\n    const bool is_policy_enforced =\n        (source && *source == site_settings::SiteSettingSourceToString(\n                                  site_settings::SiteSettingSource::kPolicy));\n\n    auto editDialog = BuildExceptionDialogInfo(*display_name);\n    table.AppendRow(\n        table_utils::Row()\n            .AppendCell(\n                table_utils::Cell(table_utils::CellType::Text, \"indent-cell\")\n                    .WithText(*display_name)\n                    .AppendIcon(*display_name, \"1x\"))\n            .AppendCell(\n                is_policy_enforced\n                    ? table_utils::Cell(table_utils::CellType::ManagedInfo)\n                          .WithManagedInfo(\n                              \"managedIcon\",\n                              GetResourceString(IDS_CONTROLLED_SETTING_POLICY))\n                    : table_utils::Cell(table_utils::CellType::Menu)\n                          .WithCellId(TrimAndRemoveSpace(*display_name))\n                          .AppendMenuItem(\"kEditIcon\",\n                                          GetResourceString(IDS_SETTINGS_EDIT),\n                                          mojom::FormControlIds::\n                                              EditTrackingPreventionException,\n                                          mojom::ButtonType::DialogButton,\n                                          mojom::ActionType::Command,\n                                          editDialog.first, \"normal\",\n                                          /*disabled=*/is_policy_enforced,\n                                          /*checked=*/false, editDialog.second,\n                                          serialized_data)\n                          .AppendMenuItem(\n                              \"kDeleteIcon\",\n                              GetResourceString(IDS_SETTINGS_REMOVE),\n                              mojom::FormControlIds::\n                                  RemoveTrackingPreventionException,\n                              mojom::ButtonType::ActionButton,\n                              mojom::ActionType::Command, serialized_data,\n                              \"normal\",\n                              /*disabled=*/is_policy_enforced)));\n  }\n\n  tracker_exceptions_table_->info = table.ToString();\n}","pos":-1,"query":"Builds and populates exception settings table.","filepos":-1,"timecost":1399.2188000000024,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\sync_file_system\\sync_file_system_service.cc:395-432","function":"SyncFileSystemService::Initialize","codesnippet":"{\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(local_service);\n  DCHECK(remote_service);\n  DCHECK(profile_);\n\n  local_service_ = std::move(local_service);\n  remote_service_ = std::move(remote_service);\n\n  auto local_syncer = std::make_unique<LocalSyncRunner>(kLocalSyncName, this);\n  auto remote_syncer = std::make_unique<RemoteSyncRunner>(\n      kRemoteSyncName, this, remote_service_.get());\n\n  local_service_->AddChangeObserver(local_syncer.get());\n  local_service_->SetLocalChangeProcessorCallback(base::BindRepeating(\n      &GetLocalChangeProcessorAdapter, weak_ptr_factory_.GetWeakPtr()));\n\n  remote_service_->AddServiceObserver(remote_syncer.get());\n  remote_service_->AddFileStatusObserver(this);\n  remote_service_->SetRemoteChangeProcessor(local_service_.get());\n\n  local_sync_runners_.push_back(std::move(local_syncer));\n  remote_sync_runners_.push_back(std::move(remote_syncer));\n\n  syncer::SyncService* sync_service =\n      SyncServiceFactory::GetForProfile(profile_);\n  if (sync_service) {\n    UpdateSyncEnabledStatus(sync_service);\n    sync_service->AddObserver(this);\n  }\n\n  ExtensionRegistry::Get(profile_)->AddObserver(this);\n\n  // Don't enable file sync.\n  // TODO(crbug.com/396460818): Cleanup file syncing.\n  remote_service_->SetSyncEnabled(false);\n}","pos":-1,"query":"initializeSyncServices","filepos":30,"timecost":1217.4882000000216,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\web_applications\\webui_web_app_navigation_throttle.cc:30-71","function":"WebUIWebAppNavigationThrottle::MaybeCreateThrottleFor","codesnippet":"{\n  if (!handle->IsInPrimaryMainFrame()) {\n    return nullptr;\n  }\n\n  // Reloading the page should not cause the tab to change.\n  if (handle->GetReloadType() != content::ReloadType::NONE) {\n    return nullptr;\n  }\n\n  content::WebContents* web_contents = handle->GetWebContents();\n\n  Browser* browser = chrome::FindBrowserWithTab(web_contents);\n  if (!browser || !browser->app_controller()) {\n    return nullptr;\n  }\n\n#if BUILDFLAG(IS_CHROMEOS)\n  // Exclude system web apps.\n  if (browser->app_controller()->system_app()) {\n    return nullptr;\n  }\n#endif\n\n  // Proceed only if the app is coming from Chrome WebUI.\n  GURL start_url = browser->app_controller()->GetAppStartUrl();\n  if (!content::HasWebUIScheme(start_url)) {\n    return nullptr;\n  }\n\n#if MICROSOFT_EDGE_BUILD\n  // Exclude sidepane.\n  if (browser->tab_strip_model() &&\n      browser->tab_strip_model()->GetIndexOfWebContents(web_contents) ==\n          TabStripModel::kNoTab) {\n    return nullptr;\n  }\n#endif  // MICROSOFT_EDGE_BUILD\n\n  return std::make_unique<WebUIWebAppNavigationThrottle>(handle);\n}","pos":-1,"query":"Create WebUI navigation throttle object","filepos":-1,"timecost":1079.4477999999945,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\devtools\\protocol\\extensions_handler.cc:203-236","function":"ExtensionsHandler::Uninstall","codesnippet":"{\n  if (!allow_loading_extensions_) {\n    std::move(callback)->sendFailure(\n        protocol::Response::ServerError(\"Method not available.\"));\n    return;\n  }\n\n  content::BrowserContext* context = ProfileManager::GetLastUsedProfile();\n  DCHECK(context);\n  extensions::ExtensionRegistry* registry =\n      extensions::ExtensionRegistry::Get(context);\n  const extensions::Extension* extension = registry->GetInstalledExtension(id);\n  if (!extension) {\n    std::move(callback)->sendFailure(protocol::Response::ServerError(\n        \"Uninstall failed. Reason: could not find extension.\"));\n    return;\n  }\n  if (extension->location() != extensions::mojom::ManifestLocation::kUnpacked) {\n    std::move(callback)->sendFailure(protocol::Response::ServerError(\n        \"Uninstall failed. Reason: extension is not an unpacked extension.\"));\n    return;\n  }\n\n  std::u16string error;\n  bool initiated =\n      extensions::ExtensionRegistrar::Get(context)->UninstallExtension(\n          id, extensions::UNINSTALL_REASON_USER_INITIATED, &error,\n          base::BindOnce(&ExtensionsHandler::OnUninstalled,\n                         weak_factory_.GetWeakPtr(), std::move(callback)));\n  if (!initiated) {\n    std::move(callback)->sendFailure(protocol::Response::ServerError(\n        \"Uninstall failed. Reason: \" + base::UTF16ToUTF8(error)));\n  }\n}","pos":11,"query":"Uninstalls unpacked browser extension","filepos":11,"timecost":872.0022999999928,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\commands\\web_app_icon_diagnostic_command.cc:60-96","function":"WebAppIconDiagnosticCommand::StartWithLock","codesnippet":"{\n  app_lock_ = std::move(lock);\n\n  const WebApp* web_app = app_lock_->registrar().GetAppById(app_id_);\n  if (!web_app) {\n    ReportResultAndDestroy(CommandResult::kFailure);\n    return;\n  }\n\n  const SortedSizesPx& downloaded_icon_sizes =\n      web_app->downloaded_icon_sizes(IconPurpose::ANY);\n  if (!downloaded_icon_sizes.empty()) {\n    icon_size_ = *downloaded_icon_sizes.begin();\n  }\n\n  result_.emplace();\n  result_->has_empty_downloaded_icon_sizes = downloaded_icon_sizes.empty();\n  result_->has_generated_icon_flag = web_app->is_generated_icon();\n\n  RunChainedCallbacks(\n      base::BindOnce(&WebAppIconDiagnosticCommand::LoadIconFromProvider,\n                     GetWeakPtr()),\n\n      base::BindOnce(\n          &WebAppIconDiagnosticCommand::DiagnoseGeneratedOrEmptyIconBitmap,\n          GetWeakPtr()),\n\n      base::BindOnce(\n          &WebAppIconDiagnosticCommand::CheckForEmptyOrMissingIconFiles,\n          GetWeakPtr()),\n\n      base::BindOnce(\n          &WebAppIconDiagnosticCommand::DiagnoseEmptyOrMissingIconFiles,\n          GetWeakPtr()),\n\n      base::BindOnce(&WebAppIconDiagnosticCommand::ReportResultAndDestroy,\n                     GetWeakPtr()));\n}","pos":1,"query":"WebAppIconDiagnosticProcessor","filepos":0,"timecost":927.4962999999989,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_desktop\\fre\\footer_view.cc:37-131","function":"FooterView::FooterView","codesnippet":"{\n  SetLayoutManager(std::make_unique<views::FlexLayout>())\n      ->SetOrientation(views::LayoutOrientation::kVertical)\n      .SetMainAxisAlignment(views::LayoutAlignment::kStart)\n      .SetCrossAxisAlignment(views::LayoutAlignment::kStretch)\n      .SetDefault(views::kMarginsKey, kDefaultMargin);\n\n  GetViewAccessibility().SetIsLeaf(true);\n  GetViewAccessibility().SetRole(ax::mojom::Role::kDialog);\n\n  // descitpion title.\n  description_title_view_ =\n      AddChildView(std::make_unique<views::StyledLabel>());\n  description_title_view_->SetTextContext(\n      ChromeTextContext::CONTEXT_WEB_WIDGET_TITLE_TEXT);\n  description_title_view_->SetHorizontalAlignment(gfx::ALIGN_CENTER);\n  description_title_view_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred, true));\n  // description.\n  description_view_ = AddChildView(std::make_unique<views::StyledLabel>());\n  description_view_->SetTextContext(\n      ChromeTextContext::CONTEXT_WEB_WIDGET_BODY_TEXT);\n  description_view_->SetDefaultTextStyle(\n      views::style::TextStyle::STYLE_PRIMARY);\n  description_view_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred, true));\n\n  // action.\n  action_button_container_ = AddChildView(std::make_unique<views::View>());\n  action_button_container_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred));\n\n  action_button_container_->SetLayoutManager(\n      std::make_unique<views::FillLayout>());\n  action_button_ = action_button_container_->AddChildView(\n      std::make_unique<views::MdTextButton>(base::BindRepeating(\n          &FooterView::OnClickButton, weak_factory_.GetWeakPtr(), false)));\n  action_button_->SetCornerRadius(4);\n  action_button_->SetHorizontalAlignment(\n      gfx::HorizontalAlignment::ALIGN_CENTER);\n  action_button_container_->SetVisible(false);\n\n  // turnoff button.\n  turnoff_button_container_ = AddChildView(std::make_unique<views::View>());\n  turnoff_button_container_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred));\n\n  turnoff_button_container_->SetLayoutManager(\n      std::make_unique<views::FillLayout>());\n  turnoff_button_ = turnoff_button_container_->AddChildView(\n      std::make_unique<views::LabelButton>(base::BindRepeating(\n          &FooterView::OnClickButton, weak_factory_.GetWeakPtr(), true)));\n  turnoff_button_->SetHorizontalAlignment(\n      gfx::HorizontalAlignment::ALIGN_CENTER);\n  turnoff_button_->SetEnabledTextColors(kColorEdgeSearchbarOptoutButton);\n  turnoff_button_container_->SetVisible(false);\n\n  // footnote.\n  footnote_view_ = AddChildView(std::make_unique<views::StyledLabel>());\n  footnote_view_->SetTextContext(\n      ChromeTextContext::CONTEXT_WEB_WIDGET_DISCLAIMER_TEXT);\n  footnote_view_->SetDefaultTextStyle(views::style::TextStyle::STYLE_DISABLED);\n  footnote_view_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,\n                               views::MaximumFlexSizeRule::kPreferred, true));\n  footnote_view_->SetVisible(false);\n\n  // footer_icon.\n  views::View* icon_container = AddChildView(std::make_unique<views::View>());\n  icon_container->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::MinimumFlexSizeRule::kScaleToZero,\n                               views::MaximumFlexSizeRule::kPreferred));\n  views::BoxLayout* icon_container_layout =\n      icon_container->SetLayoutManager(std::make_unique<views::BoxLayout>(\n          views::BoxLayout::Orientation::kHorizontal));\n  icon_container_layout->set_main_axis_alignment(\n      views::BoxLayout::MainAxisAlignment::kStart);\n  icon_container_layout->set_cross_axis_alignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n  icon_container_layout->set_between_child_spacing(kChildSpace);\n\n  footer_icon_view_ =\n      icon_container->AddChildView(std::make_unique<views::ImageView>());\n  footer_icon_text_view_ =\n      icon_container->AddChildView(std::make_unique<views::StyledLabel>());\n}","pos":-1,"query":"Initialize dialog layout and components","filepos":-1,"timecost":1086.739900000015,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\common\\common_settings_data_provider.cc:122-178","function":"CommonSettingsDataProvider::BuildColorsThemesSection","codesnippet":"{\n  const std::vector<std::pair<std::string, std::string>> options = {\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kOff)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_OFF_OPTION_TITLE)},\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kDusk)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_DUSK_OPTION_TITLE)},\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kDesert)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_DESERT_OPTION_TITLE)},\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kNightSky)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_NIGHT_SKY_OPTION_TITLE)},\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kWhite)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_WHITE_OPTION_TITLE)},\n      {base::NumberToString(\n           static_cast<int>(ui::NativeTheme::PageColors::kAquatic)),\n       GetResourceString(\n           IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_AQUATIC_OPTION_TITLE)},\n\n  };\n\n  auto* row = BuildSelectRow(\n      section, options, mojom::FormControlIds::PageColorsSelectRow, \"\" /*icon*/,\n      IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS, prefs::kPageColors,\n      IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_COMBO_BOX_SUBTITLE);\n\n  if (current_page_id == mojom::SettingsPageIds::Accessibility) {\n    row->buttons[0]->passThrough = base::NumberToString(\n        static_cast<int>(PageColorsSectionOrigins::kMakeEdgeEasierToSee));\n  } else if (current_page_id == mojom::SettingsPageIds::Appearance) {\n    row->buttons[0]->passThrough = base::NumberToString(\n        static_cast<int>(PageColorsSectionOrigins::kCustomizeAppearance));\n  }\n\n  const char* pref_control = prefs::kApplyPageColorsOnlyOnIncreasedContrast;\n  BuildToggleRow(\n      section, mojom::FormControlIds::PageColorsOnlyOnIncreasedContrastToggle,\n      \"\",\n      IDS_SETTINGS_ACCESSIBILITY_APPLY_PAGE_COLORS_ONLY_ON_INCREASED_CONTRAST_TOGGLE_TITLE,\n      pref_control, 0);\n\n  BuildSubPageLinkRow(\n      section, \"\", mojom::FormControlIds::ConfigurePageColorsBlocklistRow,\n      sub_page_id,\n      IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_BLOCK_LIST_BUTTON_LABEL,\n      IDS_SETTINGS_ACCESSIBILITY_PAGE_COLORS_BLOCK_LIST_BUTTON_SUBLABEL);\n}","pos":-1,"query":"Configure page color settings options","filepos":-1,"timecost":1823.1912000000011,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\floating_sso\\floating_sso_sync_bridge.cc:107-167","function":"FloatingSsoSyncBridge::ApplyIncrementalSyncChanges","codesnippet":"{\n  std::vector<net::CanonicalCookie> added_or_updated;\n  std::vector<net::CanonicalCookie> deleted;\n  std::unique_ptr<StoreWithCache::WriteBatch> batch =\n      store_->CreateWriteBatch();\n  for (const std::unique_ptr<syncer::EntityChange>& change : entity_changes) {\n    switch (change->type()) {\n      case syncer::EntityChange::ACTION_ADD:\n      case syncer::EntityChange::ACTION_UPDATE: {\n        const sync_pb::CookieSpecifics& specifics =\n            change->data().specifics.cookie();\n        // We save `specifics` locally only when we don't fail to convert it to\n        // a `cookie` here. Alternatively we could still store `specifics` in\n        // the store and then try to create a cookie again in case of a Chrome\n        // update. We don't do this because: (1) in the targeted enterprise\n        // use case we expect affected devices to be on the same Chrome version\n        // and (2) the disparity between client-side and server-side states will\n        // not last long due to short TTL for cookies in Sync.\n        if (std::unique_ptr<net::CanonicalCookie> cookie =\n                FromSyncProto(specifics);\n            cookie) {\n          added_or_updated.push_back(*cookie);\n          batch->WriteData(change->storage_key(), specifics);\n        }\n        break;\n      }\n      case syncer::EntityChange::ACTION_DELETE: {\n        const CookieSpecificsEntries& in_memory_data = store_->in_memory_data();\n        auto it = in_memory_data.find(change->storage_key());\n        if (it == in_memory_data.end()) {\n          // Nothing to delete in the local store.\n          break;\n        }\n        batch->DeleteData(change->storage_key());\n        if (std::unique_ptr<net::CanonicalCookie> cookie =\n                FromSyncProto(it->second);\n            cookie) {\n          deleted.push_back(*cookie);\n        }\n        break;\n      }\n    }\n  }\n\n  batch->TakeMetadataChangesFrom(std::move(metadata_change_list));\n  CommitToStore(std::move(batch));\n\n  for (Observer& observer : observers_) {\n    // No need to notify about empty lists of changes.\n    if (!added_or_updated.empty()) {\n      observer.OnCookiesAddedOrUpdatedRemotely(added_or_updated);\n    }\n    if (!deleted.empty()) {\n      observer.OnCookiesRemovedRemotely(deleted);\n    }\n  }\n\n  return {};\n}","pos":-1,"query":"Synchronizes cookie changes with storage and observers.","filepos":-1,"timecost":946.0746000000217,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\declarative_content\\chrome_content_rules_registry.cc:374-406","function":"ChromeContentRulesRegistry::EvaluateConditionsForTab","codesnippet":"{\n  std::set<raw_ptr<const ContentRule, SetExperimental>> matching_rules =\n      GetMatchingRules(tab);\n  if (matching_rules.empty() && !base::Contains(active_rules_, tab))\n    return;\n\n  std::set<raw_ptr<const ContentRule, SetExperimental>>& prev_matching_rules =\n      active_rules_[tab];\n  for (const ContentRule* rule : matching_rules) {\n    ContentAction::ApplyInfo apply_info =\n        {rule->extension, browser_context(), tab, rule->priority};\n    if (!base::Contains(prev_matching_rules, rule)) {\n      for (const std::unique_ptr<const ContentAction>& action : rule->actions)\n        action->Apply(apply_info);\n    } else {\n      for (const std::unique_ptr<const ContentAction>& action : rule->actions)\n        action->Reapply(apply_info);\n    }\n  }\n  for (const ContentRule* rule : prev_matching_rules) {\n    if (!base::Contains(matching_rules, rule)) {\n      ContentAction::ApplyInfo apply_info =\n          {rule->extension, browser_context(), tab, rule->priority};\n      for (const std::unique_ptr<const ContentAction>& action : rule->actions)\n        action->Revert(apply_info);\n    }\n  }\n\n  if (matching_rules.empty())\n    active_rules_[tab].clear();\n  else\n    swap(matching_rules, prev_matching_rules);\n}","pos":-1,"query":"manageContentRulesForTab","filepos":-1,"timecost":1334.1433000000252,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_taskbar_x\\frame\\subclass_helper_win.cc:430-477","function":"SubclassHelperWin::GetStickDirection","codesnippet":"{\n  if (IsWindowIntersectingMultipleDisplays(hwnd_)) {\n    return kStickDirectionNone;\n  }\n\n  HMONITOR monitor = MonitorFromWindow(hwnd_, MONITOR_DEFAULTTONEAREST);\n  MONITORINFO monitor_info;\n  monitor_info.cbSize = sizeof(monitor_info);\n  GetMonitorInfoW(monitor, &monitor_info);\n\n  RECT window_rect;\n  if (!widget_rect) {\n    GetWindowRect(hwnd_, &window_rect);\n  } else {\n    window_rect = widget_rect.value();\n  }\n\n  auto [top_offset, left_offset, bottom_offset, right_offset] =\n      GetOffsetBetweenViewAndWidget();\n  auto display_scale = GetDisplayScale();\n  window_rect.top = window_rect.top + top_offset * display_scale;\n  window_rect.left = window_rect.left + left_offset * display_scale;\n  window_rect.bottom = window_rect.bottom - bottom_offset * display_scale;\n  window_rect.right = window_rect.right - right_offset * display_scale;\n\n  auto current_display = display::Screen::GetScreen()->GetDisplayNearestWindow(\n      widget_->GetNativeWindow());\n  auto display_bounds = current_display.bounds();\n  auto [has_top, has_left, has_right] = HasAdjacentDisplay(current_display);\n  if (window_rect.top <= monitor_info.rcMonitor.top + distance_threshold &&\n      !has_top) {\n    animation_screen_edge_ = display_bounds.y();\n    return kStickDirectionTop;\n  } else if (window_rect.left <=\n                 monitor_info.rcMonitor.left + distance_threshold &&\n             !has_left) {\n    animation_screen_edge_ = display_bounds.x();\n    return kStickDirectionLeft;\n  } else if (window_rect.right >=\n                 monitor_info.rcMonitor.right - distance_threshold &&\n             !has_right) {\n    animation_screen_edge_ = display_bounds.right();\n    return kStickDirectionRight;\n  } else {\n    return kStickDirectionNone;\n  }\n}","pos":-1,"query":"Determine window stick direction on screen edges.","filepos":-1,"timecost":1155.099199999997,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_web_app_widgets\\web_app_widget_service_handler.cc:446-489","function":"WebAppWidgetServiceHandler::DispatchWidgetEvent","codesnippet":"{\n  if (!g_browser_process || g_browser_process->IsShuttingDown())\n    return;\n\n  std::optional<WidgetEventInfo> info =\n      GetWidgetEventInfo(base64url_event_info);\n\n  // Return early if parsing failed. Histograms for the failures are fired in\n  // GetWidgetEventInfo.\n  if (!info.has_value())\n    return std::move(completed_closure).Run(false);\n\n  web_app::WebAppProvider* web_app_provider =\n      web_app::WebAppProvider::GetForWebApps(profile);\n\n  auto* web_app = web_app_provider->registrar_unsafe().GetAppById(app_id);\n  if (!web_app) {\n    RecordWidgetEventResult(info->event_type,\n                            WebAppWidgetEventResult::kErrorNoMatchingApp);\n    return std::move(completed_closure).Run(false);\n  }\n\n  // Do not fire event if the widget does not successfully update.\n  bool success =\n      MaybeUpdateWebAppWidget(web_app_provider, app_id, info.value());\n  if (!success)\n    return std::move(completed_closure).Run(false);\n\n  auto widget = CreateWidget(web_app_provider, app_id, *info);\n  if (!widget) {\n    RecordWidgetEventResult(info->event_type,\n                            WebAppWidgetEventResult::kErrorNoMatchingWidget);\n    return std::move(completed_closure).Run(false);\n  }\n\n  if (info->event_type == WebAppWidgetEventType::kWidgetUninstall)\n    DeleteWidgetInstance(web_app_provider, app_id, info->instance_id);\n\n  DispatchWidgetEventInternal(profile, std::move(widget), web_app->scope(),\n                              app_id, *info, std::move(completed_closure));\n}","pos":-1,"query":"handleWebAppWidgetEvent","filepos":15,"timecost":1199.014599999995,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\crosapi\\document_scan_ash_type_converters.cc:193-259","function":"unknown","codesnippet":"{\n    auto output = crosapi::mojom::OptionConstraint::New();\n    output->type = ConvertTo<crosapi::mojom::OptionConstraintType>(\n        input.constraint_type());\n    // In the protobuf, constraints are represented as several different fields.\n    // In mojom, these are mapped to one union for a closer match to the JS API\n    // that consumes this.\n    //\n    // If the protobuf does not have the correct value field set to match its\n    // declared type, this will create an output with the same type and an empty\n    // constraint.  The empty constraint will always fail to match any value,\n    // but will be semantically correct.\n    switch (output->type) {\n      case crosapi::mojom::OptionConstraintType::kNone:\n        // No constraint value.\n        break;\n      case crosapi::mojom::OptionConstraintType::kIntRange:\n        if (!input.has_int_range()) {\n          LOG(WARNING) << \"OptionConstraint has type INT_RANGE but does not \"\n                          \"contain a valid int_range\";\n        }\n        output->restriction =\n            crosapi::mojom::OptionConstraintRestriction::NewIntRange(\n                crosapi::mojom::IntRange::From(input.int_range()));\n        break;\n      case crosapi::mojom::OptionConstraintType::kIntList:\n        if (input.valid_int().empty()) {\n          LOG(WARNING) << \"OptionConstraint has type INT_LIST but does not \"\n                          \"contain a valid valid_int\";\n        }\n        output->restriction =\n            crosapi::mojom::OptionConstraintRestriction::NewValidInt(\n                std::vector<int32_t>{input.valid_int().begin(),\n                                     input.valid_int().end()});\n        break;\n      case crosapi::mojom::OptionConstraintType::kFixedRange:\n        if (!input.has_fixed_range()) {\n          LOG(WARNING) << \"OptionConstraint has type FIXED_RANGE but does not \"\n                          \"contain a valid fixed_range\";\n        }\n        output->restriction =\n            crosapi::mojom::OptionConstraintRestriction::NewFixedRange(\n                crosapi::mojom::FixedRange::From(input.fixed_range()));\n        break;\n      case crosapi::mojom::OptionConstraintType::kFixedList:\n        if (input.valid_fixed().empty()) {\n          LOG(WARNING) << \"OptionConstraint has type FIXED_LIST but does not \"\n                          \"contain a valid valid_fixed\";\n        }\n        output->restriction =\n            crosapi::mojom::OptionConstraintRestriction::NewValidFixed(\n                std::vector<double>{input.valid_fixed().begin(),\n                                    input.valid_fixed().end()});\n        break;\n      case crosapi::mojom::OptionConstraintType::kStringList:\n        if (input.valid_string().empty()) {\n          LOG(WARNING) << \"OptionConstraint has type STRING_LIST but does not \"\n                          \"contain a valid valid_string\";\n        }\n        output->restriction =\n            crosapi::mojom::OptionConstraintRestriction::NewValidString(\n                std::vector<std::string>{input.valid_string().begin(),\n                                         input.valid_string().end()});\n        break;\n    }\n    return output;\n  }","pos":-1,"query":"convertProtobufToMojomOptionConstraint","filepos":-1,"timecost":1730.8942000000097,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\edge_copilot_private\\edge_copilot_private_api.cc:82-116","function":"EdgeCopilotPrivateNavigateToCopilotPageFunction::Run","codesnippet":"{\n  std::optional<api::edge_copilot_private::NavigateToCopilotPage::Params>\n      parameters =\n          api::edge_copilot_private::NavigateToCopilotPage::Params::Create(\n              args());\n  EXTENSION_FUNCTION_VALIDATE(parameters);\n\n  std::string page;\n  std::string form_code;\n  switch (parameters->page) {\n    case api::edge_copilot_private::CopilotPage::kDiscover:\n      page = kDiscoverPage;\n      form_code = kDiscoverPageFormCode;\n      break;\n    default:\n      NOTREACHED();\n  }\n\n  Browser* browser = GetBrowser(GetSenderWebContents());\n  if (!browser) {\n    return RespondNow(WithArguments(false));\n  }\n\n  if (!hub_utils::CanShowDiscover(browser)) {\n    return RespondNow(WithArguments(false));\n  }\n\n  if (!edge_underside_chat_v2::utils::IsUndersideChatV2Launch(browser)) {\n    return RespondNow(WithArguments(false));\n  }\n\n  edge_underside_chat_v2::utils::NavigateToCopilotPage(browser, page,\n                                                       form_code);\n  return RespondNow(WithArguments(true));\n}","pos":-1,"query":"Navigate to Copilot page if valid","filepos":-1,"timecost":1839.0237999999954,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\ash\\holding_space\\holding_space_keyed_service.cc:476-521","function":"HoldingSpaceKeyedService::InitializeDelegates","codesnippet":"{\n  // Bail out if delegates have already been initialized - delegates are\n  // shutdown on suspend, and re-initialized once suspend completes. If\n  // holding space keyed service starts observing suspend state after\n  // `SuspendImminent()` is sent out, original delegates may still be around.\n  if (!delegates_.empty()) {\n    return;\n  }\n\n  // The `HoldingSpaceDownloadsDelegate` monitors the status of downloads.\n  auto downloads_delegate = std::make_unique<HoldingSpaceDownloadsDelegate>(\n      this, &holding_space_model_);\n  downloads_delegate_ = downloads_delegate.get();\n  delegates_.push_back(std::move(downloads_delegate));\n\n  // The `HoldingSpaceFileSystemDelegate` monitors the file system for changes.\n  delegates_.push_back(std::make_unique<HoldingSpaceFileSystemDelegate>(\n      this, &holding_space_model_));\n\n  // The `HoldingSpaceMetricsDelegate` records metrics.\n  delegates_.push_back(std::make_unique<HoldingSpaceMetricsDelegate>(\n      this, &holding_space_model_));\n\n  // The `HoldingSpacePersistenceDelegate` manages holding space persistence.\n  delegates_.push_back(std::make_unique<HoldingSpacePersistenceDelegate>(\n      this, &holding_space_model_, &thumbnail_loader_,\n      /*persistence_restored_callback=*/\n      base::BindOnce(&HoldingSpaceKeyedService::OnPersistenceRestored,\n                     weak_factory_.GetWeakPtr())));\n\n  // The `HoldingSpaceSuggestionsDelegate` manages file suggestions (i.e. the\n  // files predicted to be used).\n  if (features::IsHoldingSpaceSuggestionsEnabled()) {\n    auto suggestions_delegate =\n        std::make_unique<HoldingSpaceSuggestionsDelegate>(\n            this, &holding_space_model_);\n    suggestions_delegate_ = suggestions_delegate.get();\n    delegates_.push_back(std::move(suggestions_delegate));\n  }\n\n  // Initialize all delegates only after they have been added to our collection.\n  // Delegates should not fire their respective callbacks during construction\n  // but once they have been initialized they are free to do so.\n  for (auto& delegate : delegates_) {\n    delegate->Init();\n  }\n}","pos":-1,"query":"initializeHoldingSpaceDelegates","filepos":-1,"timecost":1805.8395999999775,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\commands\\fetch_installability_for_chrome_management.cc:146-177","function":"FetchInstallabilityForChromeManagement::OnAppLockGranted","codesnippet":"{\n  CHECK(app_lock_);\n  CHECK(app_lock_->IsGranted());\n\n  if (IsWebContentsDestroyed()) {\n    GetMutableDebugValue().Set(\"web_contents_destroyed\", true);\n    CompleteAndSelfDestruct(CommandResult::kSuccess,\n                            InstallableCheckResult::kNotInstallable,\n                            std::nullopt);\n    return;\n  }\n  DCHECK(!app_id_.empty());\n\n  InstallableCheckResult result;\n  if (app_lock_->registrar().GetInstallState(app_id_) == std::nullopt) {\n    result = InstallableCheckResult::kInstallable;\n  } else {\n    switch (app_lock_->registrar().GetInstallState(app_id_).value()) {\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      case web_app::proto::EDGE_PACKAGED_APP_MAYBE_RESETTING:\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n      case web_app::proto::SUGGESTED_FROM_ANOTHER_DEVICE:\n        result = InstallableCheckResult::kInstallable;\n        break;\n      case web_app::proto::INSTALLED_WITH_OS_INTEGRATION:\n      case web_app::proto::INSTALLED_WITHOUT_OS_INTEGRATION:\n        result = InstallableCheckResult::kAlreadyInstalled;\n        break;\n    }\n  }\n\n  CompleteAndSelfDestruct(CommandResult::kSuccess, result, app_id_);\n}","pos":-1,"query":"Check app installability status","filepos":-1,"timecost":1283.7486000000208,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\win\\edge_search_indexer\\quick_links_indexer.cc:183-232","function":"QuickLinksIndexer::TryGetQuickLinks","codesnippet":"{\n  auto all_quick_links = instant_service_->GetMostVisitedItems();\n  const int all_quick_links_size = all_quick_links.size();\n  // record histogram with the number of initial quick links\n  base::UmaHistogramCounts100(kAddQuickLinksInitialCountHistogram,\n                              all_quick_links_size);\n\n  if (all_quick_links_size > 0) {\n    // Query the first item to make sure Unknown isn't returned. If so, it\n    // means means the module isn't loaded. Reschedule for the next idle time\n    // to give it time to load. This could happen repeatedly, which is fine.\n    const auto safe_result =\n        edge::well_known_domains::IsDomainSafe(all_quick_links.front().url);\n    if (edge::well_known_domains::IsDomainSafeResult::Unknown == safe_result) {\n      SetUpdateIndexOnNextIdle(true);\n      return false;\n    }\n\n    int filtered_out_count = 0;\n    const ukm::SourceId source_id = ukm::ConvertToSourceId(\n        ukm::AssignNewSourceId(), ukm::SourceIdType::HISTORY_ID);\n\n    filtered_out_count = std::erase_if(\n        all_quick_links,\n        [this, source_id](const InstantMostVisitedItem& current_link) {\n          bool is_unsafe =\n              edge::well_known_domains::IsDomainSafeResult::Unsafe ==\n              edge::well_known_domains::IsDomainSafe(current_link.url);\n          if (is_unsafe) {\n            this->PostTaskToRecordUnsafeDomain(source_id, current_link.url);\n          }\n          return is_unsafe;\n        });\n\n    base::UmaHistogramCounts100(kQuickLinksFilteredCountHistogram,\n                                filtered_out_count);\n    base::UmaHistogramCounts100(\n        kQuickLinksFilteredPercentageHistogram,\n        ((all_quick_links_size - filtered_out_count) * 100) /\n            all_quick_links_size);\n    base::UmaHistogramBoolean(kQuickLinksDidFilterAllLinksHistogram,\n                              filtered_out_count == all_quick_links_size);\n  }\n\n  if (all_quick_links.size() > kMaxQuickLinksInIndex) {\n    all_quick_links.resize(kMaxQuickLinksInIndex);\n  }\n\n  output_list = std::move(all_quick_links);\n  return true;\n}","pos":-1,"query":"filterAndRecordQuickLinksSafety","filepos":81,"timecost":1248.3177999999898,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_lightning\\lightning_client.cc:283-390","function":"LightningClient::OnGetPageConfigInfoCompleted","codesnippet":"{\n  auto* response_info = simple_url_loader_->ResponseInfo();\n  if (response_info) {\n    int response_code = response_info->headers->response_code();\n    base::UmaHistogramSparse(kLightningPageConfigResponseHistogram,\n                             response_code);\n    auto duration = base::Time::Now() - initialize_time;\n    base::UmaHistogramTimes(kLightningPageConfigApiTimeHistogram, duration);\n    DVLOG(1) << \"FRE lightning Falcon API1 service response code \"\n             << response_code;\n    std::optional<std::string> ref_header =\n        response_info->headers->GetNormalizedHeader(kFalconRefHeaderName);\n    DVLOG(1) << \"FRE lightning Falcon API1 \" << ref_header.value_or(\"\");\n  }\n\n  if (!response) {\n    DVLOG(1) << \"FRE lightning Falcon API1 null response received\";\n    std::move(callback).Run(/*should_import_takeout=*/false,\n                            /*should_import_password=*/false,\n                            /*is_failure=*/true);\n    return;\n  }\n\n  JSONStringValueDeserializer serializer(*(response.release()));\n  int error_code = base::ValueDeserializer::kErrorCodeNoError;\n  std::string message;\n  std::unique_ptr<base::Value> deserialized_response =\n      serializer.Deserialize(&error_code, &message);\n\n  if (error_code == base::ValueDeserializer::kErrorCodeNoError &&\n      deserialized_response && deserialized_response->is_dict()) {\n    auto& json_dict = deserialized_response->GetDict();\n\n    std::optional<bool> should_import_takeout_value =\n        json_dict.FindBool(\"shouldImport\");\n    bool should_import_takeout = should_import_takeout_value.has_value()\n                                     ? should_import_takeout_value.value()\n                                     : false;\n\n    std::optional<bool> should_import_password_value =\n        json_dict.FindBool(\"importPassword\");\n    bool should_import_password = should_import_password_value.has_value()\n                                      ? should_import_password_value.value()\n                                      : false;\n\n    if (base::FeatureList::IsEnabled(\n            features::kEdgeSunflowerBypassTriggerConditions)) {\n      should_import_takeout = true;\n      should_import_password = true;\n    }\n\n    if (should_import_takeout || should_import_password) {\n      if (uia_remote_script_enabled_) {\n        std::string* script = json_dict.FindString(kUiAScriptKey);\n        std::string* initial_url = json_dict.FindString(kUiAInitialUrlKey);\n        auto* challenge_urls = json_dict.FindList(kUiAChallengeUrlsKey);\n        std::string* password_export_url =\n            json_dict.FindString(kUiAPasswordExportUrlKey);\n        std::string* password_challenge_url =\n            json_dict.FindString(kUiAPasswordChallengUrlKey);\n        std::optional<int> timeout = json_dict.FindInt(kUiATimeoutKey);\n\n        if (script && initial_url && challenge_urls && password_export_url &&\n            password_challenge_url && timeout.has_value()) {\n          uia_valid_ = true;\n          uia_script_ = *script;\n          uia_initial_url_ = *initial_url;\n          uia_password_export_url_ = *password_export_url;\n          uia_password_challenge_url_ = *password_challenge_url;\n          uia_timeout_ = *timeout;\n\n          for (auto& url : *challenge_urls) {\n            if (!url.is_string()) {\n              continue;\n            }\n            uia_challenge_urls_.push_back(url.GetString());\n          }\n        } else {\n          should_import_takeout = false;\n          should_import_password = false;\n        }\n      } else {\n        uia_valid_ = true;\n        uia_timeout_ = 600;\n        uia_initial_url_ = \"https://takeout.google.com/\";\n        uia_password_export_url_ = \"https://passwords.google.com/options\";\n        uia_password_challenge_url_ =\n            \"https://accounts.google.com/signin/v2/challenge/pwd\";\n        uia_challenge_urls_.push_back(\n            \"https://accounts.google.com/signin/v2/challenge/\");\n\n        uia_script_ =\n            ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(\n                IDR_LIGHTNING_UIA_JS);\n      }\n    }\n\n    std::move(callback).Run(should_import_takeout, should_import_password,\n                            /*is_failure=*/false);\n  } else {\n    DVLOG(1) << \"FRE lightning Falcon API1 response deserialize failure\";\n    std::move(callback).Run(/*should_import_takeout=*/false,\n                            /*should_import_password=*/false,\n                            /*is_failure=*/true);\n  }\n}","pos":-1,"query":"ProcessAPIResponseAndExecuteCallback","filepos":-1,"timecost":972.097299999994,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\safe_browsing\\generated_safe_browsing_pref.cc:39-83","function":"GeneratedSafeBrowsingPref::SetPref","codesnippet":"{\n  if (!value->is_int())\n    return extensions::settings_private::SetPrefResult::PREF_TYPE_MISMATCH;\n\n  auto selection = static_cast<SafeBrowsingSetting>(value->GetInt());\n\n  if (selection != SafeBrowsingSetting::DISABLED &&\n      selection != SafeBrowsingSetting::STANDARD &&\n      selection != SafeBrowsingSetting::ENHANCED)\n    return extensions::settings_private::SetPrefResult::PREF_TYPE_MISMATCH;\n\n  // If SBER is forcefully disabled, Enhanced cannot be selected by the user.\n  const PrefService::Preference* reporting_pref =\n      profile_->GetPrefs()->FindPreference(\n          prefs::kSafeBrowsingScoutReportingEnabled);\n  const bool reporting_on = reporting_pref->GetValue()->GetBool();\n  const bool reporting_enforced = !reporting_pref->IsUserModifiable();\n\n  if (reporting_enforced && !reporting_on &&\n      selection == SafeBrowsingSetting::ENHANCED) {\n    return extensions::settings_private::SetPrefResult::PREF_NOT_MODIFIABLE;\n  }\n\n  // kSafeBrowsingEnabled is considered the canonical source for Safe Browsing\n  // management.\n  const PrefService::Preference* enabled_pref =\n      profile_->GetPrefs()->FindPreference(prefs::kSafeBrowsingEnabled);\n  if (!enabled_pref->IsUserModifiable()) {\n    return extensions::settings_private::SetPrefResult::PREF_NOT_MODIFIABLE;\n  }\n\n  // Update both Safe Browsing preferences to match selection.\n  profile_->GetPrefs()->SetBoolean(prefs::kSafeBrowsingEnabled,\n                                   selection != SafeBrowsingSetting::DISABLED);\n  profile_->GetPrefs()->SetBoolean(prefs::kSafeBrowsingEnhanced,\n                                   selection == SafeBrowsingSetting::ENHANCED);\n\n  // Set ESB not set in sync with Account ESB through TailoredSecurity.\n  if (selection == SafeBrowsingSetting::ENHANCED) {\n    profile_->GetPrefs()->SetBoolean(\n        prefs::kEnhancedProtectionEnabledViaTailoredSecurity, false);\n  }\n\n  return extensions::settings_private::SetPrefResult::SUCCESS;\n}","pos":-1,"query":"validateAndSetSafeBrowsingPreference","filepos":-1,"timecost":997.3383000000031,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\push_notification\\server_client\\push_notification_desktop_api_call_flow.cc:36-70","function":"unknown","codesnippet":"{\n  switch (error) {\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kOffline:\n      stream << \"[offline]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kEndpointNotFound:\n      stream << \"[endpoint not found]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kAuthenticationError:\n      stream << \"[authentication error]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kBadRequest:\n      stream << \"[bad request]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kResponseMalformed:\n      stream << \"[response malformed]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kInternalServerError:\n      stream << \"[internal server error]\";\n      break;\n    case PushNotificationDesktopApiCallFlow::PushNotificationApiCallFlowError::\n        kUnknown:\n      stream << \"[unknown]\";\n      break;\n  }\n  return stream;\n}","pos":-1,"query":"FormatPushNotificationErrorMessage","filepos":-1,"timecost":1731.1087000000116,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_collected_cookies_dialog\\edge_collected_cookies_dialog_handler.cc:174-206","function":"EdgeCollectedCookiesDialogHandler::HandleRemoveSite","codesnippet":"{\n  CHECK_EQ(2U, args.size());\n  CHECK(request_.callback_id_.empty());\n\n  AllowJavascript();\n\n  if (!GetContentSettings()) {\n    request_.callback_id_ = args[0].GetString();\n    RejectJavascriptCallback(base::Value(request_.callback_id_), base::Value());\n    request_.Clear();\n    return;\n  }\n\n  const std::string site_name = args[1].GetString();\n  auto origin = url::Origin::Create(GURL(site_name));\n\n  if (origin.GetURL().SchemeIsHTTPOrHTTPS()) {\n    allowed_browsing_data_model()->RemoveUnpartitionedBrowsingData(\n        origin.host(), base::DoNothing());\n    blocked_browsing_data_model()->RemoveUnpartitionedBrowsingData(\n        origin.host(), base::DoNothing());\n  } else {\n    allowed_browsing_data_model()->RemoveUnpartitionedBrowsingData(\n        origin, base::DoNothing());\n    blocked_browsing_data_model()->RemoveUnpartitionedBrowsingData(\n        origin, base::DoNothing());\n  }\n\n  request_.callback_id_ = args[0].GetString();\n\n  ResolveJavascriptCallback(base::Value(request_.callback_id_), base::Value());\n  request_.Clear();\n}","pos":-1,"query":"clearBrowsingDataForOrigin","filepos":-1,"timecost":1140.1172000000079,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\permissions\\permission_prompt_bubble_one_origin_view.cc:262-305","function":"PermissionPromptBubbleOneOriginView::MaybeAddMediaPreview","codesnippet":"{\n#if !BUILDFLAG(IS_CHROMEOS)\n  // Unit tests call this without initializing `browser_`, but this should not\n  // happen in production code.\n  if (!browser()) {\n    return;\n  }\n\n  if (requested_audio_capture_device_ids.empty() &&\n      requested_video_capture_device_ids.empty()) {\n    return;\n  }\n\n  if (!camera_permission_label_ && !mic_permission_label_ &&\n      !ptz_camera_permission_label_) {\n    return;\n  }\n\n  // Check this last, as it queries the origin trials service.\n  if (!media_preview_feature::ShouldShowMediaPreview(\n          *browser()->profile(), delegate()->GetRequestingOrigin(),\n          delegate()->GetEmbeddingOrigin(),\n          media_preview_metrics::UiLocation::kPermissionPrompt)) {\n    return;\n  }\n\n  auto* cached_device_info = media_effects::MediaDeviceInfo::GetInstance();\n  devices_observer_.Observe(cached_device_info);\n  if (camera_permission_label_ || ptz_camera_permission_label_) {\n    // Initialize camera label with the current number of cached video devices.\n    OnVideoDevicesChanged(cached_device_info->GetVideoDeviceInfos());\n  }\n  if (mic_permission_label_) {\n    // Initialize mic label with the current number of cached audio devices.\n    OnAudioDevicesChanged(cached_device_info->GetAudioDeviceInfos());\n  }\n\n  media_previews_.emplace(browser(), this, index,\n                          requested_audio_capture_device_ids,\n                          requested_video_capture_device_ids, delegate());\n#endif\n}","pos":-1,"query":"initializeMediaPreviewPermissions","filepos":297,"timecost":960.5203000000038,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\lobster\\lobster_image_provider_from_snapper.cc:314-351","function":"LobsterImageProviderFromSnapper::OnImagesSanitized","codesnippet":"{\n  std::vector<ash::LobsterImageCandidate> image_candidates;\n\n  for (auto& candidate : sanitized_image_candidates) {\n    if (candidate.has_value()) {\n      image_candidates.push_back(candidate.value());\n    }\n  }\n\n  if (!image_candidates.empty()) {\n    std::move(callback).Run(std::move(image_candidates));\n    return;\n  }\n\n  // If there is no valid image, returns errors based on the filtered reasons.\n  for (auto& filtered_datum : filtered_data) {\n    if (filtered_datum.additional_reasons_size() > 0) {\n      if (std::find(filtered_datum.additional_reasons().begin(),\n                    filtered_datum.additional_reasons().end(),\n                    manta::proto::FilteredReason::IMAGE_SAFETY_PERSON) !=\n          filtered_datum.additional_reasons().end()) {\n        std::move(callback).Run(base::unexpected(ash::LobsterError(\n            /*status_code=*/ash::LobsterErrorCode::kContainsPeople,\n            /*message=*/GetErrorMessage(\n                ash::LobsterErrorCode::kContainsPeople))));\n        return;\n      }\n    }\n  }\n  // All the images were filtered out due to our safety filters.\n  std::move(callback).Run(base::unexpected(ash::LobsterError(\n      /*status_code=*/ash::LobsterErrorCode::kBlockedOutputs,\n      GetErrorMessage(ash::LobsterErrorCode::kBlockedOutputs))));\n}","pos":-1,"query":"filterAndProcessImageCandidates","filepos":23,"timecost":1459.6847000000125,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_family_safety\\family_safety_url.cc:145-194","function":"FamilySafetyUrl::PopulateMembers","codesnippet":"{\n  valid_ = url.is_valid();\n\n  if (!valid_ || !url.has_host()) {\n    valid_ = false;\n    return;\n  }\n  scheme_ = url.scheme();\n\n  // Don't include private domains. Excluding eTLD blocking is done to prevent\n  // possible misconfigurations that are not supported by the Family backend and\n  // could possibly leave client in an unusable state.\n  domain_and_registry_ = net::registry_controlled_domains::GetDomainAndRegistry(\n      url, net::registry_controlled_domains::PrivateRegistryFilter::\n               EXCLUDE_PRIVATE_REGISTRIES);\n  if (domain_and_registry_.empty()) {\n    if (!(scheme_ == content::kChromeUIScheme)) {\n      valid_ = false;\n      return;\n    }\n  }\n\n  const std::vector<std::string> domain_and_registry_parts =\n      base::SplitString(domain_and_registry_, \".\", base::TRIM_WHITESPACE,\n                        base::SPLIT_WANT_NONEMPTY);\n  if (scheme_ == content::kChromeUIScheme) {\n    domain_and_registry_ = url.host();\n  } else {\n    std::vector<std::string> domains = base::SplitString(\n        url.host(), \".\", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n\n    const size_t domain_and_etld_size = domain_and_registry_parts.size();\n\n    DCHECK(domains.size() >= domain_and_etld_size);\n\n    // Remove eTLD+1 from |domains|.\n    for (size_t i = 0; i < domain_and_etld_size; ++i)\n      domains.pop_back();\n\n    subdomains_ = domains;\n  }\n\n  if (url.has_path()) {\n    path_components_ = base::SplitString(url.path(), \"/\", base::TRIM_WHITESPACE,\n                                         base::SPLIT_WANT_NONEMPTY);\n  }\n\n  if (url.has_query()) {\n    query_ = url.query();\n  }\n}","pos":-1,"query":"validateAndExtractUrlComponents","filepos":-1,"timecost":875.6051999999909,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\extension_action\\extension_action_api.cc:221-265","function":"ExtensionActionFunction::ExtractDataFromArguments","codesnippet":"{\n  // There may or may not be details (depends on the function).\n  // The tabId might appear in details (if it exists), as the first\n  // argument besides the action type (depends on the function), or be omitted\n  // entirely.\n  if (args().empty())\n    return true;\n\n  base::Value& first_arg = mutable_args()[0];\n\n  switch (first_arg.type()) {\n    case base::Value::Type::INTEGER:\n      tab_id_ = first_arg.GetInt();\n      break;\n\n    case base::Value::Type::DICT: {\n      // Found the details argument.\n      details_ = &first_arg.GetDict();\n      // Still need to check for the tabId within details.\n      if (base::Value* tab_id_value = details_->Find(\"tabId\")) {\n        switch (tab_id_value->type()) {\n          case base::Value::Type::NONE:\n            // OK; tabId is optional, leave it default.\n            return true;\n          case base::Value::Type::INTEGER:\n            tab_id_ = tab_id_value->GetInt();\n            return true;\n          default:\n            // Boom.\n            return false;\n        }\n      }\n      // Not found; tabId is optional, leave it default.\n      break;\n    }\n\n    case base::Value::Type::NONE:\n      // The tabId might be an optional argument.\n      break;\n\n    default:\n      return false;\n  }\n\n  return true;\n}","pos":-1,"query":"Validate and extract tabId from arguments","filepos":-1,"timecost":1162.5129999999772,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_management\\management_ui_handler.cc:140-172","function":"EdgeManagementUIHandler::GetContextualManagedDataHelper","codesnippet":"{\n  auto response = mojom::ManagedDataResponse::New();\n  response->browserManagementNotice =\n      l10n_util::GetStringUTF8(managed_() ? IDS_MANAGEMENT_BROWSER_NOTICE\n                                          : IDS_MANAGEMENT_NOT_MANAGED_NOTICE);\n\n  std::string enterprise_manager = GetAccountManager(profile);\n\n  if (enterprise_manager.empty()) {\n    response->extensionReportingTitle =\n        l10n_util::GetStringUTF8(IDS_MANAGEMENT_EXTENSIONS_INSTALLED);\n\n    response->pageSubtitle =\n        managed_()\n            ? l10n_util::GetStringUTF8(\n                  IDS_EDGE_MANAGEMENT_SUBTITLE_MANAGED_BY_ORG)\n            : l10n_util::GetStringUTF8(IDS_MANAGEMENT_NOT_MANAGED_SUBTITLE);\n\n  } else {\n    response->extensionReportingTitle =\n        (l10n_util::GetStringUTF8(IDS_MANAGEMENT_EXTENSIONS_INSTALLED));\n\n    response->pageSubtitle =\n        managed_()\n            // Bug 22078717: Don't display domain info\n            ? l10n_util::GetStringUTF8(\n                  IDS_EDGE_MANAGEMENT_SUBTITLE_MANAGED_BY_ORG)\n            : l10n_util::GetStringUTF8(IDS_MANAGEMENT_NOT_MANAGED_SUBTITLE);\n  }\n  response->managed = managed_();\n\n  return response;\n}","pos":-1,"query":"createManagedDataResponse","filepos":-1,"timecost":970.1005000000005,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\ash\\network\\network_portal_notification_controller.cc:141-182","function":"NetworkPortalNotificationController::PortalStateChanged","codesnippet":"{\n  if (!network || !IsPortalState(portal_state)) {\n    if (!last_network_guid_.empty() && IsPortalState(last_portal_state_)) {\n      NET_LOG(EVENT) << \"Captive Portal notification: Close for \"\n                     << last_network_guid_;\n    }\n    last_network_guid_.clear();\n    last_portal_state_ = portal_state;\n\n    // In browser tests we initiate fake network portal detection, but network\n    // state usually stays connected. This way, after dialog is shown, it is\n    // immediately closed. The testing check below prevents dialog from closing.\n    if (!ignore_no_network_for_testing_ ||\n        portal_state == NetworkState::PortalState::kOnline) {\n      NetworkPortalSigninController::Get()->CloseSignin();\n    }\n\n    CloseNotification();\n    return;\n  }\n\n  // Don't do anything if notification for |network| already was\n  // displayed with the same portal_state.\n  if (network->guid() == last_network_guid_ &&\n      portal_state == last_portal_state_) {\n    return;\n  }\n  last_network_guid_ = network->guid();\n  last_portal_state_ = portal_state;\n\n  NET_LOG(EVENT) << \"Captive Portal notification: Show for \"\n                 << NetworkId(network) << \" PortalState: \" << portal_state;\n  base::UmaHistogramEnumeration(\"Network.NetworkPortalNotificationState\",\n                                portal_state);\n\n  std::unique_ptr<message_center::Notification> notification =\n      CreateDefaultCaptivePortalNotification(network, portal_state);\n  DCHECK(notification) << \"Notification not created for portal state: \"\n                       << portal_state;\n  SystemNotificationHelper::GetInstance()->Display(*notification);\n}","pos":-1,"query":"HandleCaptivePortalNotification","filepos":26,"timecost":1139.468200000003,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\system\\page_data_provider_system.cc:39-171","function":"SystemPageDataProvider::SetSections","codesnippet":"{\n  auto* section = CreateSection(cached_page_ptr_.get());\n  auto* header = CreateHeaderInSection(section);\n  RegisterSearchableString(section, &(header->title), IDS_SETTINGS_SYSTEM,\n                           nullptr /* row */);\n\n  auto parent_info = std::vector<std::pair<mojom::SettingsPageIds, int>>{\n      {mojom::SettingsPageIds::SystemPerformance,\n       IDS_SETTINGS_PERFORMANCE_SYSTEM}};\n  CreateParentInfoInHeader(header, parent_info);\n\n  // Section Pointers\n  mojom::Row* rowPtr = nullptr;\n\n  // Row -- Startup boost\n#if BUILDFLAG(IS_WIN)\n  if (!edge::StartupBoostManager::IsDisabled()) {\n    rowPtr = CreateToggleRowInSection(\n        section, mojom::FormControlIds::StartupBoostEnabled);\n    RegisterSearchableString(section, &(rowPtr->title),\n                             IDS_SETTINGS_SYSTEM_STARTUP_BOOST_LABEL, rowPtr);\n    // For deep linking and elevated settings.\n    rowPtr->positionKey = \"StartupBoost\";\n\n    BuildDescriptionWithLink(\n        section, rowPtr,\n        GetResourceString(IDS_SETTINGS_SYSTEM_STARTUP_BOOST_DESCRIPTION_V2),\n        {GetResourceString(IDS_LEARN_MORE)},\n        {std::string(chrome::kStartupBoostLearnMoreURL)});\n\n    PrefObserve(prefs::kStartupBoostEnabled,\n                base::BindRepeating(\n                    &UpdateRow, rowPtr,\n                    std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n  }\n#endif\n\n// Row -- Background extensions\n#if BUILDFLAG(IS_WIN)\n  if (!is_xbox_sku_) {\n    rowPtr = CreateToggleRowInSection(\n        section, mojom::FormControlIds::BackgroundModeEnabled);\n    RegisterSearchableString(section, &(rowPtr->title),\n                             IDS_SETTINGS_SYSTEM_BACKGROUND_APPS_LABEL_V2,\n                             rowPtr);\n    // For deep linking and elevated settings.\n    rowPtr->positionKey = \"BackgroundMode\";\n    PrefObserve(prefs::kBackgroundModeEnabled,\n                base::BindRepeating(\n                    &UpdateRow, rowPtr,\n                    std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n  }\n#endif\n\n  // Row -- is_xbox_sku TvSafeAreaSettings\n  if (is_xbox_sku_) {\n    rowPtr = CreateActionButtonRowInSection(\n        section, mojom::FormControlIds::TvSafeAreaSettings,\n        IDS_SETTINGS_SYSTEM_TV_SAFE_AREA_SETTINGS_LABEL,\n        IDS_SETTINGS_SYSTEM_TV_SAFE_AREA_SETTINGS_LABEL);\n    RegisterSearchableString(section, &(rowPtr->title), rowPtr);\n    RegisterSearchableString(\n        section, &(rowPtr->description),\n        IDS_SETTINGS_SYSTEM_TV_SAFE_AREA_SETTINGS_DESCRIPTION, rowPtr);\n  }\n\n  // Row -- Graphic acceleration\n  rowPtr = CreateToggleRowInSection(\n      section, mojom::FormControlIds::HardwareAcceleration);\n  RegisterSearchableString(section, &(rowPtr->title),\n                           IDS_SETTINGS_SYSTEM_HARDWARE_ACCELERATION_LABEL,\n                           rowPtr);\n  // For deep linking and elevated settings.\n  rowPtr->positionKey = \"GraphicsAcceleration\";\n  PrefObserve(prefs::kHardwareAccelerationModeEnabled,\n              base::BindRepeating(\n                  &UpdateRow, rowPtr,\n                  std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n\n  // Section Row -- Enhance videos\n#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)\n  if (IsVideoEnhancementUiEnabled()) {\n    rowPtr = CreateToggleRowInSection(\n        section, mojom::FormControlIds::VideoEnhancementUIEnabled);\n    rowPtr->helpInfo = CreateHelpInfo(\n        IDS_SETTINGS_SYSTEM_VIDEO_ENHANCEMENT_LABEL_V2,\n        std::vector<std::pair<int, std::string>>{\n            {IDS_SETTINGS_SYSTEM_VIDEO_ENHANCEMENT_TOOLTIP_BODY, \"\"}},\n        IDS_SETTINGS_LEARN_MORE_DEFAULT_CONFIRM_TEXT);\n\n    if (IsMicroFeedbackEnabled()) {\n      std::vector<int> feedback_prompts_dislike = {\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_NO_DIFFERENCE,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_CHOPPY,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_LOST_DETAILS,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_ORIGINAL_VIDEO,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_UNRESPONSIVE,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_NOISE};\n\n      CreateFeedbackInfoInRow(\n          rowPtr, \"641ca60f-5c5f-440a-812f-938ce045fcad\", 0,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_PROMPT,\n          std::nullopt, std::nullopt,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_PROMPT,\n          feedback_prompts_dislike,\n          IDS_SETTINGS_EDGE_VIDEO_ENHANCEMENT_MICROFEEDBACK_DISLIKE_OTHER,\n          chrome::microsoft_edge::FeedbackSource::\n              kFeedbackEdgeVideoEnhancementMFB);\n    }\n\n    RegisterSearchableString(section, &(rowPtr->title),\n                             IDS_SETTINGS_SYSTEM_VIDEO_ENHANCEMENT_LABEL_V2,\n                             rowPtr);\n    RegisterSearchableString(\n        section, &(rowPtr->description),\n        IDS_SETTINGS_SYSTEM_VIDEO_ENHANCEMENT_DESCRIPTION_V2, rowPtr);\n    PrefObserve(prefs::kVideoEnhancementEnabled,\n                base::BindRepeating(\n                    &UpdateRow, rowPtr,\n                    std::vector<RowPropertyID>{RowPropertyID::SELECTED_VALUE}));\n  }\n#endif\n\n  // Row -- Open proxy settings.\n  if (ShouldRenderProxySettingsRow(is_win10_)) {\n    rowPtr = CreateActionButtonRowInSection(\n        section, mojom::FormControlIds::ProxySettings);\n    RegisterSearchableString(section, &(rowPtr->title),\n                             IDS_SETTINGS_SYSTEM_PROXY_SETTINGS_LABEL_V2,\n                             rowPtr);\n    // For deep linking and elevated settings.\n    rowPtr->positionKey = \"ProxySettings\";\n  }\n}","pos":-1,"query":"Configure system settings UI sections","filepos":-1,"timecost":1458.6473000000115,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\android\\tab_web_contents_delegate_android.cc:289-344","function":"unknown","codesnippet":"{\n  WindowOpenDisposition disposition = params.disposition;\n  if (!source || (disposition != WindowOpenDisposition::CURRENT_TAB &&\n                  disposition != WindowOpenDisposition::NEW_FOREGROUND_TAB &&\n                  disposition != WindowOpenDisposition::NEW_BACKGROUND_TAB &&\n                  disposition != WindowOpenDisposition::OFF_THE_RECORD &&\n                  disposition != WindowOpenDisposition::NEW_POPUP &&\n                  disposition != WindowOpenDisposition::NEW_WINDOW)) {\n    // We can't handle this here.  Give the parent a chance.\n    return WebContentsDelegateAndroid::OpenURLFromTab(\n        source, params, std::move(navigation_handle_callback));\n  }\n\n  if (base::FeatureList::IsEnabled(\n          external_intents::kNavigationCaptureRefactorAndroid)) {\n    if (IsCustomTab() &&\n        disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {\n      if (OpenInAppOrChromeFromCct(params.url)) {\n        // Navigation handled, stop here. Otherwise proceed normally.\n        return nullptr;\n      }\n    }\n  }\n\n  Profile* profile = Profile::FromBrowserContext(source->GetBrowserContext());\n  NavigateParams nav_params(profile, params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.source_contents = source;\n  nav_params.window_action = NavigateParams::SHOW_WINDOW;\n  auto popup_delegate =\n      std::make_unique<ChromePopupNavigationDelegate>(std::move(nav_params));\n  if (blocked_content::ConsiderForPopupBlocking(params.disposition)) {\n    popup_delegate.reset(static_cast<ChromePopupNavigationDelegate*>(\n        blocked_content::MaybeBlockPopup(\n            source, nullptr, std::move(popup_delegate), &params,\n            blink::mojom::WindowFeatures(),\n            HostContentSettingsMapFactory::GetForProfile(\n                source->GetBrowserContext()))\n            .release()));\n    if (!popup_delegate)\n      return nullptr;\n  }\n\n  if (disposition == WindowOpenDisposition::CURRENT_TAB) {\n    // Ask the parent to handle in-place opening.\n    return WebContentsDelegateAndroid::OpenURLFromTab(\n        source, params, std::move(navigation_handle_callback));\n  }\n\n  popup_delegate->nav_params()->opened_by_another_window = true;\n  TabModelList::HandlePopupNavigation(popup_delegate->nav_params());\n  return nullptr;\n}","pos":-1,"query":"Handle URL navigation and popup blocking","filepos":-1,"timecost":1038.4367000000202,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\screen_ai\\screen_ai_service_handler.cc:362-397","function":"ScreenAIServiceHandler::InitializeServiceIfNeeded","codesnippet":"{\n  std::optional<bool> service_state = GetServiceState();\n  if (service_state) {\n    // Either service is already initialized or disabled.\n    CallPendingStatusRequests(*service_state);\n    return;\n  }\n\n  base::TimeTicks request_start_time = base::TimeTicks::Now();\n  LaunchIfNotRunning();\n\n  if (!screen_ai_service_factory_.is_bound()) {\n    SetLibraryLoadState(request_start_time, false);\n    return;\n  }\n\n  if (is_ocr_) {\n    base::ThreadPool::PostTaskAndReplyWithResult(\n        FROM_HERE,\n        {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},\n        base::BindOnce(&ComponentFiles::Load, kOcrFilesList),\n        base::BindOnce(&ScreenAIServiceHandler::InitializeOCR,\n                       weak_ptr_factory_.GetWeakPtr(), request_start_time,\n                       ocr_service_.BindNewPipeAndPassReceiver()));\n    ocr_service_.reset_on_disconnect();\n  } else {\n    base::ThreadPool::PostTaskAndReplyWithResult(\n        FROM_HERE,\n        {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},\n        base::BindOnce(&ComponentFiles::Load, kMainContentExtractionFilesList),\n        base::BindOnce(\n            &ScreenAIServiceHandler::InitializeMainContentExtraction,\n            weak_ptr_factory_.GetWeakPtr(), request_start_time,\n            main_content_extraction_service_.BindNewPipeAndPassReceiver()));\n    main_content_extraction_service_.reset_on_disconnect();\n  }\n}","pos":1,"query":"Initialize screen AI service components","filepos":1,"timecost":1009.6067999999796,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\enterprise\\remote_commands\\clear_browsing_data_job.cc:95-137","function":"ClearBrowsingDataJob::RunImpl","codesnippet":"{\n  uint64_t types = 0;\n  if (clear_cache_)\n    types |= content::BrowsingDataRemover::DATA_TYPE_CACHE;\n\n  if (clear_cookies_)\n    types |= content::BrowsingDataRemover::DATA_TYPE_COOKIES;\n\n  Profile* profile = job_profile_picker_.GetProfile();\n  if (!profile) {\n    // If the payload's profile path doesn't correspond to an existing profile,\n    // there's nothing to do. The most likely scenario is that the profile was\n    // deleted by the time the command was received.\n    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n        FROM_HERE,\n        base::BindOnce(std::move(result_callback), policy::ResultType::kFailure,\n                       CreatePayload(types)));\n    return;\n  }\n\n  result_callback_ = std::move(result_callback);\n\n  if (types == 0) {\n    LOG_POLICY(WARNING, REMOTE_COMMANDS)\n        << \"Clear browsing data command has not specified any \"\n           \"data types. Please double check the payload to \"\n           \"make sure everything is set as required.\";\n    // There's nothing to clear, invoke the callback with success result and be\n    // done.\n    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(\n        FROM_HERE, base::BindOnce(std::move(result_callback_),\n                                  policy::ResultType::kSuccess,\n                                  CreatePayload(\n                                      /*failed_data_types=*/0)));\n    return;\n  }\n\n  content::BrowsingDataRemover* remover = profile->GetBrowsingDataRemover();\n  remover->AddObserver(this);\n\n  remover->RemoveAndReply(\n      base::Time(), base::Time::Max(), types,\n      content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB, this);\n}","pos":-1,"query":"clearBrowsingDataBasedOnFlags","filepos":5,"timecost":1112.3146000000124,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\search\\os_settings_provider.cc:402-465","function":"OsSettingsProvider::FilterResults","codesnippet":"{\n  base::flat_set<std::string> seen_urls;\n  base::flat_map<Subpage, double> seen_subpages;\n  base::flat_map<Section, double> seen_sections;\n  std::vector<SettingsResultPtr> clean_results;\n\n  for (const SettingsResultPtr& result : results) {\n    // Filter results below the score threshold.\n    if (result->relevance_score < min_score_) {\n      continue;\n    }\n\n    // Check if query matched alternate text for the result. If so, only allow\n    // results meeting extra requirements. Perform this check before checking\n    // for duplicates to ensure a rejected alternate result doesn't preclude a\n    // canonical result with a lower score from being shown.\n    if (result->text != result->canonical_text &&\n        (!accept_alternate_matches_ ||\n         query.size() < min_query_length_for_alternates_ ||\n         result->relevance_score < min_score_for_alternates_)) {\n      continue;\n    }\n\n    // Check if URL has been seen.\n    const std::string url = result->url_path_with_parameters;\n    const auto it = seen_urls.find(url);\n    if (it != seen_urls.end()) {\n      continue;\n    }\n\n    seen_urls.insert(url);\n    clean_results.push_back(result.Clone());\n    if (result->type == SettingsResultType::kSubpage) {\n      seen_subpages.insert(\n          std::make_pair(result->id->get_subpage(), result->relevance_score));\n    }\n    if (result->type == SettingsResultType::kSection) {\n      seen_sections.insert(\n          std::make_pair(result->id->get_section(), result->relevance_score));\n    }\n  }\n\n  // Iterate through the clean results a second time. Remove subpage or setting\n  // results that have a higher-scoring ancestor subpage or section also present\n  // in the results.\n  for (size_t i = 0; i < clean_results.size(); ++i) {\n    const auto& result = clean_results[i];\n    if ((result->type == SettingsResultType::kSubpage &&\n         ContainsBetterAncestor(result->id->get_subpage(),\n                                result->relevance_score, hierarchy_,\n                                seen_subpages, seen_sections)) ||\n        (result->type == SettingsResultType::kSetting &&\n         ContainsBetterAncestor(result->id->get_setting(),\n                                result->relevance_score, hierarchy_,\n                                seen_subpages, seen_sections))) {\n      clean_results.erase(clean_results.begin() + i);\n      --i;\n    }\n  }\n\n  return clean_results;\n}","pos":78,"query":"filterAndDeduplicateSettingsResults","filepos":78,"timecost":1088.2135000000126,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\external_install_options.cc:100-178","function":"ExternalInstallOptions::AsDebugValue","codesnippet":"{\n  base::Value::Dict root;\n\n  auto ConvertStringList = [](const std::vector<std::string>& list) {\n    base::Value::List list_json;\n    for (const std::string& item : list)\n      list_json.Append(item);\n    return list_json;\n  };\n\n  auto ConvertOptional = [](const auto& value) {\n    return value ? base::Value(*value) : base::Value();\n  };\n\n  // Prefix with a ! so this appears at the top when serialized.\n  root.Set(\"!install_url\", install_url.spec());\n  root.Set(\"add_to_applications_menu\", add_to_applications_menu);\n  root.Set(\"add_to_desktop\", add_to_desktop);\n  root.Set(\"add_to_management\", add_to_management);\n  root.Set(\"add_to_quick_launch_bar\", add_to_quick_launch_bar);\n  root.Set(\"add_to_search\", add_to_search);\n  root.Set(\"additional_search_terms\",\n           ConvertStringList(additional_search_terms));\n  root.Set(\"app_info_factory\", static_cast<bool>(app_info_factory));\n#if BUILDFLAG(IS_CHROMEOS)\n  root.Set(\"disable_if_arc_supported\", disable_if_arc_supported);\n  root.Set(\"disable_if_tablet_form_factor\", disable_if_tablet_form_factor);\n#endif  // BUILDFLAG(IS_CHROMEOS)\n  root.Set(\"disable_if_touchscreen_with_stylus_not_supported\",\n           disable_if_touchscreen_with_stylus_not_supported);\n  root.Set(\"expected_app_id\", ConvertOptional(expected_app_id));\n  root.Set(\"handles_file_open_intents\", handles_file_open_intents);\n  root.Set(\"fallback_app_name\", ConvertOptional(fallback_app_name));\n  root.Set(\"force_reinstall\", force_reinstall);\n  root.Set(\"force_reinstall_for_milestone\",\n           ConvertOptional(force_reinstall_for_milestone));\n  root.Set(\"gate_on_feature\", ConvertOptional(gate_on_feature));\n  root.Set(\"gate_on_feature_or_installed\",\n           ConvertOptional(gate_on_feature_or_installed));\n  root.Set(\"install_placeholder\", install_placeholder);\n  root.Set(\"install_source\", static_cast<int>(install_source));\n  root.Set(\"is_disabled\", is_disabled);\n  root.Set(\"is_preferred_app_for_supported_links\",\n           is_preferred_app_for_supported_links);\n  root.Set(\"launch_query_params\", ConvertOptional(launch_query_params));\n  root.Set(\"load_and_await_service_worker_registration\",\n           load_and_await_service_worker_registration);\n  root.Set(\"oem_installed\", oem_installed);\n  root.Set(\"only_for_new_users\", only_for_new_users);\n  root.Set(\"only_if_previously_preinstalled\", only_if_previously_preinstalled);\n  root.Set(\"only_use_app_info_factory\", only_use_app_info_factory);\n  root.Set(\"override_previous_user_uninstall\",\n           override_previous_user_uninstall);\n#if BUILDFLAG(ENABLE_PWA_WIN10_PACKAGE)\n  root.Set(\"packaged_app_name\", ConvertOptional(packaged_app_name));\n#endif\n  root.Set(\"require_manifest\", require_manifest);\n  root.Set(\"install_as_diy\", install_as_diy);\n  root.Set(\"service_worker_registration_url\",\n           service_worker_registration_url\n               ? base::Value(service_worker_registration_url->spec())\n               : base::Value());\n  root.Set(\"service_worker_registration_timeout_in_seconds\",\n           service_worker_registration_timeout.InSecondsF());\n#if BUILDFLAG(IS_CHROMEOS)\n  root.Set(\"system_app_type\",\n           system_app_type ? base::Value(static_cast<int>(*system_app_type))\n                           : base::Value());\n#endif\n  root.Set(\"uninstall_and_replace\", ConvertStringList(uninstall_and_replace));\n  root.Set(\"user_display_mode\", user_display_mode.has_value()\n                                    ? base::ToString(*user_display_mode)\n                                    : \"\");\n  root.Set(\"user_type_allowlist\", ConvertStringList(user_type_allowlist));\n  root.Set(\"placeholder_resolution_behavior\",\n           base::Value(static_cast<int>(placeholder_resolution_behavior)));\n  root.Set(\"install_without_os_integration\", install_without_os_integration);\n\n  return base::Value(std::move(root));\n}","pos":-1,"query":"serializeAppInstallationSettings","filepos":-1,"timecost":1182.1535999999905,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\metrics\\perf\\metric_provider.cc:251-284","function":"MetricProvider::AddProfileToCache","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (!recording_enabled_) {\n    base::UmaHistogramEnumeration(record_uma_histogram_,\n                                  RecordAttemptStatus::kRecordingDisabled);\n    return;\n  }\n\n  // For privacy reasons, Chrome can not collect Android app names that may be\n  // present in the perf data, unless the user consent to enabling App Sync.\n  // Therefore, if the user does not enable App Sync, we redact comm_md5_prefix\n  // in all COMM events of perf data proto, so these MD5 prefixes can not be\n  // used to recover Android app names. We perform the check on App Sync here\n  // because the procedure to get the user profile (from which sync settings can\n  // be obtained) must execute on the UI thread.\n  auto app_sync_state = GetAppSyncState();\n  base::UmaHistogramEnumeration(record_uma_histogram_, app_sync_state);\n  if (app_sync_state != RecordAttemptStatus::kAppSyncEnabled)\n    RedactCommMd5Prefixes(sampled_profile->mutable_perf_data());\n\n  // Add the device thermal state and cpu speed limit to the profile.\n  sampled_profile->set_thermal_state(ToProtoThermalStateEnum(thermal_state_));\n  sampled_profile->set_cpu_speed_limit_percent(cpu_speed_limit_percent_);\n\n  collector_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&MetricCollector::AddCachedDataDelta,\n                                base::Unretained(metric_collector_.get()),\n                                sampled_profile->ByteSizeLong()));\n  cached_profile_data_.resize(cached_profile_data_.size() + 1);\n  cached_profile_data_.back().Swap(sampled_profile.get());\n\n  if (!cache_updated_callback_.is_null())\n    cache_updated_callback_.Run();\n}","pos":-1,"query":"ProcessProfileDataWithPrivacyCheck","filepos":-1,"timecost":1126.5979999999981,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\passwords\\edge_password_items_view.cc:90-135","function":"BuildColumnSet","codesnippet":"{\n  // Passwords are split 60/40 (6:4) as the username is more important\n  // than obscured password digits. Otherwise two columns are 50/50 (1:1).\n  constexpr float kFirstColumnWeight = 60.0f;\n  constexpr float kSecondColumnWeight = 40.0f;\n  const int between_column_padding =\n      GetLayoutConstant(EDGE_AUTOFILL_SAVED_PASSWORD_HORIZONTAL_GAP);\n  table_layout\n      // favicon column\n      ->AddColumn(views::LayoutAlignment::kStretch,\n                  views::LayoutAlignment::kStretch,\n                  views::TableLayout::kFixedSize,\n                  views::TableLayout::ColumnSize::kUsePreferred, 0, 0)\n      .AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kStretch,\n                 views::LayoutAlignment::kStretch, kFirstColumnWeight,\n                 views::TableLayout::ColumnSize::kFixed, 0, 0)\n      .AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kStretch,\n                 views::LayoutAlignment::kStretch, kSecondColumnWeight,\n                 views::TableLayout::ColumnSize::kFixed, 0, 0);\n\n  if (type_id == MULTI_STORE_PASSWORD_COLUMN_SET) {\n    // All rows show a store indicator or leave the space blank.\n    table_layout\n        ->AddPaddingColumn(views::TableLayout::kFixedSize,\n                           between_column_padding)\n        .AddColumn(views::LayoutAlignment::kStretch,\n                   views::LayoutAlignment::kStretch,\n                   views::TableLayout::kFixedSize,\n                   views::TableLayout::ColumnSize::kUsePreferred, 0, 0)\n        // Add a column for the vertical bar.\n        .AddPaddingColumn(views::TableLayout::kFixedSize,\n                          between_column_padding)\n        .AddColumn(views::LayoutAlignment::kStretch,\n                   views::LayoutAlignment::kCenter,\n                   views::TableLayout::kFixedSize,\n                   views::TableLayout::ColumnSize::kUsePreferred, 0, 0);\n  }\n  // All rows end with a trailing column for the undo/trash button.\n  table_layout\n      ->AddPaddingColumn(views::TableLayout::kFixedSize, between_column_padding)\n      .AddColumn(views::LayoutAlignment::kEnd, views::LayoutAlignment::kStretch,\n                 views::TableLayout::kFixedSize,\n                 views::TableLayout::ColumnSize::kUsePreferred, 0, 0);\n}","pos":-1,"query":"Configure password table layout","filepos":1,"timecost":1154.0562999999966,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\processes\\processes_api.cc:250-318","function":"ProcessesEventRouter::OnTasksRefreshedWithBackgroundCalculations","codesnippet":"{\n  const bool has_on_updated_listeners =\n      HasEventListeners(api::processes::OnUpdated::kEventName);\n  const bool has_on_updated_with_memory_listeners =\n      HasEventListeners(api::processes::OnUpdatedWithMemory::kEventName);\n\n  if (!has_on_updated_listeners && !has_on_updated_with_memory_listeners)\n    return;\n\n  // Get the data of tasks sharing the same process only once.\n  std::set<base::ProcessId> seen_processes;\n  base::Value::Dict processes_dictionary;\n  for (const auto& task_id : task_ids) {\n    // We are not interested in tasks, but rather the processes on which they\n    // run.\n    const base::ProcessId proc_id =\n        observed_task_manager()->GetProcessId(task_id);\n    if (seen_processes.count(proc_id))\n      continue;\n\n    const int child_process_host_id =\n        observed_task_manager()->GetChildProcessUniqueId(task_id);\n    // Ignore tasks that don't have a valid child process host ID like ARC\n    // processes. We report the browser process info here though.\n    if (child_process_host_id == content::ChildProcessHost::kInvalidUniqueID)\n      continue;\n\n    seen_processes.insert(proc_id);\n    api::processes::Process process;\n    FillProcessData(task_id,\n                    observed_task_manager(),\n                    true,  // include_optional\n                    &process);\n\n    if (has_on_updated_with_memory_listeners) {\n      // Append the memory footprint to the process data.\n      const int64_t memory_footprint =\n          observed_task_manager()->GetMemoryFootprintUsage(task_id);\n      process.private_memory = static_cast<double>(memory_footprint);\n    }\n\n    // Store each process indexed by the string version of its ChildProcessHost\n    // ID.\n    processes_dictionary.Set(base::NumberToString(child_process_host_id),\n                             process.ToValue());\n  }\n\n  // Done with data collection. Now dispatch the appropriate events according to\n  // the present listeners.\n  DCHECK(has_on_updated_listeners || has_on_updated_with_memory_listeners);\n  if (has_on_updated_listeners) {\n    api::processes::OnUpdated::Processes processes;\n    processes.additional_properties.Merge(processes_dictionary.Clone());\n    // NOTE: If there are listeners to the updates with memory as well,\n    // listeners to onUpdated (without memory) will also get the memory info\n    // of processes as an added bonus.\n    DispatchEvent(events::PROCESSES_ON_UPDATED,\n                  api::processes::OnUpdated::kEventName,\n                  api::processes::OnUpdated::Create(processes));\n  }\n\n  if (has_on_updated_with_memory_listeners) {\n    api::processes::OnUpdatedWithMemory::Processes processes;\n    processes.additional_properties.Merge(std::move(processes_dictionary));\n    DispatchEvent(events::PROCESSES_ON_UPDATED_WITH_MEMORY,\n                  api::processes::OnUpdatedWithMemory::kEventName,\n                  api::processes::OnUpdatedWithMemory::Create(processes));\n  }\n}","pos":-1,"query":"DispatchProcessUpdateEvents","filepos":19,"timecost":1591.463300000003,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\storage_access_api\\storage_access_grant_permission_context.cc:532-565","function":"StorageAccessGrantPermissionContext::OnCheckedUserInteractionHeuristic","codesnippet":"{\n  content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(\n      request_data->id.global_render_frame_host_id());\n\n  if (!rfh) {\n    // After async steps, the RenderFrameHost is not guaranteed to still be\n    // alive.\n    RecordOutcomeSample(RequestOutcome::kDeniedAborted,\n                        net::SchemefulSite(request_data->requesting_origin));\n    std::move(callback).Run(CONTENT_SETTING_BLOCK);\n    return;\n  }\n\n  if (!had_top_level_user_interaction) {\n    rfh->AddMessageToConsole(\n        blink::mojom::ConsoleMessageLevel::kError,\n        \"requestStorageAccess: Request denied because the embedded site has \"\n        \"never been interacted with as a top-level context\");\n    NotifyPermissionSetInternal(\n        request_data, std::move(callback),\n        /*persist=*/false, CONTENT_SETTING_BLOCK,\n        RequestOutcome::kDeniedByTopLevelInteractionHeuristic);\n    return;\n  }\n\n  // PermissionContextBase::DecidePermission requires that the RenderFrameHost\n  // is still alive.\n  CHECK(rfh);\n  // Show prompt.\n  PermissionContextBase::DecidePermission(std::move(request_data),\n                                          std::move(callback));\n}","pos":-1,"query":"handleStorageAccessRequest","filepos":-1,"timecost":1147.741399999999,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\autofill\\popup\\popup_base_view.cc:162-193","function":"Widget","codesnippet":"{\n    views::Widget::InitParams params(\n        views::Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET,\n        views::Widget::InitParams::TYPE_POPUP);\n    params.delegate = autofill_popup_base_view;\n    params.parent = parent_native_view;\n#if BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    EdgeInitWidgetParams(autofill_popup_base_view, params);\n#else\n    // Ensure the popup border is not painted on an opaque background.\n    params.opacity = views::Widget::InitParams::WindowOpacity::kTranslucent;\n    params.shadow_type = views::Widget::InitParams::ShadowType::kNone;\n#endif  // BUILDFLAG(MICROSOFT_EDGE_BRANDING)\n    params.activatable = activatable;\n\n    // `kSecuritySurface` makes the popup to display on top of all other windows\n    // (including system ones, but the support among different OS, versions and\n    // setups is not consistent). This is not required for regular autofill\n    // popup use, but it makes certain attacks (those based on the popup being\n    // obscured) less practical.\n    if (base::FeatureList::IsEnabled(\n            features::kAutofillPopupZOrderSecuritySurface)) {\n      params.z_order = ui::ZOrderLevel::kSecuritySurface;\n    }\n\n    Init(std::move(params));\n    AddObserver(popup_base_view());\n\n    // No animation for popup appearance (too distracting).\n    SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);\n  }","pos":0,"query":"Initialize and configure autofill popup widget","filepos":0,"timecost":808.7356999999902,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\context_menu_matcher.cc:318-392","function":"ContextMenuMatcher::RecursivelyAppendExtensionItems","codesnippet":"{\n  MenuItem::Type last_type = MenuItem::NORMAL;\n  int radio_group_id = 1;\n  int num_visible_items = 0;\n\n  bool enable_separators = false;\n\n#if !BUILDFLAG(IS_CHROMEOS)\n  enable_separators = true;\n#endif\n\n  for (auto i = items.begin(); i != items.end(); ++i) {\n    MenuItem* item = *i;\n\n    // If last item was of type radio but the current one isn't, auto-insert\n    // a separator.  The converse case is handled below.\n    if (last_type == MenuItem::RADIO && item->type() != MenuItem::RADIO &&\n        enable_separators) {\n      menu_model->AddSeparator(ui::NORMAL_SEPARATOR);\n      last_type = MenuItem::SEPARATOR;\n    }\n\n    int menu_id = ConvertToExtensionsCustomCommandId(*index);\n    // Action context menus have a limit for top level extension items to\n    // prevent control items from being pushed off the screen, since extension\n    // items will not be placed in a submenu.\n    const int top_level_limit = api::context_menus::ACTION_MENU_TOP_LEVEL_LIMIT;\n    if (menu_id >= extensions_context_custom_last ||\n        (is_action_menu_top_level && num_visible_items >= top_level_limit))\n      return;\n\n    ++(*index);\n    if (item->visible())\n      ++num_visible_items;\n\n    extension_item_map_[menu_id] = item->id();\n    std::u16string title = item->TitleWithReplacement(\n        selection_text, kMaxExtensionItemTitleLength);\n    if (item->type() == MenuItem::NORMAL) {\n      MenuItem::List children =\n          GetRelevantExtensionItems(item->children(), can_cross_incognito);\n      if (children.empty()) {\n        menu_model->AddItem(menu_id, title);\n      } else {\n        ui::SimpleMenuModel* submenu = new ui::SimpleMenuModel(delegate_);\n        extension_menu_models_.push_back(base::WrapUnique(submenu));\n        menu_model->AddSubMenu(menu_id, title, submenu);\n        RecursivelyAppendExtensionItems(children, can_cross_incognito,\n                                        selection_text, submenu, index,\n                                        false);  // is_action_menu_top_level\n      }\n    } else if (item->type() == MenuItem::CHECKBOX) {\n      menu_model->AddCheckItem(menu_id, title);\n    } else if (item->type() == MenuItem::RADIO) {\n      if (i != items.begin() &&\n          last_type != MenuItem::RADIO) {\n        radio_group_id++;\n\n        // Auto-append a separator if needed.\n        if (enable_separators)\n          menu_model->AddSeparator(ui::NORMAL_SEPARATOR);\n      }\n\n      menu_model->AddRadioItem(menu_id, title, radio_group_id);\n    } else if (item->type() == MenuItem::SEPARATOR && enable_separators) {\n      menu_model->AddSeparator(ui::NORMAL_SEPARATOR);\n    }\n    last_type = item->type();\n  }\n}","pos":-1,"query":"Builds and organizes menu items with separators","filepos":-1,"timecost":1185.4677000000083,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\performance_manager\\observers\\page_load_metrics_observer.cc:287-328","function":"PageLoadMetricsWebContentsObserver::DidFinishNavigation","codesnippet":"{\n  // We don't record metrics for prerendering pages.\n  if (!navigation_handle->HasCommitted() ||\n      !navigation_handle->GetRenderFrameHost()->IsActive()) {\n    return;\n  }\n\n#if BUILDFLAG(ENABLE_GUEST_VIEW)\n  // Ignore navigations within guests. They don't affect the load state.\n  if (guest_view::GuestViewBase::IsGuest(navigation_handle)) {\n    return;\n  }\n#endif\n\n  DCHECK(is_loading_);\n\n  if (navigation_handle->IsInPrimaryMainFrame() &&\n      !navigation_handle->IsSameDocument()) {\n    RecordUKM();\n    ukm_source_id_ = ukm::ConvertToSourceId(\n        navigation_handle->GetNavigationId(), ukm::SourceIdType::NAVIGATION_ID);\n  }\n\n  NavigationType navigation_type;\n  if (navigation_handle->IsSameDocument()) {\n    if (navigation_handle->IsInPrimaryMainFrame())\n      navigation_type = NavigationType::kMainFrameSameDocument;\n    else\n      navigation_type = NavigationType::kSubFrameSameDocument;\n  } else {\n    if (navigation_handle->IsInPrimaryMainFrame())\n      navigation_type = NavigationType::kMainFrameDifferentDocument;\n    else\n      navigation_type = NavigationType::kSubFrameDifferentDocument;\n  }\n\n  // Replace the navigation type of the current load only if the current\n  // navigation has a lower value than previously seen navigations within the\n  // current load.\n  if (navigation_type < navigation_type_)\n    navigation_type_ = navigation_type;\n}","pos":-1,"query":"Determine and record navigation type","filepos":-1,"timecost":1351.7663000000175,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\offline_pages\\android\\offline_page_archive_publisher_impl.cc:49-93","function":"MoveAndRegisterArchive","codesnippet":"{\n  // For Android Q+, use the downloads collection rather than DownloadManager.\n  if (ShouldUseDownloadsCollection()) {\n    return delegate->AddCompletedDownload(offline_page);\n  }\n\n  OfflinePageItem published_page(offline_page);\n\n  // Calculate the new file name.\n  published_page.file_path =\n      offline_pages::model_utils::GenerateUniqueFilenameForOfflinePage(\n          offline_page.title, offline_page.url, publish_directory);\n\n  // Create the destination directory if it does not already exist.\n  if (!publish_directory.empty() && !base::DirectoryExists(publish_directory)) {\n    base::File::Error file_error;\n    base::CreateDirectoryAndGetError(publish_directory, &file_error);\n  }\n\n  // Move the file.\n  bool moved = base::Move(offline_page.file_path, published_page.file_path);\n  if (!moved) {\n    DVPLOG(0) << \"OfflinePage publishing file move failure \" << __func__;\n\n    if (!base::PathExists(offline_page.file_path)) {\n      DVLOG(0) << \"Can't copy from non-existent path, from \"\n               << offline_page.file_path << \" \" << __func__;\n    }\n    if (!base::PathExists(publish_directory)) {\n      DVLOG(0) << \"Target directory does not exist, \" << publish_directory\n               << \" \" << __func__;\n    }\n    return PublishArchiveResult::Failure(SavePageResult::FILE_MOVE_FAILED);\n  }\n\n  // Tell the download manager about our file, get back an id.\n  if (!delegate->IsDownloadManagerInstalled()) {\n    return PublishArchiveResult::Failure(\n        SavePageResult::ADD_TO_DOWNLOAD_MANAGER_FAILED);\n  }\n\n  return delegate->AddCompletedDownload(published_page);\n}","pos":-1,"query":"PublishOfflinePageToDownloads","filepos":88,"timecost":886.7884000000195,"filemrr":0.3},{"filePath":"D:\\Edge\\src\\chrome\\browser\\supervised_user\\supervised_user_extensions_manager.cc:405-443","function":"SupervisedUserExtensionsManager::ChangeExtensionStateIfNecessary","codesnippet":"{\n  // If the profile is not supervised, do nothing.\n  // TODO(crbug/1026900): SupervisedUserService should not be active if the\n  // profile is not even supervised during browser tests, i.e. this check\n  // shouldn't be needed.\n  if (!is_active_policy_for_supervised_users_) {\n    return;\n  }\n  const Extension* extension =\n      extension_registry_->GetInstalledExtension(extension_id);\n  // If the extension is not installed (yet), do nothing.\n  // Things will be handled after installation.\n  if (!extension) {\n    return;\n  }\n\n  auto* registrar = extensions::ExtensionRegistrar::Get(context_);\n  ExtensionState state = GetExtensionState(*extension);\n  switch (state) {\n    // BLOCKED extensions should be already disabled and we don't need to change\n    // their state here.\n    case ExtensionState::BLOCKED:\n      break;\n    case ExtensionState::REQUIRE_APPROVAL:\n      registrar->DisableExtension(\n          extension_id,\n          {extensions::disable_reason::DISABLE_CUSTODIAN_APPROVAL_REQUIRED});\n      break;\n    case ExtensionState::ALLOWED:\n      extension_prefs_->RemoveDisableReason(\n          extension_id,\n          extensions::disable_reason::DISABLE_CUSTODIAN_APPROVAL_REQUIRED);\n      // If not disabled for other reasons, enable it.\n      if (extension_prefs_->GetDisableReasons(extension_id).empty()) {\n        registrar->EnableExtension(extension_id);\n      }\n      break;\n  }\n}","pos":10,"query":"ManageExtensionBasedOnSupervisionStatus","filepos":10,"timecost":936.7438000000257,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_lightning\\lightning_bubble_view.cc:595-636","function":"LightningBubbleView::OnShowImportButtonClick","codesnippet":"{\n  DCHECK(browser_);\n  GURL password_url = GURL(chrome::kEdgeUISettingsPasswordURL);\n  GURL favorites_url = GURL(chrome::kEdgeUIFavoritesURL);\n\n  if (password_import_succeeded_ && takeout_import_succeeded_) {\n    browser_->OpenURL(\n        content::OpenURLParams(password_url, content::Referrer(),\n                               WindowOpenDisposition::NEW_FOREGROUND_TAB,\n                               ui::PAGE_TRANSITION_LINK, false),\n        /*navigation_handle_callback=*/{});\n    browser_->OpenURL(\n        content::OpenURLParams(favorites_url, content::Referrer(),\n                               WindowOpenDisposition::NEW_BACKGROUND_TAB,\n                               ui::PAGE_TRANSITION_LINK, false),\n        /*navigation_handle_callback=*/{});\n  } else if (takeout_import_succeeded_) {\n    browser_->OpenURL(\n        content::OpenURLParams(favorites_url, content::Referrer(),\n                               WindowOpenDisposition::NEW_FOREGROUND_TAB,\n                               ui::PAGE_TRANSITION_LINK, false),\n        /*navigation_handle_callback=*/{});\n  } else if (password_import_succeeded_) {\n    browser_->OpenURL(\n        content::OpenURLParams(password_url, content::Referrer(),\n                               WindowOpenDisposition::NEW_FOREGROUND_TAB,\n                               ui::PAGE_TRANSITION_LINK, false),\n        /*navigation_handle_callback=*/{});\n  }\n\n  if (show_pinning_sites_) {\n    base::UmaHistogramEnumeration(\n        kLightningPostImportDialogPinningClickActionHistogram,\n        PinningClickActionType::kViewImportedDataClicked);\n  } else {\n    base::UmaHistogramEnumeration(\n        kLightningPostImportDialogClickActionHistogram,\n        ClickActionType::kViewImportedDataClicked);\n  }\n\n  GetWidget()->CloseWithReason(\n      views::Widget::ClosedReason::kAcceptButtonClicked);\n}","pos":-1,"query":"Open URLs based on import success","filepos":-1,"timecost":1665.779899999994,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\enterprise\\data_controls\\chrome_dlp_rules_manager.cc:204-241","function":"ChromeDlpRulesManager::GetSourceUrlPattern","codesnippet":"{\n  const std::set<UrlConditionId> url_conditions_ids =\n      src_url_matcher_->MatchURL(source_url);\n\n  std::map<RuleId, UrlConditionId> rules_conditions_map;\n  for (const auto& condition_id : url_conditions_ids) {\n    rules_conditions_map.insert(\n        std::make_pair(src_url_rules_mapping_.at(condition_id), condition_id));\n  }\n  auto restriction_itr = restrictions_map_.find(restriction);\n  if (restriction_itr == restrictions_map_.end()) {\n    return std::string();\n  }\n\n  const auto rules_levels_map = restriction_itr->second;\n  for (const auto& rule_level_entry : rules_levels_map) {\n    auto rule_id = rule_level_entry.first;\n    auto lvl = rule_level_entry.second;\n    auto rule_condition_itr = rules_conditions_map.find(rule_id);\n    if (lvl == level && rule_condition_itr != rules_conditions_map.end()) {\n      auto condition_id = rule_condition_itr->second;\n      auto condition_pattern_itr = src_patterns_mapping_.find(condition_id);\n      if (condition_pattern_itr != src_patterns_mapping_.end()) {\n        if (out_rule_metadata) {\n          auto rule_metadata_itr = rules_id_metadata_mapping_.find(rule_id);\n          if (rule_metadata_itr != rules_id_metadata_mapping_.end()) {\n            *out_rule_metadata = rule_metadata_itr->second;\n          }\n        }\n        return condition_pattern_itr->second;\n      }\n    }\n  }\n  return std::string();\n}","pos":-1,"query":"findMatchingUrlPatternWithMetadata","filepos":-1,"timecost":1296.5715999999957,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\ash\\emoji\\emoji_page_handler.cc:518-549","function":"EmojiPageHandler::GetHistoryFromPrefs","codesnippet":"{\n  if (profile_ == nullptr || profile_->GetPrefs() == nullptr) {\n    std::move(callback).Run({});\n    return;\n  }\n  const base::Value::List* history =\n      profile_->GetPrefs()\n          ->GetDict(prefs::kEmojiPickerHistory)\n          .FindList(ConvertCategoryToPrefString(category));\n  if (history == nullptr) {\n    std::move(callback).Run({});\n    return;\n  }\n  std::vector<emoji_picker::mojom::HistoryItemPtr> results;\n  for (const auto& it : *history) {\n    const base::Value::Dict* value_dict = it.GetIfDict();\n    if (value_dict == nullptr) {\n      continue;\n    }\n    const std::string* text =\n        value_dict->FindString(kPrefsHistoryTextFieldName);\n    std::optional<base::Time> timestamp =\n        base::ValueToTime(value_dict->Find(kPrefsHistoryTimestampFieldName));\n\n    if (text != nullptr) {\n      results.push_back(emoji_picker::mojom::HistoryItem::New(\n          *text, timestamp.has_value() ? *timestamp : base::Time::UnixEpoch()));\n    }\n  }\n  std::move(callback).Run(std::move(results));\n}","pos":-1,"query":"Retrieve and process emoji picker history","filepos":-1,"timecost":963.0933000000077,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\policy\\edge_admin_center\\eac_user_policy_signin_service.cc:109-145","function":"EACUserPolicySigninService::OnPrimaryAccountChanged","codesnippet":"{\n  VLOG(1) << \"EACUserPolicySigninService primary account changed\";\n  ProfileManager* profile_manager = g_browser_process->profile_manager();\n\n  // Profile is signing out\n  if (profile_manager && IsSignoutEvent(event)) {\n    ShutdownEACUserPolicyManager();\n    // Profile turned off sync, check that we can still apply policies\n  } else if (IsTurnOffSyncEvent(event) && !CanApplyPolicies(true)) {\n    ShutdownEACUserPolicyManager();\n  }\n\n  // We don't care about signin events here\n  if (!IsAnySigninEvent(event)) {\n    return;\n  }\n\n  // If we can't apply policies, nothing to do\n  if (!CanApplyPolicies(true)) {\n    return;\n  }\n\n  InitializeForSignedInUser();\n  InitializeForBrowserWidePolicies();\n\n  if (base::FeatureList::IsEnabled(\n          features::edge::kEmxFetchPoliciesOnProfileSignin)) {\n    // Fetch policies so they are available immediately after sign-in.\n    if (user_policy_manager() && user_policy_manager()->has_client()) {\n      user_policy_manager()->RefreshPolicies(PolicyFetchReason::kSignin);\n    }\n\n    if (token_policy_manager() && token_policy_manager()->has_client()) {\n      token_policy_manager()->RefreshPolicies(PolicyFetchReason::kSignin);\n    }\n  }\n}","pos":26,"query":"Manage user policy on account change","filepos":26,"timecost":981.2110000000102,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\edge_san_personalization\\san_prompt_bubble_view.cc:355-396","function":"unknown","codesnippet":"{\n  auto subtitle_view = std::make_unique<views::View>();\n  subtitle_view->SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical, gfx::Insets::TLBR(0, 24, 20, 8),\n      ChromeLayoutProvider::Get()->GetDistanceMetric(\n          views::DISTANCE_RELATED_CONTROL_VERTICAL)));\n\n  std::u16string subtitle_string = GetSubtitleText() + u\"\\n\" +\n                                   GetLearnMoreLinkText() + u\" | \" +\n                                   GetPrivacyLinkText();\n\n  // calculate indices for styling\n  auto learn_more_start_index = GetSubtitleText().length() + 1;\n  auto learn_more_end_index =\n      learn_more_start_index + GetLearnMoreLinkText().length();\n  auto privacy_start_index = learn_more_end_index + 3;\n  auto privacy_end_index = privacy_start_index + GetPrivacyLinkText().length();\n\n  auto subtitle_label = std::make_unique<views::StyledLabel>();\n  subtitle_label->SetText(subtitle_string);\n  subtitle_label->SetLineHeight(16);\n  subtitle_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n\n  // learn more text styling\n  auto learn_more_link_style =\n      views::StyledLabel::RangeStyleInfo::CreateForLink(\n          base::BindRepeating(&SanPromptBubbleView::OnLearnMoreLinkClicked,\n                              base::Unretained(this)));\n  subtitle_label->AddStyleRange(\n      gfx::Range(learn_more_start_index, learn_more_end_index),\n      learn_more_link_style);\n\n  // privacy text styling\n  auto privacy_link_style =\n      views::StyledLabel::RangeStyleInfo::CreateForLink(base::BindRepeating(\n          &SanPromptBubbleView::OnPrivacyLinkClicked, base::Unretained(this)));\n  subtitle_label->AddStyleRange(\n      gfx::Range(privacy_start_index, privacy_end_index), privacy_link_style);\n\n  subtitle_view->AddChildView(std::move(subtitle_label));\n\n  return AddChildView(std::move(subtitle_view));\n}","pos":-1,"query":"CreateStyledSubtitleViewWithLinks","filepos":-1,"timecost":1566.9809999999998,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\chromeos\\extensions\\login_screen\\login\\shared_session_handler.cc:161-211","function":"SharedSessionHandler::UnlockSharedSession","codesnippet":"{\n  if (session_manager::SessionManager::Get()->session_state() !=\n      session_manager::SessionState::LOCKED) {\n    std::move(callback).Run(extensions::login_api_errors::kSessionIsNotLocked);\n    return;\n  }\n\n  if (session_secret_.empty()) {\n    std::move(callback).Run(extensions::login_api_errors::kNoSharedMGSFound);\n    return;\n  }\n\n  if (user_secret_hash_.empty()) {\n    std::move(callback).Run(\n        extensions::login_api_errors::kSharedSessionIsNotActive);\n    return;\n  }\n\n  CHECK(!user_secret_salt_.empty());\n\n  if (chromeos::CleanupManagerAsh::Get()->is_cleanup_in_progress()) {\n    std::move(callback).Run(extensions::login_api_errors::kCleanupInProgress);\n    return;\n  }\n\n  if (LoginApiLockHandler::Get()->IsUnlockInProgress()) {\n    std::move(callback).Run(\n        extensions::login_api_errors::kAnotherUnlockAttemptInProgress);\n    return;\n  }\n\n  std::optional<std::string> scrypt_result =\n      GetHashFromScrypt(password, user_secret_salt_);\n\n  if (!scrypt_result) {\n    std::move(callback).Run(extensions::login_api_errors::kScryptFailure);\n    return;\n  }\n\n  if (!crypto::SecureMemEqual(base::as_byte_span(*scrypt_result),\n                              base::as_byte_span(user_secret_hash_))) {\n    std::move(callback).Run(\n        extensions::login_api_errors::kAuthenticationFailed);\n    return;\n  }\n\n  UnlockWithSessionSecret(\n      base::BindOnce(&SharedSessionHandler::OnAuthenticateDone,\n                     base::Unretained(this), std::move(callback)));\n}","pos":-1,"query":"Authenticate user and unlock session","filepos":36,"timecost":1705.400099999999,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\policy\\reporting\\arc_app_install_event_logger.cc:135-184","function":"ArcAppInstallEventLogger::OnComplianceReportReceived","codesnippet":"{\n  const base::Value::List* const details =\n      compliance_report->GetDict().FindList(\"nonComplianceDetails\");\n  if (!details) {\n    return;\n  }\n\n  const std::set<std::string> all_force_install_apps_in_policy =\n      GetPackagesFromPref(arc::prefs::kArcPushInstallAppsRequested);\n  const std::set<std::string> previous_pending =\n      GetPackagesFromPref(arc::prefs::kArcPushInstallAppsPending);\n\n  std::set<std::string> noncompliant_apps_in_report;\n  for (const auto& detail : *details) {\n    const base::Value::Dict& details_dict = detail.GetDict();\n    const std::optional<int> reason =\n        details_dict.FindInt(\"nonComplianceReason\");\n    if (!reason || *reason != kNonComplianceReasonAppNotInstalled) {\n      continue;\n    }\n    const std::string* const app_name = details_dict.FindString(\"packageName\");\n    if (!app_name || app_name->empty()) {\n      continue;\n    }\n    noncompliant_apps_in_report.insert(*app_name);\n  }\n  const std::set<std::string> all_installed_apps = GetDifference(\n      all_force_install_apps_in_policy, noncompliant_apps_in_report);\n\n  std::set<std::string> newly_installed_apps;\n  std::set_intersection(\n      previous_pending.begin(), previous_pending.end(),\n      all_installed_apps.begin(), all_installed_apps.end(),\n      std::inserter(newly_installed_apps, newly_installed_apps.end()));\n\n  AddForSetOfAppsWithDiskSpaceInfo(\n      newly_installed_apps, CreateEvent(em::AppInstallReportLogEvent::SUCCESS));\n\n  if (newly_installed_apps.empty()) {\n    return;\n  }\n\n  SetPref(arc::prefs::kArcPushInstallAppsPending, noncompliant_apps_in_report);\n\n  if (!noncompliant_apps_in_report.empty()) {\n    UpdateCollector(noncompliant_apps_in_report);\n  } else {\n    StopCollector();\n  }\n}","pos":-1,"query":"ProcessNonCompliantAppsReport","filepos":-1,"timecost":1467.5252000000037,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\login\\screens\\reset_screen.cc:180-240","function":"ResetScreen::ShowImpl","codesnippet":"{\n  if (!view_) {\n    return;\n  }\n\n  // Guest sign-in button should be disabled as sign-in is not possible while\n  // reset screen is shown.\n  if (!scoped_guest_button_blocker_) {\n    scoped_guest_button_blocker_ =\n        LoginScreen::Get()->GetScopedGuestButtonBlocker();\n  }\n\n  const bool restart_required =\n      user_manager::UserManager::Get()->IsUserLoggedIn() ||\n      !base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kFirstExecAfterBoot);\n  SetScreenState(restart_required ? State::kRestartRequired\n                                  : State::kPowerwashProposal);\n\n  // Set availability of Rollback feature.\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableRollbackOption)) {\n    SetIsRollbackAvailable(false);\n  } else {\n    UpdateEngineClient::Get()->CanRollbackCheck(base::BindOnce(\n        &ResetScreen::OnRollbackCheck, weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  // Set availability of TPM firmware update.\n  PrefService* const prefs = g_browser_process->local_state();\n  const bool tpm_firmware_update_requested =\n      prefs->HasPrefPath(prefs::kFactoryResetTPMFirmwareUpdateMode);\n  if (tpm_firmware_update_requested) {\n    // If an update has been requested previously, rely on the earlier update\n    // availability test to initialize the dialog. This avoids a race condition\n    // where the powerwash dialog gets shown immediately after reboot before the\n    // init job to determine update availability has completed.\n    view_->SetIsTpmFirmwareUpdateAvailable(true);\n    SetTpmFirmwareUpdateMode(static_cast<tpm_firmware_update::Mode>(\n        prefs->GetInteger(prefs::kFactoryResetTPMFirmwareUpdateMode)));\n  } else {\n    // If a TPM firmware update hasn't previously been requested, check the\n    // system to see whether to offer the checkbox to update TPM firmware. Note\n    // that due to the asynchronous availability check, the decision might not\n    // be available immediately, so set a timeout of a couple seconds.\n    tpm_firmware_update_checker_.Run(\n        base::BindOnce(&ResetScreen::OnTPMFirmwareUpdateAvailableCheck,\n                       weak_ptr_factory_.GetWeakPtr()),\n        base::Seconds(10));\n  }\n\n  SetIsTpmFirmwareUpdateChecked(tpm_firmware_update_requested);\n  view_->SetIsTpmFirmwareUpdateEditable(!tpm_firmware_update_requested);\n\n  // Clear prefs so the reset screen isn't triggered again the next time the\n  // device is about to show the login screen.\n  prefs->ClearPref(prefs::kFactoryResetRequested);\n  prefs->ClearPref(prefs::kFactoryResetTPMFirmwareUpdateMode);\n  prefs->CommitPendingWrite();\n\n  view_->Show();\n}","pos":-1,"query":"resetScreenInitialization","filepos":2,"timecost":1420.9912999999942,"filemrr":0},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\certificate_dialogs.cc:122-152","function":"Exporter::Exporter","codesnippet":"{\n  base::FilePath suggested_name =\n      net::GenerateFileName(GURL(),               // url\n                            std::string(),        // content_disposition\n                            std::string(),        // referrer_charset\n                            suggested_file_name,  // suggested_name\n                            std::string(),        // mime_type\n                            \"certificate\");       // default_name\n\n  DownloadPrefs* download_prefs =\n      DownloadPrefs::FromBrowserContext(web_contents->GetBrowserContext());\n  base::FilePath suggested_path =\n      download_prefs->SaveFilePath().Append(suggested_name);\n\n  if (full_export_) {\n    ShowCertSelectFileDialogFullExport(select_file_dialog_.get(),\n                                       suggested_path, parent);\n  } else {\n    ShowCertSelectFileDialog(select_file_dialog_.get(),\n                             ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n                             suggested_path, parent);\n  }\n}","pos":-1,"query":"Show certificate save dialog","filepos":28,"timecost":1009.9232999999949,"filemrr":0.1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_photo\\photo_navigation_web_contents_observer.cc:27-69","function":"PhotoNavigationWebContentsObserver::DidFinishNavigation","codesnippet":"{\n  if (!base::FeatureList::IsEnabled(edge_photo::features::kEdgePhoto)) {\n    return;\n  }\n\n  if (!should_notify_) {\n    return;\n  }\n\n  if (!navigation_handle || !navigation_handle->IsInPrimaryMainFrame() ||\n      !navigation_handle->GetWebContents()) {\n    return;\n  }\n\n  content::WebContents* contents = web_contents();\n  if (!contents) {\n    return;\n  }\n\n  const GURL current_url = contents->GetOriginalRequestURL();\n\n  if (!current_url.SchemeIs(extensions::kExtensionScheme) ||\n      current_url.host_piece() != extension_misc::kEdgePhotoExtensionId) {\n    return;\n  }\n\n  auto file_path = utils::ToFilePathWithDecode(current_url.query());\n  if (!utils::IsSupportedFile(file_path)) {\n    return;\n  }\n\n  base::FilePath::StringType extension = file_path.Extension();\n  if (extension.empty()) {\n    return;\n  }\n\n  if (hijacking_prevention::IsEdgeDefaultAppForFileHandler(extension)) {\n    return;\n  }\n\n  TriggerDefaultImageHandlerPromotionCampaign(contents);\n  should_notify_ = false;\n}","pos":-1,"query":"Promotes default image handler campaign","filepos":-1,"timecost":1046.0361000000266,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\enterprise\\connectors\\device_trust\\key_management\\browser\\key_utils.cc:16-47","function":"GetUploadBrowserPublicKeyUrl","codesnippet":"{\n  if (!device_management_service) {\n    return std::nullopt;\n  }\n\n  auto params = policy::DMServerJobConfiguration::CreateParams::WithoutClient(\n      policy::DeviceManagementService::JobConfiguration::\n          TYPE_BROWSER_UPLOAD_PUBLIC_KEY,\n      device_management_service, client_id, nullptr);\n\n  params.critical = true;\n  params.auth_data = policy::DMAuth::FromDMToken(dm_token);\n  if (profile_id.has_value()) {\n    params.profile_id = profile_id.value();\n  }\n\n  policy::DMServerJobConfiguration config(std::move(params));\n\n  auto resource_request = config.GetResourceRequest(false, 0);\n  if (!resource_request) {\n    return std::nullopt;\n  }\n\n  if (!resource_request->url.is_valid()) {\n    return std::nullopt;\n  }\n\n  return resource_request->url.spec();\n}","pos":-1,"query":"GenerateResourceRequestURL","filepos":-1,"timecost":1422.2281000000075,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_settings_webui2\\pages\\common\\common_page_data_provider_page_color_blocklist.cc:99-149","function":"CommonPageColorBlocklistPageDataProvider::BuildBlocklistDialog","codesnippet":"{\n  DCHECK(button);\n  auto button_info = BuildDialogInfo(\n      mojom::FormControlIds::PageColorsBlockListActionRow,\n      mojom::DialogType::CustomFormDialog,\n      GetResourceString(IDS_SETTINGS_ON_STARTUP_SECTION_ADD_SITE_BUTTON_LABEL),\n      \"\", /* body */\n      GetResourceString(\n          IDS_SETTINGS_MOUSE_GESTURE_BLOCKLIST_ADD_DIALOG_CANCEL_BUTTON),\n      \"CloseDialog\",\n      GetResourceString(\n          IDS_SETTINGS_MOUSE_GESTURES_BLOCKLIST_DIALOG_ADD_BUTTON),\n      \"OnControlClicked\");\n\n  base::Value::Dict dialog_body_selected_value = base::Value::Dict();\n  base::Value::List dialog_body_forms = base::Value::List();\n\n  {\n    // form url\n    base::Value::Dict form = base::Value::Dict();\n    form.Set(\"name\", \"url\");\n    form.Set(\"fieldType\", (int)mojom::FormFieldType::Input);\n\n    // attributes\n    base::Value::Dict form_attr = base::Value::Dict();\n    form_attr.Set(\"type\", \"url\");\n    form_attr.Set(\"required\", true);\n    form_attr.Set(\n        \"placeholder\",\n        GetResourceString(\n          IDS_SETTINGS_MOUSE_GESTURE_BLOCKLIST_ADD_DIALOG_PLACEHOLDER_TEXT));\n\n    form.Set(\"attributes\", std::move(form_attr));\n\n    // Form: Validator\n    base::Value::List validators = base::Value::List();\n    base::Value::Dict validator = base::Value::Dict();\n    validator.Set(\"name\", \"IEModeUserListValidation\");\n    validator.Set(\"message\",\n                  GetResourceString(IDS_SETTINGS_NOT_VALID_WEB_ADDRESS));\n    validators.Append(std::move(validator));\n    form.Set(\"validator\", std::move(validators));\n\n    dialog_body_forms.Append(std::move(form));\n  }\n  base::Value::Dict dialog_body = base::Value::Dict();\n  dialog_body.Set(\"form\", std::move(dialog_body_forms));\n  button_info.Set(\"body\", std::move(dialog_body));\n  button->info = BuildInfo(std::move(button_info));\n  base::JSONWriter::Write(dialog_body_selected_value, &button->selectedValue);\n}","pos":-1,"query":"Configure dialog button with form validation","filepos":-1,"timecost":980.6653000000224,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\web_apps\\frame_toolbar\\web_app_frame_toolbar_view.cc:51-111","function":"WebAppFrameToolbarView::WebAppFrameToolbarView","codesnippet":"{\n  DCHECK(browser_view_);\n  DCHECK(web_app::AppBrowserController::IsWebApp(browser_view_->browser()));\n  SetID(VIEW_ID_WEB_APP_FRAME_TOOLBAR);\n  SetEventTargeter(std::make_unique<views::ViewTargeter>(this));\n\n  {\n    // TODO(tluk) fix the need for both LayoutInContainer() and a layout\n    // manager for frame layout.\n    views::FlexLayout* layout =\n        SetLayoutManager(std::make_unique<views::FlexLayout>());\n    layout->SetOrientation(views::LayoutOrientation::kHorizontal);\n    layout->SetMainAxisAlignment(views::LayoutAlignment::kEnd);\n    layout->SetCrossAxisAlignment(views::LayoutAlignment::kStretch);\n  }\n\n  const auto* app_controller = browser_view_->browser()->app_controller();\n\n  if (app_controller->HasMinimalUiButtons()) {\n    left_container_ =\n        AddChildView(std::make_unique<WebAppNavigationButtonContainer>(\n            browser_view_, /*toolbar_button_provider=*/this));\n    left_container_->SetProperty(\n        views::kFlexBehaviorKey,\n        views::FlexSpecification(\n            views::LayoutOrientation::kHorizontal,\n            views::MinimumFlexSizeRule::kScaleToMinimumSnapToZero)\n            .WithOrder(2));\n  }\n\n  center_container_ = AddChildView(std::make_unique<views::View>());\n  center_container_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(views::LayoutOrientation::kHorizontal,\n                               views::MinimumFlexSizeRule::kScaleToZero,\n                               views::MaximumFlexSizeRule::kUnbounded)\n          .WithOrder(3));\n\n  right_container_ = AddChildView(\n      std::make_unique<WebAppToolbarButtonContainer>(browser_view, this));\n  right_container_->SetProperty(\n      views::kFlexBehaviorKey,\n      views::FlexSpecification(right_container_->GetFlexRule()).WithOrder(1));\n\n  UpdateStatusIconsVisibility();\n\n  DCHECK(\n      !browser_view_->toolbar_button_provider() ||\n      views::IsViewClass<WebAppFrameToolbarView>(\n          browser_view_->toolbar_button_provider()->GetAsAccessiblePaneView()))\n      << \"This should be the first ToolbarButtorProvider or a replacement for \"\n         \"an existing instance of this class during a window frame refresh.\";\n  browser_view_->SetToolbarButtonProvider(this);\n\n  if (browser_view_->IsWindowControlsOverlayEnabled()) {\n    OnWindowControlsOverlayEnabledChanged();\n  }\n  if (browser_view_->AppUsesBorderlessMode()) {\n    UpdateBorderlessModeEnabled();\n  }\n}","pos":0,"query":"initializeWebAppFrameToolbarView","filepos":0,"timecost":1037.925499999983,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\actor\\tools\\page_tool.cc:43-82","function":"SetClickToolArgs","codesnippet":"{\n  SetMojoTarget(action_info.click().target(), click->target);\n\n  switch (action_info.click().click_type()) {\n    case ClickAction_ClickType::ClickAction_ClickType_LEFT:\n      click->type = actor::mojom::ClickAction::Type::kLeft;\n      break;\n    case ClickAction_ClickType::ClickAction_ClickType_RIGHT:\n      click->type = actor::mojom::ClickAction::Type::kRight;\n      break;\n    case ClickAction_ClickType::ClickAction_ClickType_UNKNOWN_CLICK_TYPE:\n    case ClickAction_ClickType::\n        ClickAction_ClickType_ClickAction_ClickType_INT_MAX_SENTINEL_DO_NOT_USE_:\n    case ClickAction_ClickType::\n        ClickAction_ClickType_ClickAction_ClickType_INT_MIN_SENTINEL_DO_NOT_USE_:\n      // TODO(issuetracker.google.com/412700289): Revert once this is set.\n      click->type = actor::mojom::ClickAction::Type::kLeft;\n      break;\n      // return false;\n  }\n\n  switch (action_info.click().click_count()) {\n    case ClickAction_ClickCount::ClickAction_ClickCount_SINGLE:\n      click->count = actor::mojom::ClickAction::Count::kSingle;\n      break;\n    case ClickAction_ClickCount::ClickAction_ClickCount_DOUBLE:\n      click->count = actor::mojom::ClickAction::Count::kDouble;\n      break;\n    case ClickAction_ClickCount::ClickAction_ClickCount_UNKNOWN_CLICK_COUNT:\n    case ClickAction_ClickCount::\n        ClickAction_ClickCount_ClickAction_ClickCount_INT_MIN_SENTINEL_DO_NOT_USE_:\n    case ClickAction_ClickCount::\n        ClickAction_ClickCount_ClickAction_ClickCount_INT_MAX_SENTINEL_DO_NOT_USE_:\n      // TODO(issuetracker.google.com/412700289): Revert once this is set.\n      click->count = actor::mojom::ClickAction::Count::kSingle;\n      break;\n      // return false;\n  }\n  return true;\n}","pos":129,"query":"SetClickActionProperties","filepos":129,"timecost":1074.6502000000037,"filemrr":0.4},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\views\\autofill\\edge_popup\\edge_popup_cell_utils.cc:128-197","function":"CreateSecondLineItemView","codesnippet":"{\n  std::unique_ptr<views::BoxLayoutView> second_line_view =\n      views::Builder<views::BoxLayoutView>()\n          .SetOrientation(views::BoxLayout::Orientation::kHorizontal)\n          .Build();\n  second_line_view->SetCrossAxisAlignment(\n      views::BoxLayout::CrossAxisAlignment::kStart);\n  second_line_view->SetInsideBorderInsets(insets);\n\n  std::unique_ptr<views::Label> text_label;\n  if (PopupMainViewV2::IsEdgeAutofillSavedPasswordTokenized()) {\n    const gfx::FontList& font_list = views::TypographyProvider::Get().GetFont(\n        views::style::CONTEXT_LABEL, views::style::STYLE_CAPTION);\n    text_label = CreateTextLabel(line_items[index++], font_list.GetFontWeight(),\n                                 kColorEdgeAutofillPopupHeaderText,\n                                 font_list.GetHeight(), font_list.GetFontSize());\n  } else {\n    text_label =\n        CreateTextLabel(line_items[index++], gfx::Font::Weight::NORMAL,\n                        kColorEdgeAutofillPopupText, kDefaultSecondLineHeight,\n                        kDefaultSecondLineFontSize);\n  }\n  SetTooltip(text_label, tooltip);\n  auto* first_label_view =\n      second_line_view->AddChildView(std::move(text_label));\n\n  int available_width = kPopupLineWidth;\n  int separator_width = 0;\n  // second label creation and setting label width dynamically.\n  if (index < line_items.size()) {\n    std::unique_ptr<views::Label> separator_space =\n        CreateSeparatorSpaceView(tooltip);\n    auto* separator_view =\n        second_line_view->AddChildView(std::move(separator_space));\n    // second label creation.\n    std::unique_ptr<views::Label> second_label =\n        CreateTextLabel(line_items[index++], gfx::Font::Weight::NORMAL,\n                        kColorEdgeAutofillPopupText, kDefaultSecondLineHeight,\n                        kDefaultSecondLineFontSize);\n    SetTooltip(second_label, tooltip);\n    auto* second_label_view =\n        second_line_view->AddChildView(std::move(second_label));\n    separator_width = separator_view->GetPreferredSize().width();\n    available_width -= separator_width;\n    available_width -= SetDynamicWidthForLabels(\n        first_label_view, second_label_view, available_width);\n  }\n\n  // Add Remaining Labels third, fourth, if line width is available.\n  while (index < line_items.size() && available_width > separator_width) {\n    // Separator creation.\n    std::unique_ptr<views::Label> separator_space =\n        CreateSeparatorSpaceView(tooltip);\n    second_line_view->AddChildView(std::move(separator_space));\n    // Another label creation.\n    text_label =\n        CreateTextLabel(line_items[index++], gfx::Font::Weight::NORMAL,\n                        kColorEdgeAutofillPopupText, kDefaultSecondLineHeight,\n                        kDefaultSecondLineFontSize);\n    SetTooltip(text_label, tooltip);\n    auto* text_label_view =\n        second_line_view->AddChildView(std::move(text_label));\n    available_width -=\n        separator_width + text_label_view->GetPreferredSize().width();\n  }\n  return second_line_view;\n}","pos":-1,"query":"createHorizontalLabelViewWithDynamicWidth","filepos":-1,"timecost":1453.4582000000228,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_hub_apps\\app_icon_auto_show\\mm2_utils.cc:167-210","function":"MM2_Utils::CheckTheMuteStateOfRelatedHubsForApp","codesnippet":"{\n  bool is_audible = false;\n  bool is_muted = true;\n  bool has_media = false;\n  bool is_paused = false;\n\n  for (Browser* browser : *BrowserList::GetInstance()) {\n    if (browser->profile() != profile) {\n      continue;\n    }\n\n    auto* edge_side_pane = EdgeSidePane::ForBrowser(browser);\n    if (!edge_side_pane) {\n      continue;\n    }\n    // TODO: If SidePane supports multiple WebContents, we need to update this\n    // logic\n    content::WebContents* hub_web_contents =\n        edge_side_pane->GetWebContentsForContentID(hub_content_id);\n    if (!hub_web_contents) {\n      continue;\n    }\n    bool audible = hub_web_contents->IsCurrentlyAudible();\n\n    auto* hub_content_media_session =\n        HubContentMediaSession::FromWebContents(hub_web_contents);\n    if (hub_content_media_session && hub_content_media_session->is_active()) {\n      has_media = true;\n      is_paused = !hub_content_media_session->is_playing();\n    }\n\n    const bool muted = audible ? (hub_web_contents->IsAudioMuted() ||\n                                  hub_web_contents->EdgeIsAppMuted())\n                               : true;\n\n    // If any of the tabs is audible, then the hub is audible.\n    is_audible |= audible;\n    // If any of the tabs is not muted, then the hub is not muted.\n    is_muted &= muted;\n  }\n  return {is_audible, is_muted, has_media, is_paused};\n}","pos":-1,"query":"determineMediaStateForProfile","filepos":274,"timecost":1208.731700000004,"filemrr":0.9},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\search\\essential_search\\essential_search_manager.cc:230-263","function":"EssentialSearchManager::OnCookieAddedToUserProfile","codesnippet":"{\n  // Notify the test that OnCookieAddedToUserProfile has been triggered.\n  if (cookie_insertion_closure_for_test_) {\n    CHECK_IS_TEST();\n    std::move(cookie_insertion_closure_for_test_).Run();\n  }\n\n  if (!result.status.IsInclude()) {\n    // Handle SOCS cookie insertion failure.\n    LOG(WARNING) << \"Failed to add SOCS cookie to user profile. Retrying.\";\n    LOG(WARNING) << \"Status=\" << result.status;\n    OnApiCallFailed(SocsCookieFetcher::Status::kCookieInsertionFailure);\n    return;\n  }\n\n  // Log success of fetching the cookie and adding it to the user profile.\n  LogStatus(SocsCookieFetcher::Status::kOk);\n\n  // After the SOCS cookie is added to the user profile, Schedule a SOCS cookie\n  // refresh to ensure a valid SOCS cookie is maintained.\n  temporary_disable_search_suggest_ = false;\n  RefetchAfter(kOneDay);\n  retry_backoff_.InformOfRequest(true);\n  PrefService* prefs = primary_profile_->GetPrefs();\n  if (prefs->GetBoolean(prefs::kEssentialSearchEnabled)) {\n    // If the kEssentialSearchEnabled policy is still enabled, mark\n    // kLastEssentialSearchValue as enabled.\n    prefs->SetBoolean(prefs::kLastEssentialSearchValue, true);\n  } else {\n    // This would be triggered in case the policy got disabled while storing the\n    // cookie.\n    RemoveSocsCookie();\n  }\n}","pos":-1,"query":"Handle SOCS cookie insertion and refresh","filepos":-1,"timecost":703.4181999999855,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\media\\router\\providers\\cast\\cast_media_route_provider.cc:91-129","function":"GetRemotePlaybackMediaSourceCompatibleSinks","codesnippet":"{\n  DCHECK(media_source.IsRemotePlaybackSource());\n  std::vector<MediaSinkInternal> compatible_sinks;\n\n  // Return an empty list if the source URL contains invalid codecs. It's\n  // possible that the source URL doesn't include an audio codec, which means\n  // the media content doesn't have an audio track. However, there must exist a\n  // valid video codec.\n  auto video_codec = ParseVideoCodec(media_source);\n  if (!video_codec.has_value() ||\n      video_codec.value() == media::VideoCodec::kUnknown) {\n    return compatible_sinks;\n  }\n  auto audio_codec = ParseAudioCodec(media_source);\n  if (audio_codec.has_value() &&\n      audio_codec.value() == media::AudioCodec::kUnknown) {\n    return compatible_sinks;\n  }\n\n  for (const auto& sink : sinks) {\n    const std::string& model_name = sink.cast_data().model_name;\n    const bool is_supported_model =\n        media::remoting::IsKnownToSupportRemoting(model_name);\n    const bool is_supported_video_codec =\n        media::remoting::IsVideoCodecCompatible(model_name,\n                                                video_codec.value());\n    const bool is_supported_audio_codec =\n        audio_codec.has_value() ? media::remoting::IsAudioCodecCompatible(\n                                      model_name, audio_codec.value())\n                                : true;\n\n    if (is_supported_model && is_supported_video_codec &&\n        is_supported_audio_codec) {\n      compatible_sinks.push_back(sink);\n    }\n  }\n  return compatible_sinks;\n}","pos":-1,"query":"filterCompatibleMediaSinks","filepos":-1,"timecost":1129.9158999999927,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\edge_agent\\agent_browser_manager.cc:171-222","function":"AgentBrowserManager::OnBrowserRemoved","codesnippet":"{\n  if (is_closing_) {\n    // All sessions are already being destroyed.\n    return;\n  }\n\n  if (!browser || !browser->profile()) {\n    // Browser is not valid or profile is not valid.\n    return;\n  }\n\n  if (!profile_) {\n    // Current profile is not valid.\n    return;\n  }\n\n  // Only handle the browser removal for the current profile.\n  if (browser->profile() != profile_.get()) {\n    return;\n  }\n\n  // Get the browser count for the current profile.\n  // TODO(ankk): How do we want to handle when there is an incognito browser for\n  // the profile?\n  const int browser_count = chrome::GetBrowserCount(profile_.get());\n  // Get the agent browser count for the current profile.\n  // Asssumes that `agent_background_browser_map_` always has a 1-1 mapping with\n  // an active session.\n  const int agent_browser_count = agent_background_browser_map_.size();\n\n  // `browser_count` should always be greater than or equal to\n  // `agent_browser_count`.\n  DCHECK(browser_count >= agent_browser_count);\n\n  if ((browser_count - agent_browser_count) > 0) {\n    // There is a user browser that is not an agent browser.\n    return;\n  }\n\n  base::AutoReset<bool> auto_reset(&is_closing_, true);\n\n  // No user browser is available, so we should close all the active sessions.\n  // Collect browsers to close to avoid iterator invalidation.\n  std::vector<Browser*> browsers_to_close;\n  for (const auto& pair : agent_background_browser_map_) {\n    browsers_to_close.push_back(pair.second);\n  }\n  for (Browser* background_browser : browsers_to_close) {\n    if (!background_browser->IsBrowserClosing()) {\n      background_browser->window()->Close();\n    }\n  }\n}","pos":-1,"query":"closeAllAgentBrowsersIfNoUserBrowser","filepos":144,"timecost":1637.578600000008,"filemrr":0.5},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\app_list\\search\\os_settings_provider.cc:281-314","function":"OsSettingsProvider::Start","codesnippet":"{\n  // Disable the provider if:\n  //  - the search backend isn't available\n  //  - the settings app isn't ready\n  //  - we don't have an icon to display with results.\n  if (!search_handler_) {\n    // If user has started to user launcher search before the user session\n    // startup tasks completed, we should honor this user action and\n    // initialize the provider. It makes the os setting search available\n    // earlier.\n    MaybeInitialize();\n    return;\n  } else if (icon_.IsEmpty()) {\n    LogStatus(Status::kNoSettingsIcon);\n    return;\n  }\n\n  // Do not return results for queries that are too short, as the results\n  // generally aren't meaningful. Note this provider never provides zero-state\n  // results.\n  if (query.size() < min_query_length_) {\n    return;\n  }\n\n  const base::TimeTicks start_time = base::TimeTicks::Now();\n  last_query_ = query;\n\n  // Invalidate weak pointers to cancel existing searches.\n  weak_factory_.InvalidateWeakPtrs();\n  search_handler_->Search(\n      query, kNumRequestedResults,\n      ash::settings::mojom::ParentResultBehavior::kDoNotIncludeParentResults,\n      base::BindOnce(&OsSettingsProvider::OnSearchReturned,\n                     weak_factory_.GetWeakPtr(), query, start_time));\n}","pos":-1,"query":"Initialize and execute settings search","filepos":-1,"timecost":1073.7654999999795,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\system_web_apps\\apps\\personalization_app\\personalization_app_ambient_provider_impl.cc:600-639","function":"PersonalizationAppAmbientProviderImpl::OnSettingsAndAlbumsFetched","codesnippet":"{\n  // `settings` value implies success.\n  if (!settings) {\n    fetch_settings_retry_backoff_.InformOfRequest(/*succeeded=*/false);\n    if (fetch_settings_retry_backoff_.failure_count() > kMaxRetries) {\n      return;\n    }\n\n    const base::TimeDelta kDelay =\n        fetch_settings_retry_backoff_.GetTimeUntilRelease();\n    base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\n        FROM_HERE,\n        base::BindOnce(\n            &PersonalizationAppAmbientProviderImpl::FetchSettingsAndAlbums,\n            read_weak_factory_.GetWeakPtr()),\n        kDelay);\n    return;\n  }\n\n  fetch_settings_retry_backoff_.Reset();\n  settings_ = settings;\n  cached_settings_ = settings;\n  personal_albums_ = std::move(personal_albums);\n  SyncSettingsAndAlbums();\n\n  OnTemperatureUnitChanged();\n\n  // Notify `OnAlbumsChanged()` first because the albums info is needed to\n  // render the description text of the topic source buttons. E.g. if the Google\n  // Photos album is empty, it will show different text.\n  OnAlbumsChanged();\n  OnTopicSourceChanged();\n\n  // If weather info is disabled, call `UpdateSettings()` immediately to force\n  // it to true. Please see b/177456397.\n  if (!settings_->show_weather && IsAmbientModeEnabled()) {\n    UpdateSettings();\n  }\n}","pos":-1,"query":"Handle settings fetch and update state","filepos":49,"timecost":1978.397399999987,"filemrr":0.2},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_wdag\\internals_ui_message_handler_win.cc:62-172","function":"InternalsUIMessageHandler::RegisterMessages","codesnippet":"{\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  web_ui()->RegisterMessageCallback(\n      \"getPolicies\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetPolicies,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getContainerState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetContainerState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getServiceState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetServiceState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getRelatedProcesses\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetRelatedProcesses,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"doRestartRelatedProcesses\",\n      base::BindRepeating(\n          &InternalsUIMessageHandler::OnDoRestartRelatedProcesses,\n          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getMachineCapabilities\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetMachineCapabilities,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getUrlTrust\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetUrlTrust,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getCommandLine\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetCommandLine,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getProxyConfiguration\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetProxyConfiguration,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getCaptivePortalState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetCaptivePortalState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"simulateCaptivePortal\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnSimulateCaptivePortal,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"doPing\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnDoPing,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getFeatures\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetFeatures,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getStandaloneModeState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetStandaloneModeState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"changeFeatureState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnChangeFeatureState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getState\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"suspendDynamicNavigationFor6Hours\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnSuspend6Hours,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"suspendDynamicNavigationUntilRestart\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnSuspendUntilRestart,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"resumeDynamicNavigation\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnResume,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"isInternalUser\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetUserState,\n                          base::Unretained(this)));\n\n  web_ui()->RegisterMessageCallback(\n      \"getLog\",\n      base::BindRepeating(&InternalsUIMessageHandler::OnGetLog,\n                          base::Unretained(this)));\n\n  // NOTE: When adding new APIs, keep in mind that these can be invoked\n  // on platforms that don't support WDAG (Win7), so add checks as needed.\n}","pos":-1,"query":"RegisterWebUICallbacks","filepos":-1,"timecost":1301.0645999999833,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\notifications\\notifications_api.cc:118-182","function":"NotificationBitmapToGfxImage","codesnippet":"{\n  const int max_device_pixel_width = target_size_dips.width() * max_scale;\n  const int max_device_pixel_height = target_size_dips.height() * max_scale;\n\n  const int kBytesPerPixel = 4;\n\n  const int width = notification_bitmap.width;\n  const int height = notification_bitmap.height;\n\n  if (width < 0 || height < 0 || width > max_device_pixel_width ||\n      height > max_device_pixel_height)\n    return false;\n\n  // Ensure we have rgba data.\n  if (!notification_bitmap.data) {\n    return false;\n  }\n\n  const std::vector<uint8_t>& rgba_data = *notification_bitmap.data;\n\n  const size_t rgba_data_length = rgba_data.size();\n  const size_t rgba_area = width * height;\n\n  if (rgba_data_length != rgba_area * kBytesPerPixel)\n    return false;\n\n  SkBitmap bitmap;\n  // Allocate the actual backing store with the sanitized dimensions.\n  std::vector<uint32_t> pixels(rgba_area);\n  SkImageInfo info = SkImageInfo::MakeN32Premul(width, height);\n  bitmap.setInfo(info, width * kBytesPerPixel);\n  bitmap.setPixels(&pixels[0]);\n\n  // Ensure that our bitmap and our data now refer to the same number of pixels.\n  if (rgba_data_length != bitmap.computeByteSize())\n    return false;\n\n  for (size_t t = 0; t < rgba_area; ++t) {\n    // `rgba_data` is RGBA, pixels is ARGB.\n    size_t rgba_index = t * kBytesPerPixel;\n    pixels[t] = SkPreMultiplyColor(((rgba_data[rgba_index + 3] & 0xFF) << 24) |\n                                   ((rgba_data[rgba_index + 0] & 0xFF) << 16) |\n                                   ((rgba_data[rgba_index + 1] & 0xFF) << 8) |\n                                   ((rgba_data[rgba_index + 2] & 0xFF) << 0));\n  }\n\n  // Make a copy, since the current bitmap is using a local std::vector for\n  // storage.\n  SkBitmap copy;\n  if (!copy.tryAllocPixels(bitmap.info())) {\n    return false;\n  }\n\n  // Copy the bitmap.\n  bitmap.readPixels(copy.pixmap());\n\n  // TODO(dewittj): Handle HiDPI images with more than one scale factor\n  // representation.\n  gfx::ImageSkia skia = gfx::ImageSkia::CreateFromBitmap(copy, 1.0f);\n  *return_image = gfx::Image(skia);\n  return true;\n}","pos":-1,"query":"validateAndConvertBitmapToImage","filepos":-1,"timecost":1062.3315000000002,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ash\\login\\marketing_backend_connector.cc:148-190","function":"MarketingBackendConnector::SetTokenAndStartRequest","codesnippet":"{\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"chromebook_mail_api\", R\"(\n      semantics {\n        sender: \"Chrome OS Marketing Opt-In Screen\"\n        description:\n          \"Communication with the Chromebook Email API to change the user's \"\n          \"preference regarding marketing emails. It is only used on the \"\n          \"last screen of the Chrome OS OOBE - Marketing Opt-In Screen.\"\n        trigger:\n          \"The request is triggered when the user opts-in for marketing \"\n          \"emails by enabling the toggle on the marketing opt-in screen.\"\n        data:\n          \"The only transmitted information is the country and the language \"\n          \"of the user's account. This information is used for delivering \"\n          \"emails to the user in the requested language.\"\n        destination: GOOGLE_OWNED_SERVICE\n      }\n      policy {\n        setting:\n          \"Not opting-in to the emails will not generate a request.\"\n        cookies_allowed: NO\n        policy_exception_justification:\n          \"Managed users are not presented with the option to opt-in.\"\n      }\n      )\");\n\n  auto resource_request = GetResourceRequest();\n  resource_request->headers.SetHeader(net::HttpRequestHeaders::kAuthorization,\n                                      std::string(\"Bearer \") + access_token_);\n\n  simple_url_loader_ = network::SimpleURLLoader::Create(\n      std::move(resource_request), traffic_annotation);\n\n  simple_url_loader_->SetAllowHttpErrorResults(true);\n  simple_url_loader_->AttachStringForUpload(GetRequestContent(),\n                                            \"application/json\");\n\n  url_loader_factory_ = profile_->GetURLLoaderFactory();\n  simple_url_loader_->DownloadToString(\n      url_loader_factory_.get(),\n      base::BindOnce(&MarketingBackendConnector::OnSimpleLoaderComplete, this),\n      kResponseMaxBodySize);\n}","pos":-1,"query":"sendMarketingEmailOptInRequest","filepos":-1,"timecost":1309.8766000000178,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\web_applications\\edge_web_app_link_handling_utils.cc:58-89","function":"IsDelegatedWebFeaturesSccdInFilePath","codesnippet":"{\n  static bool kIsDelegatedWebFeaturesSccdInFilePath = true;\n  static bool kCheckedDelegatedWebFeaturesSccd = false;\n\n  if (!kCheckedDelegatedWebFeaturesSccd) {\n    kCheckedDelegatedWebFeaturesSccd = true;\n\n    base::FilePath edge_exe_path;\n    if (!base::PathService::Get(base::FILE_EXE, &edge_exe_path)) {\n      // Let OS link handling try to work if wrong Edge exe dir was checked.\n      kIsDelegatedWebFeaturesSccdInFilePath = true;\n      web_app::web_app_metrics::RecordLinkHandlingSccdFileStatus(\n          web_app::web_app_metrics::LinkHandlingSccdFileStatus::\n              kCheckedWrongDirectory);\n    } else {\n      const base::FilePath sccd_file_path = edge_exe_path.DirName().Append(\n          FILE_PATH_LITERAL(\"delegatedWebFeatures.sccd\"));\n      base::ThreadPool::PostTaskAndReplyWithResult(\n          FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},\n          base::BindOnce(&base::PathExists, sccd_file_path),\n          base::BindOnce([](bool exists) {\n            kIsDelegatedWebFeaturesSccdInFilePath = exists;\n            if (!exists) {\n              web_app::web_app_metrics::RecordLinkHandlingSccdFileStatus(\n                  web_app::web_app_metrics::LinkHandlingSccdFileStatus::\n                      kSccdFileNotFound);\n            }\n          }));\n    }\n  }\n\n  return kIsDelegatedWebFeaturesSccdInFilePath;\n}","pos":0,"query":"CheckDelegatedWebFeaturesSccdFilePresence","filepos":0,"timecost":1224.3418999999994,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\ui\\webui\\edge_underside_chat_v2\\edge_underside_chat_v2_command_handler.cc:47-105","function":"UndersideChatCommandHandler::GetUndersideCommandExecutorAsync","codesnippet":"{\n  Browser& browser = GetBrowser();\n\n  if (!IsBrowserValid(&browser)) {\n    RunCallbackOnError(std::move(callback), CommandStatus::kBrowserNotValid);\n    return;\n  }\n\n  // Check if Provider is ready.\n  if (nullptr == HubManager::GetProviderForContent(\n                     &browser, hub_utils::GetUndersideChatHubContentID())) {\n    RunCallbackOnError(std::move(callback),\n                       CommandStatus::kChatNotInstalledYet);\n    return;\n  }\n\n  auto split_callback = base::SplitOnceCallback(std::move(callback));\n  PrepareUndersideChat(std::move(split_callback.second), show_type,\n                       should_create);\n\n  // If chat handler is ready, run the callback immediately.\n  if (auto* chat_ui = GetChatWebUI(&browser)) {\n    if (chat_ui->IsChatHandlerReady()) {\n      std::move(split_callback.first)\n          .Run(std::make_unique<\n                   edge_underside_chat_v2::UndersideCommandExecutor>(\n                   weak_ptr_factory_.GetWeakPtr(), chat_ui->GetChatHandler()),\n               CommandStatus::kHandlerReady);\n      return;\n    }\n\n    // If handler is not present above, subscribe to it and save the callback.\n    if (!subscribed_to_chat_handler_) {\n      // Register for callback notification.\n      auto handler = chat_ui->GetChatHandler();\n      if (!handler) {\n        RunCallbackOnError(std::move(split_callback.first),\n                           CommandStatus::kHandlerNotCreated);\n        return;\n      }\n      handler->SetHandlerReadyCallback(base::BindRepeating(\n          &UndersideChatCommandHandler::OnChatHandlerReadyCallback,\n          weak_ptr_factory_.GetWeakPtr()));\n      subscribed_to_chat_handler_ = true;\n      if (!callback_timeout_.IsRunning()) {\n        callback_timeout_.Start(\n            FROM_HERE, base::Minutes(kEventTimeoutMinutes),\n            base::BindRepeating(\n                &UndersideChatCommandHandler::OnHandlerReadyTimeOut,\n                weak_ptr_factory_.GetWeakPtr()));\n      }\n    }\n\n    // Save the callback.\n    chat_load_callback_list_.push_back(std::move(split_callback.first));\n  }\n}","pos":-1,"query":"Initialize and manage chat handler callbacks","filepos":-1,"timecost":2025.5255999999936,"filemrr":1},{"filePath":"D:\\Edge\\src\\chrome\\browser\\extensions\\api\\omnibox\\omnibox_api.cc:563-602","function":"ApplyDefaultSuggestionForExtensionKeyword","codesnippet":"{\n  DCHECK(keyword->type() == TemplateURL::OMNIBOX_API_EXTENSION);\n\n  std::optional<omnibox::SuggestResult> suggestion(\n      GetOmniboxDefaultSuggestion(profile, keyword->GetExtensionId()));\n  if (!suggestion || suggestion->description.empty())\n    return;  // fall back to the universal default\n\n  const std::u16string kPlaceholderText(u\"%s\");\n  const std::u16string kReplacementText(u\"<input>\");\n\n  std::u16string description = base::UTF8ToUTF16(suggestion->description);\n  ACMatchClassifications& description_styles = match->contents_class;\n\n  const std::vector<api::omnibox::MatchClassification> empty_styles;\n  const std::vector<api::omnibox::MatchClassification>* styles_list =\n      suggestion->description_styles ? &suggestion->description_styles.value()\n                                     : &empty_styles;\n  description_styles =\n      StyleTypesToACMatchClassifications(styles_list, suggestion->description);\n\n  // Replace \"%s\" with the user's input and adjust the style offsets to the\n  // new length of the description.\n  size_t placeholder(description.find(kPlaceholderText, 0));\n  if (placeholder != std::u16string::npos) {\n    std::u16string replacement =\n        remaining_input.empty() ? kReplacementText : remaining_input;\n    description.replace(placeholder, kPlaceholderText.length(), replacement);\n\n    for (auto& description_style : description_styles) {\n      if (description_style.offset > placeholder)\n        description_style.offset += replacement.length() - 2;\n    }\n  }\n\n  match->contents.assign(description);\n}","pos":-1,"query":"Format omnibox suggestion description","filepos":209,"timecost":884.644100000005,"filemrr":0.7},{"filePath":"D:\\Edge\\src\\chrome\\browser\\chromeos\\app_mode\\kiosk_troubleshooting_controller_ash.cc:31-64","function":"KioskTroubleshootingControllerAsh::AcceleratorPressed","codesnippet":"{\n  auto it = accelerators_with_actions_.find(accelerator);\n  if (it == accelerators_with_actions_.end()) {\n    return false;\n  }\n\n  // Block registered accelerators if the troubleshooting tools are disabled.\n  if (!AreKioskTroubleshootingToolsEnabled()) {\n    return true;\n  }\n\n  switch (it->second) {\n    case TroubleshootingAcceleratorAction::NEW_WINDOW:\n      ash::accelerators::NewWindow();\n      return true;\n    case TroubleshootingAcceleratorAction::SWITCH_WINDOWS_FORWARD:\n      ash::accelerators::CycleForwardMru(/*same_app_only=*/false);\n      return true;\n    case TroubleshootingAcceleratorAction::SWITCH_WINDOWS_BACKWARD:\n      ash::accelerators::CycleBackwardMru(/*same_app_only=*/false);\n      return true;\n    case TroubleshootingAcceleratorAction::SHOW_TASK_MANAGER:\n      ash::accelerators::ShowTaskManager();\n      return true;\n    case TroubleshootingAcceleratorAction::OPEN_FEEDBACK_PAGE:\n      ash::accelerators::OpenFeedbackPage();\n      return true;\n    case TroubleshootingAcceleratorAction::TOGGLE_OVERVIEW:\n      ash::accelerators::ToggleOverview();\n      return true;\n  }\n\n  return false;\n}","pos":-1,"query":"Execute troubleshooting accelerator actions","filepos":-1,"timecost":1316.726400000014,"filemrr":1}];
        
        
        // Create table
        const tableContainer = document.getElementById('table-container');
        let tableHTML = '<table><thead><tr><th>File Path</th><th>Function</th><th>Summarize by GPT-4o</th><th>Code Snippet</th></tr></thead><tbody>';
        dataset.forEach(item => {
            tableHTML += `<tr>
                <td title="${item.filePath}"><div class="cell-content">${item.filePath}</div></td>
                <td title="${item.function}"><div class="cell-content">${item.function}</div></td>
                <td title="Click to expand"><div class="cell-content">${item.query}</div></td>
                <td title="Click to expand" class="code-snippet-cell"><div class="cell-content">${item.codesnippet}</div></td>
            </tr>`;
        });
        tableHTML += '</tbody></table>';
        tableContainer.innerHTML = tableHTML;

        // Add click event listener to table cells
        document.querySelectorAll('#table-container td').forEach(cell => {
            const cellContent = cell.querySelector('.cell-content');
            // Add expand indicator if content is truncated
            if (cellContent.scrollHeight > cellContent.clientHeight) {
                cell.setAttribute('title', 'Click to expand/collapse');
                cell.style.position = 'relative';
            }
            
            cell.addEventListener('click', () => {
                cellContent.classList.toggle('expanded');
            });
        });

        // Extract labels (simplified file paths) and position values
        const labels = dataset.map((item, index) => `Item ${index + 1}`);
        const posValues = dataset.map(item => item.pos);
        const fileposValues = dataset.map(item => item.filepos);
        const timecostValues = dataset.map(item => item.timecost); // Extract timecost values
        const filemrrValues = dataset.map(item => item.filemrr); // Extract filemrr values

        // Calculate percentage of pos >= 0
        const fileCount = fileposValues.filter(filepos => filepos >= 0).length;
        const posCount = posValues.filter(pos => pos >= 0).length;
        const totalCount = posValues.length;
        const fileRate = totalCount > 0 ? (fileCount / totalCount * 100).toFixed(2) : 0;
        const posRate = totalCount > 0 ? (posCount / totalCount * 100).toFixed(2) : 0;
        
        // Update the success rate display
        document.getElementById('success-rate').textContent = `file:${fileRate}%, line:${posRate}% (dataset size: ${totalCount})`;
        
        // Create position chart
        const ctxPos = document.getElementById('posChart').getContext('2d');
        new Chart(ctxPos, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'File && line hit',
                    data: posValues,
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: posValues.map(pos => pos < 0 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 1)'),
                    pointBorderColor: posValues.map(pos => pos < 0 ? 'rgb(255, 99, 132)' : 'rgb(54, 162, 235)'),
                    pointRadius: 2,
                    tension: 0.1
                }, {
                    label: 'File hit',
                    data: fileposValues,
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(255, 159, 64, 1)',
                    pointBorderColor: 'rgb(255, 159, 64)',
                    pointRadius: 2,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return dataset[index].filePath;
                            },
                            afterTitle: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return 'Query: ' + dataset[index].query;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Pos'
                        }
                    },
                    x: {
                        display: false
                    }
                }
            }
        });


        // Create timecost chart
        const timeCtx = document.getElementById('timeCostChart').getContext('2d');
        const timeCostValues = dataset.map(item => item.timecost);
        
        new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Time Cost (ms)',
                    data: timeCostValues,
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                    pointBorderColor: 'rgba(75, 192, 192, 1)',
                    pointRadius: 2,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return dataset[index].filePath;
                            },
                            afterTitle: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                return 'Query: ' + dataset[index].query;
                            },
                            afterLabel: function(tooltipItem) {
                                const index = tooltipItem.dataIndex;
                                return 'Time cost: ' + dataset[index].timecost + ' ms';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Time (ms)'
                        }
                    },
                    x: {
                        display: false  // Hide x-axis completely
                    }
                }
            }
        });

        // Create FileMRR histogram
        const ctxFileMrr = document.getElementById('fileMrrHistogram').getContext('2d');
        const fileMrrValues = dataset.map(item => item.filemrr);
        
        // Define bins for histogram (0.0 to 1.0, step 0.1)
        const bins = Array.from({length: 11}, (_, i) => i / 10);
        const mrrLabels = bins.slice(0, -1).map((bin, i) => `${bin.toFixed(1)}-${bins[i+1].toFixed(1)}`);
        
        // Count values in each bin
        const counts = Array(bins.length - 1).fill(0);
        fileMrrValues.forEach(value => {
            if (value >= 0 && value <= 1) {
                const binIndex = Math.min(Math.floor(value * 10), 9);
                counts[binIndex]++;
            }
        });
        
        new Chart(ctxFileMrr, {
            type: 'bar',
            data: {
                labels: mrrLabels,
                datasets: [{
                    label: 'File Distribution (percentage)',
                    data: counts,
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    borderColor: 'rgba(153, 102, 255, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(tooltipItem) {
                                return tooltipItem.formattedValue + ' items';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Count'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'FileMRR Range'
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
